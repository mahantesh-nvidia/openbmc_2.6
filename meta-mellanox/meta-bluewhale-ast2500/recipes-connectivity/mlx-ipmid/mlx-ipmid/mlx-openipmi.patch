diff --git a/.gitignore b/.gitignore
index fa73bc6..e445715 100644
--- a/.gitignore
+++ b/.gitignore
@@ -11,7 +11,6 @@ Makefile.in
 tags
 /configure
 /config.*
-/m4
 /missing
 /libtool
 /ltmain.sh
diff --git a/cmdlang/ipmish.c b/cmdlang/ipmish.c
index fff7285..8a3e5ce 100644
--- a/cmdlang/ipmish.c
+++ b/cmdlang/ipmish.c
@@ -83,6 +83,9 @@ static int done = 0;
 static int evcount = 0;
 static int handling_input = 0;
 static int cmd_redisp = 1;
+#ifdef HAVE_UCDSNMP
+static int do_snmp = 0;
+#endif
 
 static void user_input_ready(int fd, void *data, os_hnd_fd_id_t *id);
 
@@ -290,39 +293,122 @@ snmp_pre_parse(struct snmp_session *session, snmp_ipaddr from)
 
 static struct snmp_session *snmp_session;
 
+struct snmp_fd_data {
+    int fd;
+    os_hnd_fd_id_t *id;
+    struct snmp_fd_data *next;
+};
+
+static struct snmp_fd_data *snmpfd = NULL;
+os_hnd_timer_id_t *snmp_timer = NULL;
+
 static void
-snmp_add_read_fds(selector_t     *sel,
-		  int            *num_fds,
-		  fd_set         *fdset,
-		  struct timeval *timeout,
-		  int            *timeout_invalid,
-		  void           *cb_data)
+snmp_check_read_fds(int fd, void *cb_data, os_hnd_fd_id_t *id)
 {
-    snmp_select_info(num_fds, fdset, timeout, timeout_invalid);
+    fd_set fdset;
+
+    FD_ZERO(&fdset);
+    FD_SET(fd, &fdset);
+    snmp_read(&fdset);
 }
 
 static void
-snmp_check_read_fds(selector_t *sel,
-		    fd_set     *fds,
-		    void       *cb_data)
+snmp_check_timeout(void *cb_data, os_hnd_timer_id_t *id)
 {
-    snmp_read(fds);
+    snmp_timeout();
 }
 
 static void
-snmp_check_timeout(selector_t *sel,
-		   void       *cb_data)
+snmp_setup_fds(os_handler_t *os_hnd)
 {
-    snmp_timeout();
+    int nfds = 0, block = 0, i, rv;
+    fd_set fdset;
+    struct timeval tv;
+    struct snmp_fd_data *fdd, *nfdd, *prev = NULL;
+
+    if (!do_snmp)
+	return;
+
+    FD_ZERO(&fdset);
+    tv.tv_sec = 0;
+    tv.tv_usec = 0;
+    snmp_select_info(&nfds, &fdset, &tv, &block);
+
+    /* Run through the list.  Since the list is kept sorted, we only
+       need one pass. */
+    fdd = snmpfd;
+    for (i = 0; i < nfds; i++) {
+	if (!FD_ISSET(i, &fdset))
+	    continue;
+
+	if (fdd) {
+	    if (fdd->fd == i) {
+		/* Didn't change. */
+		prev = fdd;
+		fdd = fdd->next;
+		continue;
+	    }
+	    if (fdd->fd < i) {
+		/* Current one was deleted. */
+		os_hnd->remove_fd_to_wait_for(os_hnd, fdd->id);
+		if (prev)
+		    prev->next = fdd->next;
+		else
+		    snmpfd = fdd->next;
+		os_hnd->mem_free(fdd);
+		continue;
+	    }
+	}
+
+	/* New one to add. */
+	nfdd = os_hnd->mem_alloc(sizeof(*fdd));
+	if (!nfdd) {
+	    rv = ENOMEM;
+	    goto err;
+	}
+	nfdd->fd = i;
+	rv = os_hnd->add_fd_to_wait_for(os_hnd, i, snmp_check_read_fds,
+					NULL, NULL, &nfdd->id);
+	if (rv)
+	    goto err;
+
+	/* Insert after */
+	if (fdd) {
+	    nfdd->next = fdd->next;
+	    fdd->next = nfdd;
+	} else {
+	    nfdd->next = NULL;
+	    snmpfd = fdd;
+	}
+    }
+
+    if (!block) {
+	os_hnd->stop_timer(os_hnd, snmp_timer);
+    } else {
+	os_hnd->stop_timer(os_hnd, snmp_timer);
+	os_hnd->start_timer(os_hnd, snmp_timer, &tv, snmp_check_timeout, NULL);
+    }
+    return;
+
+ err:
+    fprintf(stderr, "Error handling SNMP fd data: %s\n", strerror(rv));
+    exit(1);
 }
 
 static int
-snmp_init(selector_t *sel)
+snmp_init(os_handler_t *os_hnd)
 {
     struct snmp_session session;
 #ifdef HAVE_NETSNMP
     netsnmp_transport *transport = NULL;
     static char *snmp_default_port = "udp:162";
+    int rv;
+
+    rv = os_hnd->alloc_timer(os_hnd, &snmp_timer);
+    if (rv) {
+	fprintf(stderr, "Could not allocate SNMP timer\n");
+	return -1;
+    }
 
     netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID,
 			   NETSNMP_DS_LIB_MIB_ERRORS,
@@ -361,14 +447,10 @@ snmp_init(selector_t *sel)
 	return -1;
     }
 
-    ipmi_sel_set_read_fds_handler(sel,
-				  snmp_add_read_fds,
-				  snmp_check_read_fds,
-				  snmp_check_timeout,
-				  NULL);
-
     return 0;
 }
+#else
+static void snmp_setup_fds(os_handler_t *os_hnd) { }
 #endif /* HAVE_UCDSNMP */
 
 typedef struct out_data_s
@@ -751,8 +833,10 @@ read_cmd(ipmi_cmd_info_t *cmd_info)
 	printf("> %s", cmdline);
 	fflush(stdout);
 	ipmi_cmdlang_handle(&my_cmdlang, cmdline);
-	while (!cdone)
+	while (!cdone) {
+	    snmp_setup_fds(cmdlang->os_hnd);
 	    cmdlang->os_hnd->perform_one_op(cmdlang->os_hnd, NULL);
+	}
 	done_ptr = NULL;
     }
     fclose(s);
@@ -832,8 +916,10 @@ cleanup_sig(int sig)
     fprintf(stderr, "Exiting due to signal %d\n", sig);
     done = 0;
     ipmi_domain_iterate_domains(shutdown_domain_handler, &done);
-    while (done)
+    while (done) {
+	snmp_setup_fds(cmdlang.os_hnd);
 	cmdlang.os_hnd->perform_one_op(cmdlang.os_hnd, NULL);
+    }
     cleanup_term();
     exit(1);
 }
@@ -899,10 +985,6 @@ main(int argc, char *argv[])
     int              rv;
     int              curr_arg = 1;
     const char       *arg;
-#ifdef HAVE_UCDSNMP
-    int              init_snmp = 0;
-    selector_t       *sel;
-#endif
     os_handler_t     *os_hnd;
     int              use_debug_os = 0;
     char             *colstr;
@@ -947,7 +1029,7 @@ main(int argc, char *argv[])
 	    DEBUG_MSG_ERR_ENABLE();
 #ifdef HAVE_UCDSNMP
 	} else if (strcmp(arg, "--snmp") == 0) {
-	    init_snmp = 1;
+	    do_snmp = 1;
 #endif
 #ifdef HAVE_GLIB
 	} else if (strcmp(arg, "--glib") == 0) {
@@ -969,20 +1051,13 @@ main(int argc, char *argv[])
 
     if (use_debug_os) {
 	os_hnd = &ipmi_debug_os_handlers;
-	rv = sel_alloc_selector(os_hnd, &debug_sel);
+	rv = sel_alloc_selector_nothread(&debug_sel);
 	if (rv) {
 	    fprintf(stderr, "Could not allocate selector\n");
 	    return 1;
 	}
-#ifdef HAVE_UCDSNMP
-	sel = debug_sel;
-#endif
 #ifdef HAVE_GLIB
     } else if (use_glib) {
-#ifdef HAVE_UCDSNMP
-	init_snmp = 0; /* No SNMP support for glib yet. */
-	sel = NULL;
-#endif
 	g_thread_init(NULL);
 	os_hnd = ipmi_glib_get_os_handler(0);
 	if (!os_hnd) {
@@ -1003,10 +1078,6 @@ main(int argc, char *argv[])
 #endif
 #ifdef HAVE_TCL
     } else if (use_tcl) {
-#ifdef HAVE_UCDSNMP
-	init_snmp = 0; /* No SNMP support for tcl yet. */
-	sel = NULL;
-#endif
 	os_hnd = ipmi_tcl_get_os_handler(0);
 	if (!os_hnd) {
 	    fprintf(stderr,
@@ -1021,9 +1092,6 @@ main(int argc, char *argv[])
 		    "ipmi_smi_setup_con: Unable to allocate os handler\n");
 	    return 1;
 	}
-#ifdef HAVE_UCDSNMP
-	sel = ipmi_posix_os_handler_get_sel(os_hnd);
-#endif
     }
 
     os_hnd->set_log_handler(os_hnd, my_vlog);
@@ -1032,8 +1100,8 @@ main(int argc, char *argv[])
     ipmi_init(os_hnd);
 
 #ifdef HAVE_UCDSNMP
-    if (init_snmp) {
-	if (snmp_init(sel) < 0)
+    if (do_snmp) {
+	if (snmp_init(os_hnd) < 0)
 	    return 1;
     }
 #endif
@@ -1057,8 +1125,10 @@ main(int argc, char *argv[])
 	fflush(stdout);
 	done_ptr = &cdone;
 	rl_ipmish_cb_handler(e->str);
-	while (!cdone)
+	while (!cdone) {
+	    snmp_setup_fds(os_hnd);
 	    os_hnd->perform_one_op(os_hnd, NULL);
+	}
 	done_ptr = NULL;
 	free(e);
 	read_nest = 0;
@@ -1069,8 +1139,10 @@ main(int argc, char *argv[])
     handling_input = 1;
     enable_term_fd(&cmdlang);
 
-    while (!done)
+    while (!done) {
+	snmp_setup_fds(os_hnd);
 	os_hnd->perform_one_op(os_hnd, NULL);
+    }
 
     cleanup_term();
 
@@ -1078,8 +1150,10 @@ main(int argc, char *argv[])
     
     done = 0;
     ipmi_domain_iterate_domains(shutdown_domain_handler, &done);
-    while (done)
+    while (done) {
+	snmp_setup_fds(os_hnd);
 	os_hnd->perform_one_op(os_hnd, NULL);
+    }
 
     ipmi_cmdlang_cleanup();
     ipmi_shutdown();
diff --git a/configure.ac b/configure.ac
index 5103556..e02b324 100644
--- a/configure.ac
+++ b/configure.ac
@@ -277,6 +277,15 @@ AC_ARG_WITH(marvell-bmc,
 )
 AC_SUBST([MARVELL_BMC_DIR])
 
+MELLANOX_DIR=
+AC_ARG_WITH(mellanox,
+[  --with-mellanox            Enable the Mellanox BMC.],
+    AC_DEFINE(MLX_IPMID, 1, [define to 1])
+    AM_CONDITIONAL([MLX_IPMID],[true])
+    MELLANOX_DIR=mellanox
+)
+AC_SUBST([MELLANOX_DIR])
+
 AM_PROG_CC_C_O
 AC_PROG_LIBTOOL
 AC_STDC_HEADERS
@@ -850,6 +859,13 @@ OPENIPMI_SWIG_SO="${PYTHON_POSIX_SO}:\$(top_builddir)/lib/.libs/libOpenIPMI.so:\
 AC_SUBST(OPENIPMI_SWIG_LIBS)
 AC_SUBST(OPENIPMI_SWIG_SO)
 
+AX_HAVE_EPOLL_PWAIT(
+   [AX_CONFIG_FEATURE_ENABLE(epoll_pwait)],
+   [AX_CONFIG_FEATURE_DISABLE(epoll_pwait)])
+AX_CONFIG_FEATURE(
+   [epoll_pwait], [This platform supports epoll(7) with epoll_pwait(2)],
+   [HAVE_EPOLL_PWAIT], [This platform supports epoll(7) with epoll_pwait(2).])
+
 # Everything from here to AC_OUTPUT is for libedit
 
 # AC_PROG_LIBTOOL runs AC_CANONICAL_HOST
@@ -919,6 +935,7 @@ AC_OUTPUT(Makefile
 	  lanserv/OpenIPMI/Makefile
 	  lanserv/sdrcomp/Makefile
 	  lanserv/marvell-bmc/Makefile
+	  lanserv/mellanox/Makefile
 	  sample/Makefile
 	  doc/Makefile
 	  man/Makefile
diff --git a/include/OpenIPMI/Makefile.am b/include/OpenIPMI/Makefile.am
index 13b0a24..09fa91c 100644
--- a/include/OpenIPMI/Makefile.am
+++ b/include/OpenIPMI/Makefile.am
@@ -7,7 +7,12 @@ pkginclude_HEADERS = \
 	ipmi_cmdlang.h	ipmiif.h	ipmi_pef.h	ipmi_types.h	\
 	ipmi_conn.h	ipmi_lan.h	ipmi_pet.h	ipmi_ui.h	\
 	ipmi_debug.h	ipmi_lanparm.h	ipmi_picmg.h	ipmi_string.h	\
-	ipmi_sol.h	ipmi_solparm.h	ipmi_tcl.h
+	ipmi_sol.h	ipmi_solparm.h	ipmi_tcl.h	deprecator.h
+
+if MLX_IPMID
+pkginclude_HEADERS += \
+	ipmi_mlx.h
+endif
 
 SUBDIRS = internal
 
diff --git a/include/OpenIPMI/deprecator.h b/include/OpenIPMI/deprecator.h
new file mode 100644
index 0000000..f70947c
--- /dev/null
+++ b/include/OpenIPMI/deprecator.h
@@ -0,0 +1,47 @@
+/*
+ * deprecator.h
+ *
+ * MontaVista IPMI deprecation defines
+ *
+ * Author: MontaVista Software, Inc.
+ *         Corey Minyard <minyard@mvista.com>
+ *         source@mvista.com
+ *
+ * Copyright 2016 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this program; if not, write to the Free
+ *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __IPMI_DEPRECATOR_H
+#define __IPMI_DEPRECATOR_H
+
+#if (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 2))
+# define IPMI_FUNC_DEPRECATED __attribute__ ((deprecated))
+# define IPMI_TYPE_DEPRECATED __attribute__ ((deprecated))
+# define IPMI_VAR_DEPRECATED __attribute__ ((deprecated))
+#else
+# define IPMI_FUNC_DEPRECATED
+# define IPMI_TYPE_DEPRECATED
+# define IPMI_VAR_DEPRECATED
+#endif
+
+#endif /* __IPMI_DEPRECATOR_H */
diff --git a/include/OpenIPMI/ipmi_mlx.h b/include/OpenIPMI/ipmi_mlx.h
new file mode 100644
index 0000000..e24d9a3
--- /dev/null
+++ b/include/OpenIPMI/ipmi_mlx.h
@@ -0,0 +1,84 @@
+/*
+ * ipmi_mlx.h
+ */
+
+#ifndef _IPMI_MLX_H
+#define _IPMI_MLX_H
+
+#include <OpenIPMI/mcserv.h>
+
+#define MLX_AMBIENT_CARRIER_TEMP_SENSOR_NUM 0x01
+#define MLX_AMBIENT_SWITCH_TEMP_SENSOR_NUM  0X02
+#define MLX_PSU1 temp_SENSOR_NUM            0x03
+#define MLX_PSU2 temp_SENSOR_NUM            0x04
+#define MLX_ASIC_TEMP_SENSOR_NUM            0x05
+#define MLX_PSU1_VIN_SENSOR_NUM             0x9A
+#define MLX_PSU1_VOUT_SENSOR_NUM            0x9B
+#define MLX_PSU2_VIN_SENSOR_NUM             0x9C
+#define MLX_PSU2_VOUT_SENSOR_NUM            0x9D
+#define MLX_A2D_1_8V_SENSOR_NUM             0x9E
+#define MLX_A2D_1_2v_SENSOR_NUM             0x9F
+#define MLX_A2D_VCORE_SENSOR_NUM            0xA0
+#define MLX_SWB_12V_SENSOR_NUM              0xA1
+#define MLX_SWB_3_3V_AUX_SENSOR_NUM         0xA2
+#define MLX_SWB_3_3V_SEN_SENSOR_NUM         0xA3
+#define MLX_ADC_12V_SENSOR_NUM              0xA4
+#define MLX_ADC_5V_SENSOR_NUM               0xA5
+#define MLX_ADC_5V_USB_SENSOR_NUM           0xA6
+#define MLX_ADC_3_3V_AUX_SENSOR_NUM         0xA7
+#define MLX_ADC_3_3V_BMC_SENSOR_NUM         0xA8
+#define MLX_ADC_2_5V_DDR_SENSOR_NUM         0xA9
+#define MLX_ADC_1_2V_DDR_SENSOR_NUM         0xAA
+#define MLX_ADC_1_15V_VCORE                 0XAB
+#define MLX_UCD_3_3V_SENSOR_NUM             0xAC
+#define MLX_UCD_1_2V_SENSOR_NUM             0xAD
+#define MLX_UCD_VCORE_SENSOR_NUM            0xAE
+#define MLX_PSU1_PIN_SENSOR_NUM             0x14
+#define MLX_PSU1_POUT_SENSOR_NUM            0X15
+#define MLX_PSU2_PIN_SENSOR_NUM             0x16
+#define MLX_PSU2_POUT_SENSOR_NUM            0X17
+#define MLX_PSU1_IIN_SENSOR_NUM             0X1E
+#define MLX_PSU1_IOUT_SENSOR_NUM            0X1F
+#define MLX_PSU2_IIN_SENSOR_NUM             0X20
+#define MLX_PSU2_IOUT_SENSOR_NUM            0X21
+#define MLX_VCORE_UCD_CURR_SENSOR_NUM       0x22
+#define MLX_UCD_3_3V_SEN_CURR_SENSOR_NUM    0x23
+#define MLX_UCD_1_2V_CURR_SENSOR_NUM        0x24
+#define MLX_FAN1_1_SENSOR_NUM               0x70
+#define MLX_FAN1_2_SENSOR_NUM               0x71
+#define MLX_FAN2_1_SENSOR_NUM               0x72
+#define MLX_FAN2_2_SENSOR_NUM               0x73
+#define MLX_FAN3_1_SENSOR_NUM               0x74
+#define MLX_FAN3_2_SENSOR_NUM               0x75
+#define MLX_FAN4_1_SENSOR_NUM               0x76
+#define MLX_FAN4_2_SENSOR_NUM               0x77
+#define MLX_PSU1_FAN_SENSOR_NUM             0x78
+#define MLX_PSU2_FAN_SENSOR_NUM             0x79
+#define MLX_CPU_STATUS_SENSOR_NUM           0x28
+
+#define MLX_EVENT_TO_SEL_BUF_SIZE           13
+#define MLX_EVENT_DIRECTION_SHIFT           7
+
+void mlx_add_event_to_sel(lmc_data_t    *mc,
+                          unsigned char sensor_type,
+                          unsigned char sensor_num,
+                          unsigned char direction,
+                          unsigned char event_type,
+                          unsigned char offset);
+
+void mlx_mc_pef_apply(lmc_data_t    *mc,
+                       unsigned char record_type,
+                       unsigned char event[13]);
+
+struct mlx_devices_data {
+    unsigned char fan_number;
+    unsigned char fan_tacho_number;
+    unsigned char fan_eeprom_number;
+    unsigned char psu_number;
+	unsigned char status_led_number;
+	unsigned char fan_led_number;
+};
+
+struct mlx_devices_data sys_devices;
+
+#endif /* _IPMI_MLX_H */
diff --git a/include/OpenIPMI/ipmi_posix.h b/include/OpenIPMI/ipmi_posix.h
index 3bb88e2..5890c65 100644
--- a/include/OpenIPMI/ipmi_posix.h
+++ b/include/OpenIPMI/ipmi_posix.h
@@ -36,6 +36,7 @@
 
 #include <OpenIPMI/os_handler.h>
 #include <OpenIPMI/selector.h>
+#include <OpenIPMI/deprecator.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -77,7 +78,7 @@ selector_t *ipmi_posix_os_handler_get_sel(os_handler_t *os_hnd);
  *	exit(1);
  *  }
  *
- *  rv = sel_alloc_selector(os_hnd, &sel);
+ *  rv = sel_alloc_selector_nothread(&sel);
  *  if (rv)
  *      handle_error();
  *
@@ -109,9 +110,12 @@ selector_t *ipmi_posix_thread_os_handler_get_sel(os_handler_t *os_hnd);
 
 /**********************************************************************
  * Special code, like the previous non-threaded ones.  Only needed
- * if you have special selector needs.
+ * if you have special selector needs.  Don't use
+ * ipmi_posix_thread_get_os_handler(), it has no way to set the
+ * wake signal.
  *********************************************************************/
 os_handler_t *ipmi_posix_thread_get_os_handler(void);
+os_handler_t *ipmi_posix_thread_get_os_handler2(int wake_sig);
 void ipmi_posix_thread_free_os_handler(os_handler_t *os_hnd);
 void ipmi_posix_thread_os_handler_set_sel(os_handler_t *os_hnd,
 					  selector_t   *sel);
diff --git a/include/OpenIPMI/ipmi_types.h b/include/OpenIPMI/ipmi_types.h
index 45091e8..8fe85b8 100644
--- a/include/OpenIPMI/ipmi_types.h
+++ b/include/OpenIPMI/ipmi_types.h
@@ -56,20 +56,9 @@
 #ifndef _IPMI_TYPES_H
 #define _IPMI_TYPES_H
 
-#ifndef IPMI_FUNC_DEPRECATED
-# if (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 2))
-#  define IPMI_FUNC_DEPRECATED __attribute__ ((deprecated))
-#  define IPMI_TYPE_DEPRECATED __attribute__ ((deprecated))
-#  define IPMI_VAR_DEPRECATED __attribute__ ((deprecated))
-# else
-#  define IPMI_FUNC_DEPRECATED
-#  define IPMI_TYPE_DEPRECATED
-#  define IPMI_VAR_DEPRECATED
-# endif
-#endif
-
 #include <stdint.h>
 #include <OpenIPMI/ipmi_addr.h>
+#include <OpenIPMI/deprecator.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/include/OpenIPMI/ipmi_ui.h b/include/OpenIPMI/ipmi_ui.h
index 106989c..d8969be 100644
--- a/include/OpenIPMI/ipmi_ui.h
+++ b/include/OpenIPMI/ipmi_ui.h
@@ -44,7 +44,7 @@ extern "C" {
 
 extern os_handler_t ipmi_ui_cb_handlers;
 
-int ipmi_ui_init(selector_t **selector, int full_screen);
+int ipmi_ui_init(os_handler_t *os_hnd, int full_screen);
 void ipmi_ui_shutdown(void);
 
 void ipmi_ui_set_first_domain(ipmi_domain_id_t fdomain_id);
diff --git a/include/OpenIPMI/ipmiif.h.in b/include/OpenIPMI/ipmiif.h.in
index 9cdbf34..d7626a9 100644
--- a/include/OpenIPMI/ipmiif.h.in
+++ b/include/OpenIPMI/ipmiif.h.in
@@ -38,6 +38,7 @@
 #include <OpenIPMI/ipmi_types.h>
 #include <OpenIPMI/ipmi_bits.h>
 #include <OpenIPMI/os_handler.h>
+#include <OpenIPMI/deprecator.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/include/OpenIPMI/selector.h b/include/OpenIPMI/selector.h
index a8262dc..9be81bc 100644
--- a/include/OpenIPMI/selector.h
+++ b/include/OpenIPMI/selector.h
@@ -34,7 +34,6 @@
 #ifndef SELECTOR
 #define SELECTOR
 #include <sys/time.h> /* For timeval */
-#include <OpenIPMI/os_handler.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -45,7 +44,21 @@ struct selector_s;
 typedef struct selector_s selector_t;
 
 /* You have to create a selector before you can use it. */
-int sel_alloc_selector(os_handler_t *os_hnd, selector_t **new_selector);
+
+/* Create a selector for use with threads.  You have to pass in the
+   lock functions and a signal used to wake waiting threads. */
+typedef struct sel_lock_s sel_lock_t;
+int sel_alloc_selector_thread(selector_t **new_selector, int wake_sig,
+			      sel_lock_t *(*sel_lock_alloc)(void *cb_data),
+			      void (*sel_lock_free)(sel_lock_t *),
+			      void (*sel_lock)(sel_lock_t *),
+			      void (*sel_unlock)(sel_lock_t *),
+			      void *cb_data);
+
+  /* Create a selector for use in a single-threaded environment.  No
+     need for locks or wakeups.  This just call the above call with
+     NULL for all the values. */
+int sel_alloc_selector_nothread(selector_t **new_selector);
 
 /* Used to destroy a selector. */
 int sel_free_selector(selector_t *new_selector);
@@ -102,6 +115,18 @@ int sel_start_timer(sel_timer_t    *timer,
 		    struct timeval *timeout);
 
 int sel_stop_timer(sel_timer_t *timer);
+int sel_stop_timer_with_done(sel_timer_t *timer,
+			     sel_timeout_handler_t done_handler,
+			     void *cb_data);
+
+/* Use this for times provided to sel_start_time() */
+void sel_get_monotonic_time(struct timeval *tv);
+
+typedef struct sel_runner_s sel_runner_t;
+typedef void (*sel_runner_func_t)(sel_runner_t *runner, void *cb_data);
+int sel_alloc_runner(selector_t *sel, sel_runner_t **new_runner);
+int sel_free_runner(sel_runner_t *runner);
+int sel_run(sel_runner_t *runner, sel_runner_func_t func, void *cb_data);
 
 /* For multi-threaded programs, you will need to wake the selector
    thread if you add a timer to the top of the heap or change the fd
@@ -146,12 +171,19 @@ typedef void (*ipmi_sel_check_read_fds_cb)(selector_t *sel,
 					   void       *cb_data);
 typedef void (*ipmi_sel_check_timeout_cb)(selector_t *sel,
 					  void       *cb_data);
-void ipmi_sel_set_read_fds_handler(selector_t                 *sel, 
+void ipmi_sel_set_read_fds_handler(selector_t                 *sel,
 				   ipmi_sel_add_read_fds_cb   add,
 				   ipmi_sel_check_read_fds_cb handle,
 				   ipmi_sel_check_timeout_cb  timeout,
 				   void                       *cb_data);
 
+/* DEPRECATED - Do not use any more. */
+
+#include <OpenIPMI/deprecator.h>
+#include <OpenIPMI/os_handler.h>
+int sel_alloc_selector(os_handler_t *os_hnd, selector_t **new_selector)
+  IPMI_FUNC_DEPRECATED;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lanserv/Makefile.am b/lanserv/Makefile.am
index ce0a38c..4bb2be8 100644
--- a/lanserv/Makefile.am
+++ b/lanserv/Makefile.am
@@ -6,8 +6,8 @@ PVERSION="1.0.13"
 
 BUILD_CC = @BUILD_CC@
 
-SUBDIRS = OpenIPMI sdrcomp @MARVELL_BMC_DIR@
-DIST_SUBDIRS = OpenIPMI sdrcomp marvell-bmc
+SUBDIRS = OpenIPMI sdrcomp @MARVELL_BMC_DIR@ @MELLANOX_DIR@
+DIST_SUBDIRS = OpenIPMI sdrcomp marvell-bmc mellanox
 
 AM_CFLAGS = -Wall -Wsign-compare -I$(top_srcdir)/include -DIPMI_CHECK_LOCKS \
 	$(OPENSSLINCS) -DPVERSION="\"$(PVERSION)\""
@@ -15,8 +15,11 @@ AM_CFLAGS = -Wall -Wsign-compare -I$(top_srcdir)/include -DIPMI_CHECK_LOCKS \
 AM_CPPFLAGS = -DSYSCONFDIR='"$(sysconfdir)"' -DSTATEDIR='"$(localstatedir)"'
 
 lib_LTLIBRARIES = libIPMIlanserv.la
-
+if MLX_IPMID
+bin_PROGRAMS = mlx_ipmid ipmilan
+else
 bin_PROGRAMS = ipmi_sim ipmilan
+endif
 
 noinst_PROGRAMS = ipmi_checksum
 
@@ -36,26 +39,38 @@ ipmilan_SOURCES = lanserv.c
 ipmilan_LDADD = $(POPTLIBS) libIPMIlanserv.la -ldl
 ipmilan_LDFLAGS = -rdynamic ../unix/libOpenIPMIposix.la \
 	../utils/libOpenIPMIutils.la
+if MLX_IPMID
+mlx_ipmid_SOURCES = ipmi_sim.c bmc.c emu_cmd.c sol.c \
+	bmc_storage.c bmc_app.c bmc_chassis.c bmc_transport.c \
+	bmc_sensor.c bmc_picmg.c
 
+mlx_ipmid_LDADD = $(POPTLIBS) libIPMIlanserv.la -lpthread
+mlx_ipmid_LDFLAGS = -rdynamic ../unix/libOpenIPMIposix.la \
+	../utils/libOpenIPMIutils.la
+else
 ipmi_sim_SOURCES = ipmi_sim.c bmc.c emu_cmd.c sol.c \
 	bmc_storage.c bmc_app.c bmc_chassis.c bmc_transport.c \
 	bmc_sensor.c bmc_picmg.c
+
 ipmi_sim_LDADD = $(POPTLIBS) libIPMIlanserv.la -lpthread
 ipmi_sim_LDFLAGS = -rdynamic ../unix/libOpenIPMIposix.la \
 	../utils/libOpenIPMIutils.la
+endif
 
 man_MANS = ipmilan.8 ipmi_lan.5 ipmi_sim.1 ipmi_sim_cmd.5
 
 EXTRA_DIST = atca.emu README.vm lan.conf ipmisim1.emu $(man_MANS)
 
+if !MLX_IPMID
 install-data-local:
 	$(INSTALL) -m 755 -d "$(DESTDIR)$(sysconfdir)/ipmi/"; \
-	$(INSTALL) -m 644 $(srcdir)/lan.conf "$(DESTDIR)$(sysconfdir)/ipmi/"; 
-	$(INSTALL) -m 644 $(srcdir)/ipmisim1.emu "$(DESTDIR)$(sysconfdir)/ipmi/"; 
+	$(INSTALL) -m 644 $(srcdir)/lan.conf "$(DESTDIR)$(sysconfdir)/ipmi/";
+	$(INSTALL) -m 644 $(srcdir)/ipmisim1.emu "$(DESTDIR)$(sysconfdir)/ipmi/";
 
 uninstall-local:
 	-rm -f "$(DESTDIR)$(sysconfdir)/ipmi/lan.conf"
 	-rm -f "$(DESTDIR)$(sysconfdir)/ipmi/sim.emu"
 	-rmdir "$(DESTDIR)$(sysconfdir)/ipmi" 2>/dev/null
+endif
 
 CLEANFILES = libIPMIlanserv.map
diff --git a/lanserv/OpenIPMI/mcserv.h b/lanserv/OpenIPMI/mcserv.h
index a51fb74..1f17a96 100644
--- a/lanserv/OpenIPMI/mcserv.h
+++ b/lanserv/OpenIPMI/mcserv.h
@@ -58,6 +58,7 @@
 
 #include <OpenIPMI/msg.h>
 #include <OpenIPMI/os_handler.h>
+#include <config.h>
 
 typedef struct lmc_data_s lmc_data_t;
 
@@ -111,6 +112,7 @@ ipmi_sol_t *ipmi_mc_get_sol(lmc_data_t *mc);
 startcmd_t *ipmi_mc_get_startcmdinfo(lmc_data_t *mc);
 user_t *ipmi_mc_get_users(lmc_data_t *mc);
 pef_data_t *ipmi_mc_get_pef(lmc_data_t *mc);
+int ipmi_mc_is_power_on(lmc_data_t *mc);
 
 void ipmi_mc_destroy(lmc_data_t *mc);
 
diff --git a/lanserv/OpenIPMI/serv.h b/lanserv/OpenIPMI/serv.h
index 32817d8..15c8453 100644
--- a/lanserv/OpenIPMI/serv.h
+++ b/lanserv/OpenIPMI/serv.h
@@ -182,7 +182,6 @@ struct channel_s
 #define HW_OP_IRQ_DISABLE	5
 #define HW_OP_GRACEFUL_SHUTDOWN	6
 #define HW_OP_CHECK_POWER	7
-#define HW_OP_FORCEOFF		8
     unsigned int hw_capabilities; /* Bitmask of above bits for capabilities. */
 #define HW_OP_CAN_RESET(chan) ((chan)->hw_capabilities & (1 << HW_OP_RESET))
 #define HW_OP_CAN_POWER(chan) ((chan)->hw_capabilities & (1 << HW_OP_POWERON))
@@ -328,6 +327,7 @@ struct sys_data_s {
 
 #define DEBUG_RAW_MSG	(1 << 0)
 #define DEBUG_MSG	(1 << 1)
+#define DEBUG_SOL	(1 << 2)
     unsigned int debug;
 
 #define NEW_SESSION			1
diff --git a/lanserv/bmc.c b/lanserv/bmc.c
index bcaca52..162504c 100644
--- a/lanserv/bmc.c
+++ b/lanserv/bmc.c
@@ -582,7 +582,7 @@ int
 ipmi_mc_set_num_leds(lmc_data_t   *mc,
 		     unsigned int count)
 {
-    if (count > MAX_LEDS)
+    if (count > FAN_LED_MAX)
 	return EINVAL;
     if (mc->emu->atca_mode && (count < MIN_ATCA_LEDS))
 	return EINVAL;
@@ -797,9 +797,7 @@ handle_tick(void *info, unsigned int seconds)
 	    /* Waiting for the first kill */
 	    mc->startcmd.wait_poweroff--;
 	    if (mc->startcmd.wait_poweroff == 0) {
-		if (HW_OP_CAN_POWER(mc->channels[15]))
-		    mc->channels[15]->hw_op(mc->channels[15], HW_OP_FORCEOFF);
-		else if (mc->startcmd.vmpid)
+		if (mc->startcmd.vmpid)
 		    ipmi_do_kill(&mc->startcmd, 0);
 		mc->startcmd.wait_poweroff = -mc->startcmd.kill_wait_time;
 	    }
@@ -878,23 +876,14 @@ ipmi_emu_add_mc(emu_data_t    *emu,
     mc->hs_sensor = NULL;
 
     if (emu->atca_mode) {
-	mc->num_leds = 2;
+	mc->num_leds = MIN_ATCA_LEDS;
 
-	/* By default only blue LED has local control. */
-	mc->leds[0].loc_cnt = 1;
-	mc->leds[0].loc_cnt_sup = 1;
-
-	mc->leds[0].def_loc_cnt_color = 1; /* Blue LED */
-	mc->leds[0].def_override_color = 1;
-	mc->leds[0].color_sup = 0x2;
-	mc->leds[0].color = 0x1;
-
-	for (i=1; i<MAX_LEDS; i++) {
+	for (i=0; i<FAN_LED_MAX; i++) {
 	    /* Others default to red */
-	    mc->leds[i].def_loc_cnt_color = 2;
+        mc->leds[i].def_loc_cnt_color = 2;
 	    mc->leds[i].def_override_color = 2;
 	    mc->leds[i].color_sup = 0x2;
-	    mc->leds[i].color = 0x2;
+	    mc->leds[i].color = 0x2; // set RED by default
 	}
     }
 
diff --git a/lanserv/bmc.h b/lanserv/bmc.h
index 10cc773..57c8aee 100644
--- a/lanserv/bmc.h
+++ b/lanserv/bmc.h
@@ -299,10 +299,12 @@ struct lmc_data_s
     const char *chassis_control_prog;
 
     unsigned char power_value;
-#define MAX_LEDS 8
-#define MIN_ATCA_LEDS 2
+#define FAN_LED_MAX 10
+#define PSU_LED_MAX 1
+#define STATUS_LED_MAX 2
+#define MIN_ATCA_LEDS 6
     unsigned int  num_leds;
-    led_data_t leds[MAX_LEDS];
+    led_data_t leds[FAN_LED_MAX];
 
     /* Will be NULL if not valid. */
     sensor_t      *hs_sensor;
diff --git a/lanserv/bmc_app.c b/lanserv/bmc_app.c
index 9a0d482..a4c13cb 100644
--- a/lanserv/bmc_app.c
+++ b/lanserv/bmc_app.c
@@ -41,6 +41,13 @@
 #include <OpenIPMI/ipmi_mc.h>
 #include <OpenIPMI/ipmi_lan.h>
 
+#include <config.h>
+#include <stdlib.h>
+
+#ifdef MLX_IPMID
+#include <OpenIPMI/ipmi_mlx.h>
+#endif
+
 static void
 handle_get_device_id(lmc_data_t    *mc,
 		     msg_t         *msg,
@@ -158,8 +165,38 @@ handle_get_watchdog_timer(lmc_data_t    *mc,
     ipmi_set_uint16(rdata + 7, v);
     v = diff_timeval_dc(&mc->watchdog_time, &zero_tv);
     ipmi_set_uint16(rdata + 5, v);
-    *rdata_len = 7;
+    *rdata_len = 9;
+}
+
+#ifdef MLX_IPMID
+void
+mlx_add_event_to_sel(lmc_data_t    *mc,
+           unsigned char sensor_type,
+           unsigned char sensor_num,
+           unsigned char direction,
+           unsigned char event_type,
+           unsigned char offset)
+{
+    lmc_data_t    *dest_mc;
+    unsigned char data[MLX_EVENT_TO_SEL_BUF_SIZE];
+    int           rv;
+
+    rv = ipmi_emu_get_mc_by_addr(mc->emu, mc->event_receiver, &dest_mc);
+    if (rv)
+        return;
+
+    memset(data, 0, MLX_EVENT_TO_SEL_BUF_SIZE);
+
+    data[4] = mc->ipmb;
+    data[6] = 0x04; /* Event message revision for IPMI 1.5. */
+    data[7] = sensor_type;
+    data[8] = sensor_num;
+    data[9] = (direction << MLX_EVENT_DIRECTION_SHIFT) | event_type;
+    data[10] = offset;
+
+    mc_new_event(dest_mc, 0x02, data);
 }
+#endif
 
 void
 watchdog_timeout(void *cb_data)
@@ -171,11 +208,13 @@ watchdog_timeout(void *cb_data)
     if (!mc->watchdog_running)
 	goto out;
 
+#ifndef MLX_IPMID
     if( !sens ) {
 	// NOTE(noelbk): The watchdog sensor should have been defined
 	// earlier, but don't SEGFAULT if it isn't
 	goto out;
     }
+#endif
 
     if (! mc->watchdog_preaction_ran) {
 	struct timeval tv, now;
@@ -214,25 +253,69 @@ watchdog_timeout(void *cb_data)
  do_full_expiry:
     mc->watchdog_running = 0; /* Stop the watchdog on a timeout */
     mc->watchdog_expired |= (1 << IPMI_MC_WATCHDOG_GET_USE(mc));
+
+#ifdef MLX_IPMID
+    unsigned char status_led_run_str[32];
+    system("echo 1 > /bsp/leds/status/red/brightness");
+    system("echo 0 > /bsp/leds/status/green/brightness");
+    system("echo 0 > /bsp/leds/status/amber/brightness");
+
+    if (sprintf(status_led_run_str,"status_led.py 0x%02x %d 0x%02x\n", 180, 0, 0))
+           system(status_led_run_str);
+
+    /* set "IERR" if IPMI watchdog timeout expired */
+    system("echo 1 > /bsp/environment/cpu_status");
+#endif
+
     switch (IPMI_MC_WATCHDOG_GET_ACTION(mc)) {
     case IPMI_MC_WATCHDOG_ACTION_NONE:
+#ifdef MLX_IPMID
+        /*Uart to BMC*/
+        system("echo 0 > /bsp/reset/uart_sel");
+        mlx_add_event_to_sel(mc, IPMI_SENSOR_TYPE_WATCHDOG_1, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x6);
+#else
 	set_sensor_bit(mc, sens, 0, 1, 0xc0, mc->watchdog_use & 0xf, 0xff, 1);
+#endif
 	break;
 
     case IPMI_MC_WATCHDOG_ACTION_RESET:
+#ifdef MLX_IPMID
+        /*CPU Reset*/
+        system("echo 0 > /bsp/reset/cpu_reset_soft");
+        mlx_add_event_to_sel(mc, IPMI_SENSOR_TYPE_WATCHDOG_1, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x1);
+#else
 	set_sensor_bit(mc, sens, 1, 1, 0xc1, mc->watchdog_use & 0xf, 0xff, 1);
 	bchan->hw_op(bchan, HW_OP_RESET);
+#endif
 	break;
 
     case IPMI_MC_WATCHDOG_ACTION_POWER_DOWN:
+#ifdef MLX_IPMID
+        /*CPU Power-off*/
+        system("echo 0 > /bsp/reset/cpu_reset_hard");
+        mlx_add_event_to_sel(mc, IPMI_SENSOR_TYPE_WATCHDOG_1, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x3);
+#else
 	set_sensor_bit(mc, sens, 2, 1, 0xc2, mc->watchdog_use & 0xf, 0xff, 1);
 	bchan->hw_op(bchan, HW_OP_POWEROFF);
+	if (bchan->stop_cmd)
+	    bchan->stop_cmd(bchan, 0);
+#endif
 	break;
 
     case IPMI_MC_WATCHDOG_ACTION_POWER_CYCLE:
+#ifdef MLX_IPMID
+        /*CPU power cycle*/
+        system("echo 0 > /bsp/reset/cpu_reset_hard");
+        sleep(3);
+        system("echo 1 > /bsp/reset/cpu_reset_hard");
+        mlx_add_event_to_sel(mc, IPMI_SENSOR_TYPE_WATCHDOG_1, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x4);
+#else
 	set_sensor_bit(mc, sens, 3, 1, 0xc3, mc->watchdog_use & 0xf, 0xff, 1);
 	bchan->hw_op(bchan, HW_OP_POWEROFF);
+	if (bchan->stop_cmd)
+	    bchan->stop_cmd(bchan, 0);
 	start_poweron_timer(mc);
+#endif
 	break;
     }
 
@@ -244,12 +327,13 @@ static void
 do_watchdog_reset(lmc_data_t *mc)
 {
     struct timeval tv;
-
+#ifndef MLX_IPMID
     if (IPMI_MC_WATCHDOG_GET_ACTION(mc) ==
 	IPMI_MC_WATCHDOG_ACTION_NONE) {
 	mc->watchdog_running = 0;
 	return;
     }
+#endif
     mc->watchdog_preaction_ran = 0;
 
     /* Timeout is in tenths of a second, offset is in seconds */
@@ -264,8 +348,26 @@ do_watchdog_reset(lmc_data_t *mc)
 	    tv.tv_usec = 0;
 	}
     }
+#ifdef MLX_IPMID
+    unsigned char status_led_run_str[32]; 
+
+    if (mc->watchdog_running != 1) {
+        if (sprintf(status_led_run_str,"status_led.py 0x%02x %d 0x%02x\n", 180, 1, 0))
+            system(status_led_run_str);
+    }
+    mc->sysinfo->stop_timer(mc->watchdog_timer);
+#endif
     mc->watchdog_running = 1;
+#ifndef MLX_IPMID
     mc->sysinfo->start_timer(mc->watchdog_timer, &tv);
+#else
+    if (mc->sysinfo->start_timer(mc->watchdog_timer, &tv))
+        mc->sysinfo->log(mc->sysinfo, OS_ERROR, NULL,
+                         "Failed to reset watchdog timer");
+
+    /* set "Presence detected" on IPMI watchdog start */
+    system("echo 128 > /bsp/environment/cpu_status");
+#endif
 }
 
 static void
diff --git a/lanserv/bmc_chassis.c b/lanserv/bmc_chassis.c
index e7231e3..90d92c8 100644
--- a/lanserv/bmc_chassis.c
+++ b/lanserv/bmc_chassis.c
@@ -63,6 +63,12 @@ set_power(lmc_data_t *mc, int pval)
 {
     int rv = 0;
 
+    if (mc->power_timer) {
+	mc->sysinfo->stop_timer(mc->power_timer);
+	mc->sysinfo->free_timer(mc->power_timer);
+	mc->power_timer = NULL;
+    }
+
     if (mc->chassis_control_set_func) {
 	unsigned char val = !!pval;
 	rv = mc->chassis_control_set_func(mc, CHASSIS_CONTROL_POWER, &val,
@@ -87,9 +93,12 @@ power_timeout(void *cb_data)
 {
     lmc_data_t *mc = cb_data;
 
-    mc->sysinfo->free_timer(mc->power_timer);
-    mc->power_timer = NULL;
-    set_power(mc, 1);
+    if (ipmi_mc_is_power_on(mc)) {
+	struct timeval tv = { 1, 0 };
+	mc->sysinfo->start_timer(mc->power_timer, &tv);
+    } else {
+	set_power(mc, 1);
+    }
 }
 
 int
@@ -125,39 +134,49 @@ handle_get_chassis_capabilities(lmc_data_t    *mc,
     rdata[5] = mc->sysinfo->bmc_ipmb;
 }
 
-static void
-handle_get_chassis_status(lmc_data_t    *mc,
-			  msg_t         *msg,
-			  unsigned char *rdata,
-			  unsigned int  *rdata_len,
-			  void          *cb_data)
+int
+ipmi_mc_is_power_on(lmc_data_t *mc)
 {
-    rdata[0] = 0;
     if (mc->chassis_control_get_func) {
 	unsigned char val;
 	int rv;
 	rv = mc->chassis_control_get_func(mc, CHASSIS_CONTROL_POWER, &val,
 					  mc->chassis_control_cb_data);
-	if (rv) {
-	    rdata[0] = IPMI_UNKNOWN_ERR_CC;
-	    *rdata_len = 1;
-	    return;
-	}
-	rdata[1] = val;
+	if (rv)
+	    return -1;
+	return val;
     } else if (mc->chassis_control_prog) {
 	int val;
 	if (extcmd_getvals(mc->sysinfo, &val, mc->chassis_control_prog,
-			   &chassis_prog[CHASSIS_CONTROL_POWER], 1)) {
-	    rdata[0] = IPMI_UNKNOWN_ERR_CC;
-	    *rdata_len = 1;
-	    return;
-	}
-	rdata[1] = val;
+			   &chassis_prog[CHASSIS_CONTROL_POWER], 1))
+	    return -1;
+	return val;
     } else if (mc->startcmd.vmpid) {
-	rdata[1] = 1;
+	return 1;
     } else if (HW_OP_CAN_POWER(mc->channels[15])) {
 	int rv = mc->channels[15]->hw_op(mc->channels[15], HW_OP_CHECK_POWER);
-	rdata[1] = rv > 0;
+	return rv > 0;
+    }
+    return 0; /* Assume power is off */
+}
+
+static void
+handle_get_chassis_status(lmc_data_t    *mc,
+			  msg_t         *msg,
+			  unsigned char *rdata,
+			  unsigned int  *rdata_len,
+			  void          *cb_data)
+{
+    int rv;
+
+    rdata[0] = 0;
+    rv = ipmi_mc_is_power_on(mc);
+    if (rv < 0) {
+	rdata[0] = IPMI_UNKNOWN_ERR_CC;
+	*rdata_len = 1;
+	return;
+    } else {
+	rdata[0] = !!rv;
     }
     rdata[2] = 0;
     rdata[3] = 0;
@@ -206,12 +225,6 @@ handle_chassis_control(lmc_data_t    *mc,
 	break;
 
     case 2: /* power cycle */
-	rv = start_poweron_timer(mc);
-	if (rv) {
-	    rdata[0] = IPMI_UNKNOWN_ERR_CC;
-	    *rdata_len = 1;
-	    return;
-	}
 	rv = set_power(mc, 0);
 	if (rv == ENOTSUP)
 	    goto no_support;
@@ -220,6 +233,12 @@ handle_chassis_control(lmc_data_t    *mc,
 	    *rdata_len = 1;
 	    return;
 	}
+	rv = start_poweron_timer(mc);
+	if (rv) {
+	    rdata[0] = IPMI_UNKNOWN_ERR_CC;
+	    *rdata_len = 1;
+	    return;
+	}
 	break;
 
     case 3: /* hard reset */
@@ -362,7 +381,8 @@ set_system_boot_options(lmc_data_t    *mc,
 	    break;
 	}
 	break;
-
+    case 3: /* BMC boot flag valid bit clearing, just ignore this for now. */
+	break;
     case 4: /* Boot Info Ack */
 	if (msg->len < 3) {
 	    rdata[0] = IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
diff --git a/lanserv/bmc_picmg.c b/lanserv/bmc_picmg.c
index fdfb6ec..e751874 100644
--- a/lanserv/bmc_picmg.c
+++ b/lanserv/bmc_picmg.c
@@ -40,6 +40,37 @@
 #include <OpenIPMI/ipmi_msgbits.h>
 #include <OpenIPMI/ipmi_picmg.h>
 
+#define LED_STATE_FILE "/sys/class/leds/mlxcpld_i2c:fan"
+
+static const char* red_led[FAN_LED_MAX] =
+{
+    LED_STATE_FILE"1:red/brightness",
+    LED_STATE_FILE"2:red/brightness",
+    LED_STATE_FILE"3:red/brightness",
+    LED_STATE_FILE"4:red/brightness",
+    LED_STATE_FILE"5:red/brightness",
+    LED_STATE_FILE"6:red/brightness",
+    LED_STATE_FILE"7:red/brightness",
+    LED_STATE_FILE"8:red/brightness",
+    LED_STATE_FILE"9:red/brightness",
+    LED_STATE_FILE"10:red/brightness"
+};
+
+static const char* green_led[10] =
+{
+    LED_STATE_FILE"1:green/brightness",
+    LED_STATE_FILE"2:green/brightness",
+    LED_STATE_FILE"3:green/brightness",
+    LED_STATE_FILE"4:green/brightness",
+    LED_STATE_FILE"5:green/brightness",
+    LED_STATE_FILE"6:green/brightness",
+    LED_STATE_FILE"7:green/brightness",
+    LED_STATE_FILE"8:green/brightness",
+    LED_STATE_FILE"9:green/brightness",
+    LED_STATE_FILE"10:green/brightness"
+};
+
+
 int
 ipmi_mc_set_power(lmc_data_t *mc, unsigned char power, int gen_event)
 {
@@ -295,7 +326,7 @@ handle_picmg_cmd_get_fru_led_properties(lmc_data_t    *mc,
 	rdata[3] = 0x00;
     } else {
 	rdata[2] = 0xf; /* We support the first 4 LEDs. */
-	rdata[3] = mc->num_leds = 4; /* How many more do we support? */
+	rdata[3] = mc->num_leds = FAN_LED_MAX; /* How many more do we support? */
     }
     *rdata_len = 4;
 }
@@ -392,6 +423,8 @@ handle_picmg_cmd_set_fru_led_state(lmc_data_t    *mc,
 				   void          *cb_data)
 {
     unsigned int led;
+    FILE *f_green;
+    FILE *f_red;
 
     if (check_msg_length(msg, 3, rdata, rdata_len))
 	return;
@@ -424,12 +457,38 @@ handle_picmg_cmd_set_fru_led_state(lmc_data_t    *mc,
 	mc->leds[led].color = mc->leds[led].def_loc_cnt_color;
 	break;
 
-    case 0xfb:
     case 0xfd:
     case 0xfe:
 	rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
 	*rdata_len = 1;
-	return;
+    return;
+
+    case 0xfb: // temporary added handler to set LED state into 'lamp test' cmnd
+        f_green = fopen(green_led[led], "w");
+        f_red = fopen(red_led[led], "w");
+        if (!f_red || !f_green) {
+            printf("\nUnable to open LED status file");
+            rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+            *rdata_len = 1;
+            return;
+        } else {
+            if (msg->data[5] == 0x2) { //RED
+                fprintf(f_green, "%u", 0);
+                fprintf(f_red, "%u", 1);
+            }
+            else if (msg->data[5] == 0x3) { //GREEN
+                fprintf(f_red, "%u", 0);
+                fprintf(f_green, "%u", 1);
+            }
+            else {
+                rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+                *rdata_len = 1;
+                return;
+            }
+            fclose(f_green);
+        fclose(f_red);
+        }
+        break;
 
     default: /* Override mode */
 	mc->leds[led].loc_cnt = 0;
@@ -453,6 +512,40 @@ handle_picmg_cmd_set_fru_led_state(lmc_data_t    *mc,
     *rdata_len = 2;
 }
 
+static unsigned char get_led_color(unsigned int led, unsigned char *color)
+{
+    FILE *f_green = fopen(green_led[led], "r");
+    FILE *f_red = fopen(red_led[led], "r");
+    char line_green[10];
+    char line_red[10];
+    int red, green;
+
+    if (!f_green || !f_red) {
+        printf("\nUnable to open LED status file");
+        return IPMI_INVALID_DATA_FIELD_CC;
+    }
+
+    if ((0 >= fread(line_green, 1, sizeof(line_green),f_green))||
+         (0 >= fread(line_red, 1, sizeof(line_red),f_red)))
+    {
+                fclose(f_green);
+                fclose(f_red);
+                return IPMI_INVALID_DATA_FIELD_CC;
+    }
+
+    red = strtoul(line_red, NULL, 0);
+    green = strtoul(line_green, NULL, 0);
+    fclose(f_green);
+    fclose(f_red);
+
+    if (red && !green)
+        *color = 2;
+    else
+        *color = 3;
+
+    return 0;
+}
+
 static void
 handle_picmg_cmd_get_fru_led_state(lmc_data_t    *mc,
 				   msg_t         *msg,
@@ -461,6 +554,7 @@ handle_picmg_cmd_get_fru_led_state(lmc_data_t    *mc,
 				   void          *cb_data)
 {
     unsigned int led;
+    unsigned char rv = 0;
 
     if (check_msg_length(msg, 3, rdata, rdata_len))
 	return;
@@ -487,6 +581,13 @@ handle_picmg_cmd_get_fru_led_state(lmc_data_t    *mc,
     if (mc->leds[led].loc_cnt) {
 	rdata[3] = mc->leds[led].off_dur;
 	rdata[4] = mc->leds[led].on_dur;
+
+    rv = get_led_color(led, &mc->leds[led].color);
+    if (!rv) {
+        rdata[0] = rv;
+        *rdata_len = 1;
+    }
+
 	rdata[5] = mc->leds[led].color;
 	*rdata_len = 6;
     } else {
@@ -496,6 +597,14 @@ handle_picmg_cmd_get_fru_led_state(lmc_data_t    *mc,
 	rdata[5] = mc->leds[led].def_loc_cnt_color;
 	rdata[6] = mc->leds[led].off_dur;
 	rdata[7] = mc->leds[led].on_dur;
+
+    rv = get_led_color(led, &mc->leds[led].color);
+    if (!rv) {
+        rdata[0] = rv;
+        *rdata_len = 1;
+    }
+
+
 	rdata[8] = mc->leds[led].color;
 	*rdata_len = 9;
     }
diff --git a/lanserv/bmc_sensor.c b/lanserv/bmc_sensor.c
index 2166dee..9654ae6 100644
--- a/lanserv/bmc_sensor.c
+++ b/lanserv/bmc_sensor.c
@@ -41,11 +41,16 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#include <config.h>
 
 #include <OpenIPMI/ipmi_err.h>
 #include <OpenIPMI/ipmi_msgbits.h>
 #include <OpenIPMI/ipmi_bits.h>
 
+#ifdef MLX_IPMID
+#include <OpenIPMI/ipmi_mlx.h>
+#endif
+
 static void sensor_poll(void *cb_data);
 
 static void
@@ -294,6 +299,77 @@ handle_get_sensor_hysteresis(lmc_data_t    *mc,
     *rdata_len = 3;
 }
 
+#ifdef MLX_IPMID
+static void 
+status_led_control(unsigned char num,
+                   unsigned char direction,
+                   unsigned char type)
+{
+   unsigned char status_led_run_str[32];
+
+    switch (type) {
+    case IPMI_SENSOR_TYPE_TEMPERATURE:
+        switch (num) {
+        case MLX_AMBIENT_CARRIER_TEMP_SENSOR_NUM:
+        case MLX_AMBIENT_SWITCH_TEMP_SENSOR_NUM:
+        case MLX_ASIC_TEMP_SENSOR_NUM:
+            if (sprintf(status_led_run_str,"status_led.py 0x%02x %d 0x%02x\n",num, direction, type))
+                 system(status_led_run_str);
+            break;
+        default:
+            break;
+        }
+        break;
+    case IPMI_SENSOR_TYPE_VOLTAGE:
+        switch (num) {
+        case MLX_UCD_3_3V_SENSOR_NUM:
+        case MLX_UCD_1_2V_SENSOR_NUM:
+        case MLX_UCD_VCORE_SENSOR_NUM:
+        case MLX_PSU1_VIN_SENSOR_NUM:
+        case MLX_PSU2_VIN_SENSOR_NUM:
+        case MLX_A2D_1_8V_SENSOR_NUM:
+            if (sprintf(status_led_run_str,"status_led.py 0x%02x %d 0x%02x\n",num, direction, type))
+                 system(status_led_run_str);
+            break;
+        default:
+            break;
+        }
+        break;
+    case IPMI_SENSOR_TYPE_CURRENT:
+        switch (num) {
+        case MLX_VCORE_UCD_CURR_SENSOR_NUM:
+        case MLX_UCD_3_3V_SEN_CURR_SENSOR_NUM:
+        case MLX_UCD_1_2V_CURR_SENSOR_NUM:
+            if (sprintf(status_led_run_str,"status_led.py 0x%02x %d 0x%02x\n",num, direction, type))
+                 system(status_led_run_str);
+            break;
+        default:
+            break;
+        }
+        break;
+    case IPMI_SENSOR_TYPE_FAN:
+        switch (num) {
+        case MLX_FAN1_1_SENSOR_NUM:
+        case MLX_FAN1_2_SENSOR_NUM:
+        case MLX_FAN2_1_SENSOR_NUM:
+        case MLX_FAN2_2_SENSOR_NUM:
+        case MLX_FAN3_1_SENSOR_NUM:
+        case MLX_FAN3_2_SENSOR_NUM:
+        case MLX_FAN4_1_SENSOR_NUM:
+        case MLX_FAN4_2_SENSOR_NUM:
+            if (sprintf(status_led_run_str,"status_led.py 0x%02x %d 0x%02x\n",num, direction, type))
+                 system(status_led_run_str);
+            break;
+        default:
+            break;
+        }
+        break;
+    default:
+        break;
+    }
+}
+#endif
+
 static void
 do_event(lmc_data_t    *mc,
 	 sensor_t      *sensor,
@@ -333,6 +409,10 @@ do_event(lmc_data_t    *mc,
     data[11] = byte2;
     data[12] = byte3;
 
+#ifdef MLX_IPMID
+    status_led_control(sensor->num, direction, sensor->sensor_type);
+#endif
+
     mc_new_event(dest_mc, 0x02, data);
 }
 
@@ -1506,12 +1586,94 @@ sensor_poll(void *cb_data)
 
 	err = sensor->poll(sensor->cb_data, &val, &errstr);
 	if (err) {
+#ifdef MLX_IPMID
+            if (sensor->enabled) {
+                status_led_control(sensor->num, 0, sensor->sensor_type);
+                sensor->enabled = 0;
+                /* In case PSU1 or PSU2 is power-off/plugged-out add msg to the SEL */
+                switch (sensor->num) {
+                case MLX_PSU1_PIN_SENSOR_NUM:
+                if (access("/bsp/fru/psu1_eeprom", F_OK) == 0) /* AC lost or out-of-range */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x4);
+                else /* Power Supply AC lost */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x3);
+                break;
+                case MLX_PSU2_PIN_SENSOR_NUM:
+                if (access("/bsp/fru/psu1_eeprom", F_OK) == 0)  /* AC lost or out-of-range */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x4);
+                else  /* Power Supply AC lost */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x3);
+                break;
+                    /* In case any FAN is plugged-out sensor can't be read add msg to the SEL */
+                case MLX_FAN1_1_SENSOR_NUM:
+                case MLX_FAN1_2_SENSOR_NUM:
+                if (access("/bsp/fru/fan1_eeprom", F_OK) == 0) /* "Availability State",  "Device Disabled" */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_DISCRETE_DEVICE_ENABLE, 0x0);
+                else /* "Availability State",  "Device Absent" */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_DISCRETE_DEVICE_PRESENCE, 0x0);
+                break;
+                case MLX_FAN2_1_SENSOR_NUM:
+                case MLX_FAN2_2_SENSOR_NUM:
+                if (access("/bsp/fru/fan2_eeprom", F_OK) == 0)  /* "Availability State",  "Device Disabled" */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_DISCRETE_DEVICE_ENABLE, 0x0);
+                else  /* "Availability State",  "Device Absent" */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_DISCRETE_DEVICE_PRESENCE, 0x0);
+                break;
+                case MLX_FAN3_1_SENSOR_NUM:
+                case MLX_FAN3_2_SENSOR_NUM:
+                if (access("/bsp/fru/fan3_eeprom", F_OK) == 0) /* "Availability State",  "Device Disabled" */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_DISCRETE_DEVICE_ENABLE, 0x0);
+                else /* "Availability State",  "Device Absent" */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_DISCRETE_DEVICE_PRESENCE, 0x0);
+                break;
+                case MLX_FAN4_1_SENSOR_NUM:
+                case MLX_FAN4_2_SENSOR_NUM:
+                if (access("/bsp/fru/fan4_eeprom", F_OK) == 0) /* "Availability State",  "Device Disabled" */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_DISCRETE_DEVICE_ENABLE, 0x0);
+                else /* "Availability State",  "Device Absent" */
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_DISCRETE_DEVICE_PRESENCE, 0x0);
+                break;
+                default:
+                    break;
+                }
+            }
+            goto out_restart;
+#else
 	    mc->sysinfo->log(mc->sysinfo, OS_ERROR, NULL,
 			     "Error getting sensor value (%2.2x,%d,%d): %s, %s",
 			     ipmi_mc_get_ipmb(mc), sensor->lun, sensor->num,
 			     strerror(err), errstr);
+#endif /* MLX_IPMID */
 	    goto out_restart;
 	}
+#ifdef MLX_IPMID
+        else{
+            if (!sensor->enabled) {
+                status_led_control(sensor->num, 1, sensor->sensor_type);
+                sensor->enabled = 1;
+                switch (sensor->num) {
+                /* In case PSU1 or PSU2 is power-on add msg to the SEL */
+                case MLX_PSU1_PIN_SENSOR_NUM:
+                case MLX_PSU2_PIN_SENSOR_NUM:
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x0);
+                break;
+                /* In case any FAN is plugged-out sensor can't be read add msg to the SEL */
+                case MLX_FAN1_1_SENSOR_NUM:
+                case MLX_FAN1_2_SENSOR_NUM:
+                case MLX_FAN2_1_SENSOR_NUM:
+                case MLX_FAN2_2_SENSOR_NUM:
+                case MLX_FAN3_1_SENSOR_NUM:
+                case MLX_FAN3_2_SENSOR_NUM:
+                case MLX_FAN4_1_SENSOR_NUM:
+                case MLX_FAN4_2_SENSOR_NUM:
+                    mlx_add_event_to_sel(sensor->mc, sensor->sensor_type, sensor->num, 0, IPMI_EVENT_READING_TYPE_DISCRETE_DEVICE_ENABLE, 0x1);
+                break;
+                default:
+                    break;
+                }
+            }
+        }
+#endif
 	
 	if (sensor->event_reading_code == IPMI_EVENT_READING_TYPE_THRESHOLD) {
 	    if (val < 0)
@@ -1585,7 +1747,7 @@ handle_ipmi_get_pef_capabilities(lmc_data_t    *mc,
     rdata[0] = 0;
     rdata[1] = 0x51; /* version */
     rdata[2] = 0x3f; /* support everything but OEM */
-    rdata[3] = MAX_EVENT_FILTERS;
+    rdata[3] = MAX_EVENT_FILTERS - 1;
     *rdata_len = 4;
 }
 
@@ -1638,10 +1800,14 @@ handle_ipmi_set_pef_config_parms(lmc_data_t    *mc,
 	    break;
 
 	case 2:
-	    if (mc->pef.commit)
-		mc->pef.commit(sys);
-	    memset(&mc->pef.changed, 0, sizeof(mc->pef.changed));
-	    mc->pef.set_in_progress = 0;
+	    if (mc->pef.set_in_progress) {
+		if (mc->pef.commit)
+		    mc->pef.commit(sys);
+		memset(&mc->pef.changed, 0, sizeof(mc->pef.changed));
+		mc->pef.set_in_progress = 0;
+	    }
+	    else
+		err = IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC;
 	    break;
 
 	case 3:
@@ -1656,105 +1822,145 @@ handle_ipmi_set_pef_config_parms(lmc_data_t    *mc,
 	break;
 
     case 1:
-	mc->pef.pef_control = msg->data[1];
-	mc->pef.changed.pef_control = 1;
+        if (mc->pef.set_in_progress) {
+	    mc->pef.pef_control = msg->data[1];
+	    mc->pef.changed.pef_control = 1;
+        }
+        else
+            err = IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC;
 	break;
 
     case 2:
-	mc->pef.pef_action_global_control = msg->data[1];
-	mc->pef.changed.pef_action_global_control = 1;
+        if (mc->pef.set_in_progress) {
+	    mc->pef.pef_action_global_control = msg->data[1];
+	    mc->pef.changed.pef_action_global_control = 1;
+        }
+        else
+            err = IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC;
 	break;
 
     case 3:
-	mc->pef.pef_startup_delay = msg->data[1];
-	mc->pef.changed.pef_startup_delay = 1;
+        if (mc->pef.set_in_progress) {
+	    mc->pef.pef_startup_delay = msg->data[1];
+	    mc->pef.changed.pef_startup_delay = 1;
+        }
+        else
+            err = IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC;
 	break;
 
     case 4:
-	mc->pef.pef_alert_startup_delay = msg->data[1];
-	mc->pef.changed.pef_alert_startup_delay = 1;
+        if (mc->pef.set_in_progress) {
+	    mc->pef.pef_alert_startup_delay = msg->data[1];
+	    mc->pef.changed.pef_alert_startup_delay = 1;
+        }
+        else
+            err = IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC;
 	break;
 
     case 6:
-	set = msg->data[1] & 0x7f;
-	if (msg->len < 22)
-	    err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
-	else if ((set <= 0) || (set >= mc->pef.num_event_filters))
-	    err = IPMI_INVALID_DATA_FIELD_CC;
-	else {
+        if (mc->pef.set_in_progress) {
 	    set = msg->data[1] & 0x7f;
-	    memcpy(mc->pef.event_filter_table[set], msg->data+1, 21);
-	    mc->pef.changed.event_filter_table[set] = 1;
-	}
+	    if (msg->len < 22)
+		err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
+	    else if ((set <= 0) || (set >= mc->pef.num_event_filters))
+		err = IPMI_INVALID_DATA_FIELD_CC;
+	    else {
+		set = msg->data[1] & 0x7f ;
+		memcpy(mc->pef.event_filter_table[set], msg->data+1, 21);
+		mc->pef.changed.event_filter_table[set] = 1;
+	    }
+        }
+        else
+            err = IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC;
 	break;
 
     case 7:
-	set = msg->data[1] & 0x7f;
-	if (msg->len < 3)
-	    err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
-	else if ((set <= 0) || (set >= mc->pef.num_event_filters))
-	    err = IPMI_INVALID_DATA_FIELD_CC;
-	else {
+        if (mc->pef.set_in_progress) {
 	    set = msg->data[1] & 0x7f;
-	    memcpy(mc->pef.event_filter_data1[set], msg->data+1, 2);
-	    mc->pef.changed.event_filter_data1[set] = 1;
-	}
+	    if (msg->len < 3)
+		err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
+	    else if ((set <= 0) || (set >= mc->pef.num_event_filters))
+		err = IPMI_INVALID_DATA_FIELD_CC;
+	    else {
+		set = msg->data[1] & 0x7f;
+		memcpy(mc->pef.event_filter_data1[set], msg->data+1, 2);
+		mc->pef.changed.event_filter_data1[set] = 1;
+	    }
+        }
+        else
+            err = IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC;
 	break;
 
     case 9:
-	set = msg->data[1] & 0x7f;
-	if (msg->len < 5)
-	    err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
-	else if ((set <= 0) || (set >= mc->pef.num_alert_policies))
-	    err = IPMI_INVALID_DATA_FIELD_CC;
-	else {
+        if (mc->pef.set_in_progress) {
 	    set = msg->data[1] & 0x7f;
-	    memcpy(mc->pef.alert_policy_table[set], msg->data+1, 4);
-	    mc->pef.changed.alert_policy_table[set] = 1;
-	}
+	    if (msg->len < 5)
+		err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
+	    else if ((set <= 0) || (set >= mc->pef.num_alert_policies))
+		err = IPMI_INVALID_DATA_FIELD_CC;
+	    else {
+		set = msg->data[1] & 0x7f;
+		memcpy(mc->pef.alert_policy_table[set], msg->data+1, 4);
+		mc->pef.changed.alert_policy_table[set] = 1;
+	    }
+        }
+        else
+            err = IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC;
 	break;
 
     case 10:
-	if (msg->len < 18)
-	    err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
-	else {
-	    memcpy(mc->pef.system_guid, msg->data+1, 17);
-	    mc->pef.changed.system_guid = 1;
-	}
+        if (mc->pef.set_in_progress) {
+	    if (msg->len < 18)
+		err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
+	    else {
+		memcpy(mc->pef.system_guid, msg->data+1, 17);
+		mc->pef.changed.system_guid = 1;
+	    }
+        }
+        else
+            err = IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC;
 	break;
 
     case 12:
-	set = msg->data[1] & 0x7f;
-	if (msg->len < 4)
-	    err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
-	else if (set >= mc->pef.num_alert_strings)
-	    err = IPMI_INVALID_DATA_FIELD_CC;
-	else {
+        if (mc->pef.set_in_progress) {
 	    set = msg->data[1] & 0x7f;
-	    memcpy(mc->pef.alert_string_keys[set], msg->data+1, 3);
-	    mc->pef.changed.alert_string_keys[set] = 1;
-	}
+	    if (msg->len < 4)
+		err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
+	    else if (set >= mc->pef.num_alert_strings)
+		err = IPMI_INVALID_DATA_FIELD_CC;
+	    else {
+		set = msg->data[1] & 0x7f;
+		memcpy(mc->pef.alert_string_keys[set], msg->data+1, 3);
+		mc->pef.changed.alert_string_keys[set] = 1;
+	    }
+        }
+        else
+            err = IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC;
 	break;
 
     case 13:
-	set = msg->data[1] & 0x7f;
-	if (msg->len < 4)
-	    err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
-	else if (set >= mc->pef.num_alert_strings)
-	    err = IPMI_INVALID_DATA_FIELD_CC;
-	else if (msg->data[2] == 0)
-	    err = IPMI_INVALID_DATA_FIELD_CC;
-	else {
-	    int dlen = msg->len - 3;
+        if (mc->pef.set_in_progress) {
 	    set = msg->data[1] & 0x7f;
-	    block = msg->data[2] - 1;
-	    if (((block*16) + dlen) > MAX_ALERT_STRING_LEN) {
-		err = IPMI_PARAMETER_OUT_OF_RANGE_CC;
-		break;
+	    if (msg->len < 4)
+		err =  IPMI_REQUEST_DATA_LENGTH_INVALID_CC;
+	    else if (set >= mc->pef.num_alert_strings)
+		err = IPMI_INVALID_DATA_FIELD_CC;
+	    else if (msg->data[2] == 0)
+		err = IPMI_INVALID_DATA_FIELD_CC;
+	    else {
+		int dlen = msg->len - 3;
+		set = msg->data[1] & 0x7f;
+		block = msg->data[2] - 1;
+		if (((block*16) + dlen) > MAX_ALERT_STRING_LEN) {
+		    err = IPMI_PARAMETER_OUT_OF_RANGE_CC;
+		    break;
+		}
+		memcpy(mc->pef.alert_strings[set]+(block*16), msg->data+3, dlen);
+		mc->pef.changed.alert_strings[set] = 1;
 	    }
-	    memcpy(mc->pef.alert_strings[set]+(block*16), msg->data+3, dlen);
-	    mc->pef.changed.alert_strings[set] = 1;
-	}
+        }
+        else
+            err = IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC;
 	break;
 
     default:
diff --git a/lanserv/bmc_storage.c b/lanserv/bmc_storage.c
index ded179f..ca6b188 100644
--- a/lanserv/bmc_storage.c
+++ b/lanserv/bmc_storage.c
@@ -39,10 +39,12 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#include <time.h>
 
 #include <OpenIPMI/ipmi_err.h>
 #include <OpenIPMI/ipmi_msgbits.h>
 #include <OpenIPMI/persist.h>
+#include <OpenIPMI/serserv.h>
 
 /*
  * SEL handling commands.
@@ -277,8 +279,85 @@ mc_new_event(lmc_data_t *mc,
 	if (chan->set_atn)
 	    chan->set_atn(chan, 1, IPMI_MC_EVBUF_FULL_INT_ENABLED(mc));
     }
+
+#ifdef MLX_IPMID
+    if (mc->pef.pef_control & 0x1)
+        mlx_mc_pef_apply(mc, record_type, event);
+#endif /* MLX_IPMID */
 }
 
+#ifdef MLX_IPMID
+void mlx_mc_pef_apply(lmc_data_t    *mc,
+                        unsigned char record_type,
+                        unsigned char event[13])
+{
+    unsigned int i;
+
+    for (i=1; i<MAX_EVENT_FILTERS; i++) {
+        if (!(mc->pef.event_filter_table[i][1] & 0x80))
+            continue;
+
+        if ((mc->pef.event_filter_table[i][5] != 0xff) 
+            && (mc->pef.event_filter_table[i][5] != event[4]))
+            continue;
+
+        if ((mc->pef.event_filter_table[i][6] != 0xff) 
+            && (mc->pef.event_filter_table[i][6] != event[5]))
+            continue;
+
+        if ((mc->pef.event_filter_table[i][7] != 0xff) 
+            && (mc->pef.event_filter_table[i][7] != event[7]))
+            continue;
+
+        if ((mc->pef.event_filter_table[i][8] != 0xff) 
+            && (mc->pef.event_filter_table[i][8] != event[8]))
+            continue;
+
+        if ((mc->pef.event_filter_table[i][9] != 0xff) 
+            && (mc->pef.event_filter_table[i][9] != event[12]))
+            continue;
+
+        if ((mc->pef.event_filter_table[i][2] & 0x10)
+            && (mc->pef.pef_action_global_control & 0x10)) /* OEM */
+            system("echo 3 > /bsp/leds/status/amber/trigger");
+
+        if ((mc->pef.event_filter_table[i][2] & 0x2)
+            && (mc->pef.pef_action_global_control & 0x2))  /* Power-off */
+            system("echo 0 > /bsp/reset/cpu_reset_hard");
+
+        if ((mc->pef.event_filter_table[i][2] & 0x4)
+            && (mc->pef.pef_action_global_control & 0x4))  /* Reset */
+            system("echo 0 > /bsp/reset/cpu_reset_soft");
+
+        if ((mc->pef.event_filter_table[i][2] & 0x8)
+            && (mc->pef.pef_action_global_control & 0x8)) { /* Power cycle */
+            system("echo 0 > /bsp/reset/cpu_reset_hard");
+            sleep(3);
+            system("echo 1 > /bsp/reset/cpu_reset_hard");
+        }
+
+        if ((mc->pef.event_filter_table[i][2] & 0x20)
+            && (mc->pef.pef_action_global_control & 0x20)) { /* Diagnostic interupt */
+
+            serserv_data_t *si = mc->channels[15]->chan_info;
+            unsigned int len = 2;
+            unsigned char c[2];
+            int rv = 0;
+
+            c[0] = 0x07;
+            c[1] = 0xA1;
+
+            si->send_out(si, c, len);
+        }
+
+        /* SNMP is not supported, thus skip Alert action */
+        if ((mc->pef.event_filter_table[i][2] & 0x1)
+            && (mc->pef.pef_action_global_control & 0x1))
+            continue;
+    }
+}
+#endif /* MLX_IPMID */
+
 static void
 handle_get_sel_info(lmc_data_t    *mc,
 		    msg_t         *msg,
@@ -1616,8 +1695,15 @@ fru_sem_trywait(fru_data_t *fru)
 
     /* Wait 250ms for the semaphore. */
   restart:
-    ts.tv_sec = 0;
-    ts.tv_nsec = 250000000;
+    rv = clock_gettime(CLOCK_REALTIME, &ts);
+    if (rv == -1)
+	return errno;
+
+    ts.tv_nsec += 250000000;
+    if (ts.tv_nsec >= 1000000000) {
+	ts.tv_nsec -= 1000000000;
+	ts.tv_sec += 1;
+    }
     rv = sem_timedwait(&fru->sem, &ts);
     if (rv) {
 	if (rv == EINTR)
@@ -1714,6 +1800,109 @@ handle_read_fru_data(lmc_data_t    *mc,
 	    *rdata_len = 1;
 	    goto out_unlock;
 	}
+#ifdef MLX_IPMID
+#define MLX_FRU_HEADER_VERSION               0x1
+#define MLX_FRU_HEADER_PRODUCT               0x1
+#define MLX_FRU_PRODUCT_MANUFACTURER_LEN     0xc4 // &3f = 4
+#define MLX_FRU_PRODUCT_NAME_LEN             0xcb // &3f = 11
+#define MLX_FRU_PRODUCT_PART_NUMBER_LEN      0xcb // &3f = 11
+#define MLX_FRU_PRODUCT_VERSION_LEN          0xc2 // &3f = 2
+#define MLX_FRU_PRODUCT_SERIAL_LEN           0xcc // &3f = 12
+#define MLX_FRU_PRODUCT_INFO_LEN_MASK        0x3f
+#define MLX_FRU_NO_PRODUCT_EXTRA_INFO        0xc1
+
+#define MLX_FRU_PRODUCT_MANUFACTURER_OFFSET  8
+#define MLX_FRU_PRODUCT_NAME_OFFSET          92
+#define MLX_FRU_PRODUCT_PART_NUMBER_OFFSET   64
+#define MLX_FRU_PRODUCT_VERSION_OFFSET       84
+#define MLX_FRU_PRODUCT_SERIAL_OFFSET        40
+#define MLX_FRU_FAN_DEV_ID_MIN               6
+#define MLX_FRU_FAN_DEV_ID_MAX               9
+#define MLX_FRU_CTRL_FIELD_MASK(o,c)         (o == 0 && c == 8)
+#define MLX_FRU_CTRL_LEN_MASK(o,c)           (o == 8 && c == 2)
+#define MLX_FRU_PROD_INFO_1(o,c)             (o == 8 && (c == 33 || c == 32))
+#define MLX_FRU_PROD_INFO_2(o,c)             ((o == 41 && c == 31) || (o == 40 && c == 32))
+
+        unsigned char buf[30];
+
+    if (devid >= MLX_FRU_FAN_DEV_ID_MIN && devid <= MLX_FRU_FAN_DEV_ID_MAX) {
+        if (MLX_FRU_CTRL_FIELD_MASK(offset, count)) {
+            memset(buf, 0 , sizeof(buf));
+            buf[0] = MLX_FRU_HEADER_VERSION;
+            buf[4] = MLX_FRU_HEADER_PRODUCT;
+            memcpy(rdata + 2, buf, count);
+        }
+        if (MLX_FRU_CTRL_LEN_MASK(offset, count)) {
+            rdata[2] = 0x0;
+            rdata[3] = 0x8;
+        }
+        if (MLX_FRU_PROD_INFO_1(offset, count)) {
+            // ipmitool skip first three bytes which specify
+            // fru area version, fru area length
+            // and fru board language
+            rdata[2] = 0x0;
+            rdata[3] = 0x0;
+            rdata[4] = 0x0;
+            rdata[5] = MLX_FRU_PRODUCT_MANUFACTURER_LEN;
+
+            // Product Manufacturer
+            memset(buf, 0 , sizeof(buf));
+            rv = fru->fru_io_cb(fru->data, FRU_IO_READ, buf, MLX_FRU_PRODUCT_MANUFACTURER_OFFSET, MLX_FRU_PRODUCT_MANUFACTURER_LEN & MLX_FRU_PRODUCT_INFO_LEN_MASK);
+            if (rv) {
+                rdata[0] = IPMI_UNKNOWN_ERR_CC;
+                *rdata_len = 1;
+                goto out_unlock;
+            }
+            memcpy(rdata + 6, buf, MLX_FRU_PRODUCT_MANUFACTURER_LEN & MLX_FRU_PRODUCT_INFO_LEN_MASK);
+            rdata[10] = MLX_FRU_PRODUCT_NAME_LEN;
+
+            // Product Name
+            memset(buf, 0, sizeof(buf));
+            rv = fru->fru_io_cb(fru->data, FRU_IO_READ, buf, MLX_FRU_PRODUCT_NAME_OFFSET, MLX_FRU_PRODUCT_NAME_LEN & MLX_FRU_PRODUCT_INFO_LEN_MASK);
+            if (rv) {
+                rdata[0] = IPMI_UNKNOWN_ERR_CC;
+                *rdata_len = 1;
+                goto out_unlock;
+            }
+            memcpy(rdata + 11, buf, MLX_FRU_PRODUCT_NAME_LEN & MLX_FRU_PRODUCT_INFO_LEN_MASK);
+            rdata[22] = MLX_FRU_PRODUCT_PART_NUMBER_LEN;
+
+            // Product Part Number
+            memset(buf, 0, sizeof(buf));
+            rv = fru->fru_io_cb(fru->data, FRU_IO_READ, buf, MLX_FRU_PRODUCT_PART_NUMBER_OFFSET, MLX_FRU_PRODUCT_PART_NUMBER_LEN & MLX_FRU_PRODUCT_INFO_LEN_MASK);
+            if (rv) {
+                rdata[0] = IPMI_UNKNOWN_ERR_CC;
+                *rdata_len = 1;
+                goto out_unlock;
+            }
+            memcpy(rdata + 23, buf, MLX_FRU_PRODUCT_PART_NUMBER_LEN & MLX_FRU_PRODUCT_INFO_LEN_MASK);
+            rdata[34] = MLX_FRU_PRODUCT_VERSION_LEN;
+        }
+        if (MLX_FRU_PROD_INFO_2(offset, count)) {
+            // Product Version
+            memset(buf, 0 , sizeof(buf));
+            rv = fru->fru_io_cb(fru->data, FRU_IO_READ, buf, MLX_FRU_PRODUCT_VERSION_OFFSET, MLX_FRU_PRODUCT_VERSION_LEN & MLX_FRU_PRODUCT_INFO_LEN_MASK);
+            if (rv) {
+                rdata[0] = IPMI_UNKNOWN_ERR_CC;
+                *rdata_len = 1;
+                goto out_unlock;
+            }
+            memcpy(rdata + 2, buf, MLX_FRU_PRODUCT_VERSION_LEN & MLX_FRU_PRODUCT_INFO_LEN_MASK);
+            rdata[4] = MLX_FRU_PRODUCT_SERIAL_LEN;
+
+            // Product Serial
+            memset(buf, 0, sizeof(buf));
+            rv = fru->fru_io_cb(fru->data, FRU_IO_READ, buf, MLX_FRU_PRODUCT_SERIAL_OFFSET, MLX_FRU_PRODUCT_SERIAL_LEN & MLX_FRU_PRODUCT_INFO_LEN_MASK);
+            if (rv) {
+                rdata[0] = IPMI_UNKNOWN_ERR_CC;
+                *rdata_len = 1;
+                goto out_unlock;
+            }
+            memcpy(rdata + 5, buf, MLX_FRU_PRODUCT_SERIAL_LEN & MLX_FRU_PRODUCT_INFO_LEN_MASK);
+            rdata[19] = MLX_FRU_NO_PRODUCT_EXTRA_INFO;
+        }
+    }
+#endif
     } else {
 	memcpy(rdata + 2, data + offset, count);
     }
diff --git a/lanserv/emu_cmd.c b/lanserv/emu_cmd.c
index 48fb1dc..0f176b3 100644
--- a/lanserv/emu_cmd.c
+++ b/lanserv/emu_cmd.c
@@ -1087,6 +1087,8 @@ debug_cmd(emu_out_t *out, emu_data_t *emu, lmc_data_t *mc, char **toks)
 	    level |= DEBUG_RAW_MSG;
 	} else if (strcmp(tok, "msg") == 0) {
 	    level |= DEBUG_MSG;
+	} else if (strcmp(tok, "sol") == 0) {
+	    level |= DEBUG_SOL;
 	} else {
 	    out->printf(out, "Invalid debug level '%s', options are 'raw' and 'msg'\n",
 		   tok);
diff --git a/lanserv/extcmd.c b/lanserv/extcmd.c
index 1cd902f..55a2040 100644
--- a/lanserv/extcmd.c
+++ b/lanserv/extcmd.c
@@ -220,12 +220,14 @@ extcmd_setval(void *baseloc, extcmd_info_t *t)
 static int
 process_extcmd_value(void *baseloc, extcmd_info_t *t, char *buf)
 {
-    while (buf) {
-	unsigned int len = strlen(t->name);
+    unsigned int len = strlen(t->name);
 
+    while (buf) {
+	while (*buf == '\n')
+	    buf++;
 	if ((strncmp(buf, t->name, len) == 0) && buf[len] == ':')
 	    return extcmd_getval(baseloc, t, buf + len + 1);
-	buf = strchr(buf, '\n') + 1;
+	buf = strchr(buf, '\n');
     }
     return EEXIST;
 }
diff --git a/lanserv/ipmi_sim.c b/lanserv/ipmi_sim.c
index 5a694b6..05cfec8 100644
--- a/lanserv/ipmi_sim.c
+++ b/lanserv/ipmi_sim.c
@@ -90,14 +90,21 @@
 #include <OpenIPMI/serv.h>
 #include <OpenIPMI/lanserv.h>
 #include <OpenIPMI/serserv.h>
-
+#ifdef MLX_IPMID
+#include <OpenIPMI/ipmi_types.h>
+#endif
 #include "emu.h"
 #include <OpenIPMI/persist.h>
 
 #define MAX_ADDR 4
 
 #define BASE_CONF_STR SYSCONFDIR "/ipmi"
+#ifdef MLX_IPMID
+#define MLNX_CONF_FILE_EXT       ".hw"
+static char *config_file = BASE_CONF_STR "/mellanox.lan.conf";
+#else
 static char *config_file = BASE_CONF_STR "/lan.conf";
+#endif
 static const char *statedir = STATEDIR;
 static char *command_string = NULL;
 static char *command_file = NULL;
@@ -310,6 +317,31 @@ lan_data_ready(int lan_fd, void *cb_data, os_hnd_fd_id_t *id)
     return;
 }
 
+#ifdef MLX_IPMID
+static int
+ipmi_open(char *ipmi_dev)
+{
+    int ipmi_fd;
+
+    if (ipmi_dev) {
+	ipmi_fd = open(ipmi_dev, O_RDWR);
+    } else {
+	ipmi_fd = open("/dev/ipmidev/0", O_RDWR);
+	if (ipmi_fd == -1) {
+	    ipmi_fd = open("/dev/ipmi0", O_RDWR);
+	}
+	if (ipmi_fd == -1) {
+	    ipmi_fd = open("/dev/ipmi-bt-host", O_RDWR);
+	}
+    }
+
+    if (ipmi_fd == -1) {
+	perror("Could not open ipmi device /dev/ipmidev/0, /dev/ipmi0 or /dev/ipmi-bt-host");
+    }
+    return ipmi_fd;
+}
+#endif
+
 static int
 open_lan_fd(struct sockaddr *addr, socklen_t addr_len)
 {
@@ -474,8 +506,75 @@ ser_bind_ready(int fd, void *cb_data, os_hnd_fd_id_t *id)
     }
 }
 
+#ifdef MLX_IPMID
+static void
+ser_bt_data_ready(int fd, void *cb_data, os_hnd_fd_id_t *id)
+{
+    serserv_data_t *ser = cb_data;
+    unsigned int  len;
+    unsigned char msgd[256];
+
+    len = read(fd, msgd, sizeof(msgd));
+
+    if (ser->sysinfo->debug & DEBUG_MSG)
+        printf(">ser_bt_data_ready size %d\n", len);
+    if (len <= 0) {
+
+        if ((len < 0) && (errno == EINTR))
+            return;
+
+        if (ser->codec->disconnected)
+            ser->codec->disconnected(ser);
+        ser->os_hnd->remove_fd_to_wait_for(ser->os_hnd, id);
+        close(fd);
+        ser->con_fd = -1;
+        return;
+    }
+
+    ser->bind_fd = -1;
+    serserv_handle_data(ser, msgd, len);
+    ser->bind_fd = 0;
+    serserv_handle_data(ser, msgd, 1);
+}
+
 static int
-ser_channel_init(void *info, channel_t *chan)
+ser_channel_bt_proto_init(void *info, channel_t *chan)
+{
+    misc_data_t *data = info;
+    serserv_data_t *ser = chan->chan_info;
+    int err;
+    int fd;
+    os_hnd_fd_id_t *fd_id;
+
+    ser->os_hnd = data->os_hnd;
+    ser->user_info = data;
+    ser->send_out = ser_send;
+    err = serserv_init(ser);
+    if (err) {
+	fprintf(stderr, "Unable to init serial: 0x%x\n", err);
+	exit(1);
+    }
+
+    fd = ipmi_open(NULL);
+    if (fd == -1){
+        exit(1);
+        fprintf(stderr, "Unable to init serial: 0x%x\n", err);
+    }
+
+    ser->con_fd = fd;
+
+    err = data->os_hnd->add_fd_to_wait_for(data->os_hnd, ser->con_fd,
+					       ser_bt_data_ready, ser,
+					       NULL, &fd_id);
+    if (!err)
+        isim_add_fd(fd);
+
+    return 0;
+}
+#endif
+
+static int
+ser_channel_tmode_proto_init(void *info, channel_t *chan)
 {
     misc_data_t *data = info;
     serserv_data_t *ser = chan->chan_info;
@@ -569,6 +668,25 @@ ser_channel_init(void *info, channel_t *chan)
     return err;
 }
 
+static int
+ser_channel_init(void *info, channel_t *chan)
+{
+    serserv_data_t *ser = chan->chan_info;
+    switch(ser->channel.protocol_type) {
+#ifdef MLX_IPMID
+        case IPMI_CHANNEL_PROTOCOL_BT_v15:
+            return ser_channel_bt_proto_init(info, chan);
+            break;
+#endif
+        case IPMI_CHANNEL_PROTOCOL_TMODE:
+            return ser_channel_tmode_proto_init(info, chan);
+            break;
+        default:
+            return -1;
+            break;
+    }
+}
+
 static void
 isim_log(sys_data_t *sys, int logtype, msg_t *msg, const char *format,
 	 va_list ap, int len)
@@ -1496,7 +1614,11 @@ main(int argc, const char *argv[])
 	exit(1);
     }
 
+#ifdef MLX_IPMID
+    err = persist_init("mlx_ipmid", sysinfo.name, statedir);
+#else
     err = persist_init("ipmi_sim", sysinfo.name, statedir);
+#endif
     if (err) {
 	fprintf(stderr, "Unable to initialize persistence: %s\n",
 		strerror(err));
@@ -1533,7 +1655,11 @@ main(int argc, const char *argv[])
 	strcpy(command_file, BASE_CONF_STR);
 	strcat(command_file, "/");
 	strcat(command_file, sysinfo.name);
-	strcat(command_file, ".emu");
+#ifdef MLX_IPMID
+        strcat(command_file, MLNX_CONF_FILE_EXT);
+#else
+        strcat(command_file, ".emu");
+#endif
 	tf = fopen(command_file, "r");
 	if (!tf) {
 	    free(command_file);
@@ -1630,6 +1756,14 @@ main(int argc, const char *argv[])
 	goto out;
     }
 
+#ifdef MLX_IPMID
+/*Uart to CPU*/
+    system("echo 1 > /bsp/reset/uart_sel");
+
+/*CPU go*/
+    system("echo 1 > /bsp/reset/cpu_reset_hard");
+#endif
+
     data.os_hnd->operation_loop(data.os_hnd);
     rv = 0;
   out:
diff --git a/lanserv/ipmisim1.emu b/lanserv/ipmisim1.emu
index 367715b..b96da95 100644
--- a/lanserv/ipmisim1.emu
+++ b/lanserv/ipmisim1.emu
@@ -28,9 +28,12 @@ sensor_set_event_support 0x20 0 1 enable scanning per-state \
 	000111111000000 000111111000000
 
 # Add a satellite MC
-mc_add 0x30 2 no-device-sdrs 0x98 0x10 1 0x20 0x1291 0xf03
+mc_add 0x30 2 no-device-sdrs 0x98 0x10 1 0xa0 0x1291 0xf03
 
-sensor_add 0x30 0 1 0x01 0x01 poll 1000 file "/tmp/file1.ipm"
+sensor_add 0x30 0 1 0x01 0x01
+# Uncomment the following and comment the proceding to read the value
+# from the given file.  You can modify the file contents.
+#sensor_add 0x30 0 1 0x01 0x01 poll 1000 file "/tmp/file1.ipm"
 sensor_set_threshold 0x30 0 1 settable 111000 0xa0 0x90 0x70 00 00 00
 sensor_set_event_support 0x30 0 1 enable scanning per-state \
 	000111111000000 000111111000000 \
diff --git a/lanserv/lan.conf b/lanserv/lan.conf
index c251d14..aa2da85 100644
--- a/lanserv/lan.conf
+++ b/lanserv/lan.conf
@@ -51,14 +51,14 @@ set_working_mc 0x20
   # startcmd is what to execute to start a VM associated with the
   # codec above (localhost 9002).  It also starts a console serial port
   # on port 9003 that is also used as the monitor interface.
-  startcmd "/home/cminyard/git/qemu/O/x86_64-softmmu/qemu-system-x86_64 --enable-kvm -drive file=/work/cge7/build.x86-generic-64/tmp/deploy/images/complete-image.ext2,format=raw -nographic -kernel ~/git/linux-ipmi/Ox86_64/arch/x86/boot/bzImage -append 'root=/dev/sda console=ttyS0,115200' -net nic,model=e1000,macaddr=52:54:00:12:34:59 -net user,hostfwd=tcp::5556-10.0.2.15:22 -chardev socket,id=ipmi0,host=localhost,port=9011,reconnect=10 -device ipmi-bmc-extern,id=bmc0,chardev=ipmi0 -device isa-ipmi-bt,bmc=bmc0 -serial mon:telnet::9012,server,telnet,nowait"
+  startcmd "qemu-system-x86_64 --enable-kvm -drive file=/opt/qemu/cge-complete-image-x86-generic-64-1.ext2,format=raw -nographic -kernel /opt/qemu/bzImage-1 -append 'root=/dev/sdb console=ttyS0,115200' -net nic,model=e1000,macaddr=52:54:00:12:34:59 -net user,hostfwd=tcp::5556-10.0.2.15:22 -chardev socket,id=ipmi0,host=localhost,port=9002,reconnect=10 -device ipmi-bmc-extern,id=bmc0,chardev=ipmi0 -device isa-ipmi-bt,bmc=bmc0 -serial mon:telnet::9003,server,telnet,nowait"
 
-  sol "telnet:localhost:9012" 115200
+  sol "telnet:localhost:9003" 115200
 
   # Start startcmd at startup?  Default is false.
   startnow false
 
-  # The amount of time to wait for the startcmd to do a graceful shutdown
+  # The amount of time to wait for the startcmd to do a power off
   # on a powerdown request.  The simulator will send a request to the
   # target, wait this amount of time, and then do a SIGTERM kill on the
   # process.  If this is zero, a SIGTERM will not be done (nor will a SIGKILL).
@@ -107,11 +107,13 @@ set_working_mc 0x30
 
   # Define a serial VM inteface for channel 15 (the system interface) on
   # port 9003 for the MC at 0x30
-  serial 15 localhost 9011 codec VM
+  serial 15 localhost 9012 codec VM
 
-  startcmd "$HOME/git/qemu-kvm/x86_64-softmmu/qemu-system-x86_64 --enable-kvm -drive file=$HOME/KVM/Test4sda -nographic -net nic,model=e1000,macaddr=52:54:00:12:34:59 -net user,hostfwd=tcp::5556-10.0.2.15:22 -chardev socket,id=ipmi0,host=localhost,port=9011,reconnect=10 -device isa-ipmi,chardev=ipmi0,interface=bt,irq=5 -serial mon:tcp::9012,server,telnet,nowait"
+  startcmd "qemu-system-x86_64 --enable-kvm -drive file=/opt/qemu/cge-complete-image-x86-generic-64-2.ext2,format=raw -nographic -kernel /opt/qemu/bzImage-2 -append 'root=/dev/sdb console=ttyS0,115200' -net nic,model=e1000,macaddr=52:54:00:12:34:59 -net user,hostfwd=tcp::5557-10.0.2.15:22 -chardev socket,id=ipmi0,host=localhost,port=9012,reconnect=10 -device ipmi-bmc-extern,id=bmc0,chardev=ipmi0 -device isa-ipmi-kcs,bmc=bmc0,irq=5 -serial mon:tcp::9013,server,telnet,nowait"
 
-  # Start startcmd at startup?  Default is false.
+  sol "telnet:localhost:9013" 115200
+
+# Start startcmd at startup?  Default is false.
   startnow false
 
 # Allow a console connection to perform emulation commands.
diff --git a/lanserv/lanserv_ipmi.c b/lanserv/lanserv_ipmi.c
index b0a2431..67bf74a 100644
--- a/lanserv/lanserv_ipmi.c
+++ b/lanserv/lanserv_ipmi.c
@@ -2217,7 +2217,7 @@ aes_cbc_encrypt(lanserv_data_t *lan, session_t *session,
     unsigned char  *d;
     unsigned char  *iv;
     unsigned int   i;
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx;
     int            rv;
     int            outlen;
     int            tmplen;
@@ -2264,14 +2264,18 @@ aes_cbc_encrypt(lanserv_data_t *lan, session_t *session,
     *data_size += 16;
 
     /* Ok, we're set to do the crypt operation. */
-    EVP_CIPHER_CTX_init(&ctx);
-    EVP_EncryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL, a->ckey, iv);
-    EVP_CIPHER_CTX_set_padding(&ctx, 0);
-    if (!EVP_EncryptUpdate(&ctx, *pos, &outlen, d, l)) {
+    ctx = EVP_CIPHER_CTX_new();
+    if (!ctx) {
+	    rv = ENOMEM;
+	    goto out_cleanup;
+    }
+    EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, a->ckey, iv);
+    EVP_CIPHER_CTX_set_padding(ctx, 0);
+    if (!EVP_EncryptUpdate(ctx, *pos, &outlen, d, l)) {
 	rv = ENOMEM;
 	goto out_cleanup;
     }
-    if (!EVP_EncryptFinal_ex(&ctx, (*pos) + outlen, &tmplen)) {
+    if (!EVP_EncryptFinal_ex(ctx, (*pos) + outlen, &tmplen)) {
 	rv = ENOMEM; /* right? */
 	goto out_cleanup;
     }
@@ -2281,7 +2285,7 @@ aes_cbc_encrypt(lanserv_data_t *lan, session_t *session,
     *data_len = outlen + 16;
 
  out_cleanup:
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_free(ctx);
     free(d);
     return rv;
 }
@@ -2292,7 +2296,7 @@ aes_cbc_decrypt(lanserv_data_t *lan, session_t *session, msg_t *msg)
     auth_data_t    *a = &session->auth_data;
     unsigned int   l = msg->len;
     unsigned char  *d;
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx;
     int            outlen;
     unsigned char  *pad;
     int            padlen;
@@ -2312,10 +2316,14 @@ aes_cbc_decrypt(lanserv_data_t *lan, session_t *session, msg_t *msg)
     memcpy(d, msg->data+16, l);
 
     /* Ok, we're set to do the decrypt operation. */
-    EVP_CIPHER_CTX_init(&ctx);
-    EVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL, a->k2, msg->data);
-    EVP_CIPHER_CTX_set_padding(&ctx, 0);
-    if (!EVP_DecryptUpdate(&ctx, msg->data+16, &outlen, d, l)) {
+    ctx = EVP_CIPHER_CTX_new();
+    if (!ctx) {
+	    rv = ENOMEM;
+	    goto out_cleanup;
+    }
+    EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, a->k2, msg->data);
+    EVP_CIPHER_CTX_set_padding(ctx, 0);
+    if (!EVP_DecryptUpdate(ctx, msg->data+16, &outlen, d, l)) {
 	rv = EINVAL;
 	goto out_cleanup;
     }
@@ -2348,7 +2356,7 @@ aes_cbc_decrypt(lanserv_data_t *lan, session_t *session, msg_t *msg)
     msg->len = outlen;
 
  out_cleanup:
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_free(ctx);
     free(d);
     return rv;
 }
diff --git a/lanserv/mellanox/50-mlx-events.rules b/lanserv/mellanox/50-mlx-events.rules
new file mode 100644
index 0000000..7adc1e8
--- /dev/null
+++ b/lanserv/mellanox/50-mlx-events.rules
@@ -0,0 +1,71 @@
+########################################################################
+# Copyright (c) 2017 Mellanox Technologies.
+# Copyright (c) 2017 Nataliya Yakuts <nataliyay@mellanox.com>
+#
+# Licensed under the GNU General Public License Version 2
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+
+SUBSYSTEM=="iio", KERNEL=="iio:device0", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add A2D %S %p"
+SUBSYSTEM=="iio", KERNEL=="iio:device0", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm A2D %S %p"
+
+SUBSYSTEM=="platform", KERNEL=="1e6e9000.adc", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add ADC %S %p"
+SUBSYSTEM=="platform", KERNEL=="1e6e9000.adc", ACTION=="rm", RUN+="/usr/bin/mlx-hw-events.sh add ADC %S %p"
+
+SUBSYSTEM=="i2c", KERNEL=="3-0051", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add eeprom_psu2 %S %p"
+SUBSYSTEM=="i2c", KERNEL=="3-0051", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm eeprom_psu2 %S %p"
+
+SUBSYSTEM=="i2c", KERNEL=="3-0050", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add eeprom_psu1 %S %p"
+SUBSYSTEM=="i2c", KERNEL=="3-0050", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm eeprom_psu1 %S %p"
+
+SUBSYSTEM=="i2c", KERNEL=="14-0050", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add eeprom_fan1 %S %p"
+SUBSYSTEM=="i2c", KERNEL=="14-0050", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm eeprom_fan1 %S %p"
+
+SUBSYSTEM=="i2c", KERNEL=="15-0050", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add eeprom_fan2 %S %p"
+SUBSYSTEM=="i2c", KERNEL=="15-0050", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm eeprom_fan2 %S %p"
+
+SUBSYSTEM=="i2c", KERNEL=="16-0050", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add eeprom_fan3 %S %p"
+SUBSYSTEM=="i2c", KERNEL=="16-0050", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm eeprom_fan3 %S %p"
+
+SUBSYSTEM=="i2c", KERNEL=="17-0050", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add eeprom_fan4 %S %p"
+SUBSYSTEM=="i2c", KERNEL=="17-0050", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm eeprom_fan4 %S %p"
+
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan1:green", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add fan1_green %S %p"
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan1:green", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm fan1_green %S %p"
+
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan1:red", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add fan1_red %S %p"
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan1:red", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm fan1_red %S %p"
+
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan2:green", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add fan2_green %S %p"
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan2:green", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm fan2_green %S %p"
+
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan2:red", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add fan2_red %S %p"
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan2:red", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm fan2_red %S %p"
+
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan3:green", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add fan3_green %S %p"
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan3:green", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm fan3_green %S %p"
+
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan3:red", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add fan3_red %S %p"
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan3:red", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm fan3_red %S %p"
+
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan4:green", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add fan4_green %S %p"
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan4:green", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm fan4_green %S %p"
+
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan4:red", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add fan4_red %S %p"
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:fan4:red", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm fan4_red %S %p"
+
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:status:green", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add status_green %S %p"
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:status:green", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm status_green %S %p"
+
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:status:red", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add status_red %S %p"
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:status:red", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm status_red %S %p"
+
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:status:amber", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add status_amber %S %p"
+SUBSYSTEM=="leds", KERNEL=="mlnxcpld_ctrl:status:amber", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm status_amber %S %p"
+
+SUBSYSTEM=="thermal", KERNEL=="thermal_zone0", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add thermal_zone0 %S %p"
+SUBSYSTEM=="thermal", KERNEL=="thermal_zone0", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm thermal_zone0 %S %p"
diff --git a/lanserv/mellanox/50-mlx-hwmon-4-10-events.rules b/lanserv/mellanox/50-mlx-hwmon-4-10-events.rules
new file mode 100644
index 0000000..cacc22a
--- /dev/null
+++ b/lanserv/mellanox/50-mlx-hwmon-4-10-events.rules
@@ -0,0 +1,44 @@
+########################################################################
+# Copyright (c) 2017 Mellanox Technologies.
+# Copyright (c) 2017 Nataliya Yakuts <nataliyay@mellanox.com>
+#
+# Licensed under the GNU General Public License Version 2
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a340.i2c-bus/i2c-8/8-0049/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add amb_carrier %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a340.i2c-bus/i2c-8/8-0049/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm amb_carrier %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a340.i2c-bus/i2c-8/8-004a/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add amb_switch %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a340.i2c-bus/i2c-8/8-004a/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm amb_switch %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a100.i2c-bus/i2c-3/3-0059/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add psu2 %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a100.i2c-bus/i2c-3/3-0059/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm psu2 %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a100.i2c-bus/i2c-3/3-0058/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add psu1 %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a100.i2c-bus/i2c-3/3-0058/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm psu1 %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a3c0.i2c-bus/i2c-10/10-0027/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add UCD %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a3c0.i2c-bus/i2c-10/10-0027/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm UCD %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a3c0.i2c-bus/i2c-10/10-0041/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add VcoreUCD %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a3c0.i2c-bus/i2c-10/10-0041/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm VcoreUCD %S %p"
+
+#not present in 4.10
+#SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-12/i2c-12/12-0048/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add asic %S %p"
+#SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-12/i2c-12/12-0048/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm asic %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a140.i2c-bus/i2c-4/4-0071/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add reset %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a140.i2c-bus/i2c-4/4-0071/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm reset %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a140.i2c-bus/i2c-4/4-0071/hwmon/hwmon*", ACTION=="change", RUN+="/usr/bin/mlx-hw-events.sh change reset %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a140.i2c-bus/i2c-4/4-0072/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add phy_reset %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a140.i2c-bus/i2c-4/4-0072/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm phy_reset %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/ahb:apb:i2c@1e78a000/1e78a140.i2c-bus/i2c-4/4-0072/hwmon/hwmon*", ACTION=="change", RUN+="/usr/bin/mlx-hw-events.sh change phy_reset %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e786000.pwm-tacho-controller/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add fan_4_10 %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e786000.pwm-tacho-controller/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm fan_4_10 %S %p"
diff --git a/lanserv/mellanox/50-mlx-hwmon-events.rules b/lanserv/mellanox/50-mlx-hwmon-events.rules
new file mode 100644
index 0000000..2b39bd6
--- /dev/null
+++ b/lanserv/mellanox/50-mlx-hwmon-events.rules
@@ -0,0 +1,43 @@
+########################################################################
+# Copyright (c) 2017 Mellanox Technologies.
+# Copyright (c) 2017 Nataliya Yakuts <nataliyay@mellanox.com>
+#
+# Licensed under the GNU General Public License Version 2
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-8/i2c-8/8-0049/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add amb_carrier %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-8/i2c-8/8-0049/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm amb_carrier %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-8/i2c-8/8-004a/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add amb_switch %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-8/i2c-8/8-004a/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm amb_switch %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-3/i2c-3/3-0059/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add psu2 %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-3/i2c-3/3-0059/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm psu2 %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-3/i2c-3/3-0058/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add psu1 %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-3/i2c-3/3-0058/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm psu1 %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-10/i2c-10/10-0027/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add UCD %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-10/i2c-10/10-0027/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm UCD %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-10/i2c-10/10-0041/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add VcoreUCD %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-10/i2c-10/10-0041/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm VcoreUCD %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-12/i2c-12/12-0048/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add asic %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-12/i2c-12/12-0048/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm asic %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-4/i2c-4/4-0071/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add reset %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-4/i2c-4/4-0071/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm reset %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-4/i2c-4/4-0071/hwmon/hwmon*", ACTION=="change", RUN+="/usr/bin/mlx-hw-events.sh change reset %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-4/i2c-4/4-0072/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add phy_reset %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-4/i2c-4/4-0072/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm phy_reset %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e78a000.i2c/i2c-4/i2c-4/4-0072/hwmon/hwmon*", ACTION=="change", RUN+="/usr/bin/mlx-hw-events.sh change phy_reset %S %p"
+
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e786000.pwm/hwmon/hwmon*", ACTION=="add", RUN+="/usr/bin/mlx-hw-events.sh add fan %S %p"
+SUBSYSTEM=="hwmon", DEVPATH=="/devices/platform/ahb/ahb:apb/1e786000.pwm/hwmon/hwmon*", ACTION=="remove", RUN+="/usr/bin/mlx-hw-events.sh rm fan %S %p"
diff --git a/lanserv/mellanox/Makefile.am b/lanserv/mellanox/Makefile.am
new file mode 100644
index 0000000..97e0f9c
--- /dev/null
+++ b/lanserv/mellanox/Makefile.am
@@ -0,0 +1,29 @@
+
+AM_CFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/lanserv
+pkglib_LTLIBRARIES = mellanox.la
+
+mellanox_la_SOURCES = mellanox.c
+mellanox_la_LDFLAGS = -module
+
+install-data-local:
+	$(INSTALL) -m 755 -d "$(DESTDIR)$(sysconfdir)/ipmi/"; \
+	$(INSTALL) -m 755 -d "$(DESTDIR)$(localstatedir)/mlx_ipmid/mellanox/"; \
+	$(INSTALL) -m 644 $(srcdir)/mellanox.lan.conf "$(DESTDIR)$(sysconfdir)/ipmi/"; \
+	$(INSTALL) -m 644 $(srcdir)/mellanox.hw "$(DESTDIR)$(sysconfdir)/ipmi/"; \
+	$(INSTALL) -m 775 $(srcdir)/lancontrol "$(DESTDIR)$(sysconfdir)/ipmi/"; \
+	$(INSTALL) -m 644 $(srcdir)/sdr.20.main "$(DESTDIR)$(localstatedir)/mlx_ipmid/mellanox/"; \
+	$(INSTALL) -m 775 $(srcdir)/sel_set_log_size.sh "$(DESTDIR)$(bindir)"; \
+	$(INSTALL) -m 775 $(srcdir)/50-mlx-events.rules "$(DESTDIR)$(localstatedir)/mlx_ipmid/mellanox/"; \
+	$(INSTALL) -m 775 $(srcdir)/50-mlx-hwmon-events.rules "$(DESTDIR)$(localstatedir)/mlx_ipmid/mellanox/"; \
+	$(INSTALL) -m 775 $(srcdir)/mlx-hw-events.sh "$(DESTDIR)$(bindir)"; \
+	$(INSTALL) -m 775 $(srcdir)/status_led.py "$(DESTDIR)$(bindir)"; \
+	$(INSTALL) -m 644 $(srcdir)/status_led.json "$(DESTDIR)$(sysconfdir)";
+
+uninstall-local:
+	-rm -f "$(DESTDIR)$(sysconfdir)/ipmi/mellanox.lan.conf"
+	-rm -f "$(DESTDIR)$(sysconfdir)/ipmi/mellanox.hw"
+	-rm -f "$(DESTDIR)$(sysconfdir)/ipmi/sdr.20.main"
+	-rm -f "$(DESTDIR)$(bindir)/sel_set_log_size.sh"
+	-rm -f "$(DESTDIR)$(bindir)/status_led.py"
+	-rm -f "$(DESTDIR)$(sysconfdir)/status_led.json"
+	-rmdir "$(DESTDIR)$(sysconfdir)/ipmi" 2>/dev/null"
diff --git a/lanserv/mellanox/lancontrol b/lanserv/mellanox/lancontrol
new file mode 100755
index 0000000..76bfe0f
--- /dev/null
+++ b/lanserv/mellanox/lancontrol
@@ -0,0 +1,295 @@
+#!/bin/sh
+
+#
+# Script for handling external LAN configuration from the
+# IPMI deamon.  This command is generally invoked by the mlx_ipmid
+# to get and set external LAN configuration parameters.
+#
+# It's parameters are:
+#
+#  lancontrol <device> get [parm [parm ...]]
+#  lancontrol <device> set|check [parm val [parm val ...]]
+#
+# where <device> is a network device (eth0, etc.) and parm is one of:
+#  ip_addr
+#  ip_addr_src
+#  mac_addr
+#  subnet_mask
+#  default_gw_ip_addr
+# These are config values out of the IPMI LAN config table that are
+# not IPMI-exclusive, they require setting external things.
+#
+# The output of the "get" is "<parm>:<value>" for each listed parm.
+# The output of the "set" is empty on success.  Error output goes to
+# standard out (so it can be captured in the simulator) and the program
+# returns an error.
+#
+# The IP address values are standard IP addresses in the form a.b.c.d.
+# The MAC addresses ar standard 6 octet xx:xx:xx:xx:xx:xx values.  The
+# only special one is ip_addr_src, which can be "dhcp" or "static".
+#
+# The "check" operation checks to see if a value is valid without
+# committing it.
+#
+
+tmp_ip_addr="0.0.0.0"
+tmp_netmask="0"
+tmp_gateway="0.0.0.0"
+tmp_ip_addr_src="dhcp"
+
+prog=$0
+
+device=$1
+if [ "x$device" = "x" ]; then
+    echo "No device given"
+    exit 1;
+fi
+shift
+
+op=$1
+if [ "x$op" = "x" ]; then
+    echo "No operation given"
+    exit 1
+fi
+shift
+
+do_get() {
+    while [ "x$1" != "x" ]; do
+	case $1 in
+	    ip_addr)
+		val=`ifconfig $device | grep '^ *inet addr:' | tr ':' ' ' | sed 's/.*inet addr \([0-9.]*\).*$/\1/'`
+		if [ "x$val" = "x" ]; then
+		    val="0.0.0.0"
+		fi
+		;;
+
+	    ip_addr_src)
+		if [ ! -f /etc/systemd/network/50-static.network ];  then
+			val="dhcp"
+		else
+			val="static"
+		fi
+		;;
+
+	    mac_addr)
+		val=`ifconfig $device | grep 'HWaddr' | sed 's/.*HWaddr \([0-9a-fA-F:]*\).*$/\1/'`
+		if [ "x$val" = "x" ]; then
+		    val="00:00:00:00:00:00"
+		fi
+		;;
+
+	    subnet_mask)
+		val=`ifconfig $device | grep '^ *inet addr:' | tr ':' ' ' | sed 's/.*Mask \([0-9.]*\).*$/\1/'`
+		if [ "x$val" = "x" ]; then
+		    val="0.0.0.0"
+		fi
+		;;
+
+	    default_gw_ip_addr)
+		val=`route -n | grep '^0\.0\.0\.0' | grep "$device\$" | tr ' ' '\t' | tr -s '\t' '\t' | cut -f 2`
+		if [ "x$val" = "x" ]; then
+		    val="0.0.0.0"
+		fi
+		;;
+
+	    default_gw_mac_addr)
+		val=`route -n | grep '^0\.0\.0\.0' | grep "$device\$" | tr ' ' '\t' | tr -s '\t' '\t' | cut -s -f 2`
+		if [ "x$val" = "x" ]; then
+		    val="00:00:00:00:00:00"
+		else
+		    ping -W 1 -c 1 $val >/dev/null 2>&1
+		    val=`arp -n $val | grep "($val)" | tr ' ' '\t' | tr -s '\t' '\t' | cut -f 4`
+		    if [ "x$val" = "x" -o "x$val" = 'x<incomplete>' ]; then
+			val="00:00:00:00:00:00"
+		    fi
+		fi
+		;;
+
+	    backup_gw_ip_addr)
+		val="0.0.0.0"
+		;;
+
+	    backup_gw_mac_addr)
+		val="00:00:00:00:00:00"
+		;;
+
+	    *)
+		echo "Invalid parameter: $1"
+		exit 1
+		;;
+	esac
+
+	echo "$1:$val"
+	shift
+    done
+}
+
+do_check() {
+	case $1 in
+	    ip_addr_src)
+		# We only support static and dhcp IP address sources
+		case $2 in
+		    static)
+			;;
+		    dhcp)
+			;;
+		    *)
+			echo "Invalid ip_addr_src: $2"
+			exit 1
+			;;
+		esac
+		;;
+
+		ip_addr | subnet_mask | default_gw_ip_addr)
+		if [ "$2" != "`echo $2 | grep -E [0-9]\{1,3\}[.][0-9]\{1,3\}[.][0-9]\{1,3\}[.][0-9]\{1,3\}`" ];
+			then
+			echo "Invalid value $2 for parameter $1"
+			exit 1
+		fi
+		;;
+
+		mac_addr)
+		if [ "$2" != "`echo $2 | grep -E [[:xdigit:]]\{1,2\}[:][[:xdigit:]]\{1,2\}[:][[:xdigit:]]\{1,2\}[:][[:xdigit:]]\{1,2\}[:][[:xdigit:]]\{1,2\}[:][[:xdigit:]]\{1,2\}`" ];
+			then
+			echo "Invalid value $2 for parameter $1"
+			exit 1
+		fi
+		;;
+
+	    *)
+		echo "Invalid parameter: $parm"
+		exit 1
+		;;
+	esac
+}
+
+mask2cidr() {
+	nbits=0
+	IFS=.
+	for dec in $1 ; do
+		case $dec in
+			255) let nbits+=8;;
+			254) let nbits+=7;;
+			252) let nbits+=6;;
+			248) let nbits+=5;;
+			240) let nbits+=4;;
+			224) let nbits+=3;;
+			192) let nbits+=2;;
+			128) let nbits+=1;;
+			0);;
+			*) echo "Error: $dec is not recognized"; exit 1
+		esac
+	done
+	echo "$nbits"
+}
+
+do_set() {
+	if [ "x$1" = "x" ]
+	then
+		echo "no parameters given for set command - fail"
+		exit 1
+	fi
+	while [ "x$1" != "x" ]; do
+		parm="$1"
+		shift
+		if [ "x$1" = "x" ]; then
+			echo "No value present for parameter $parm"
+			exit 1
+		fi
+		val="$1"
+		shift
+
+		do_check $parm $val
+
+		case $parm in
+			ip_addr)
+				echo $val > /tmp/ip_addr
+				;;
+
+			ip_addr_src)
+				if [ $val == "dhcp" ]; then
+					rm -rf /etc/systemd/network/50-static.network
+					systemctl stop systemd-networkd
+					systemctl start systemd-networkd
+				else
+					if [ ! -f /etc/systemd/network/50-static.network ]; then
+						echo [Match] >> /etc/systemd/network/50-static.network
+						echo Name=eth0 >> /etc/systemd/network/50-static.network
+					fi
+				fi
+				;;
+
+			subnet_mask)
+				echo $(mask2cidr $val) > /tmp/subnet_mask
+				;;
+
+			default_gw_ip_addr)
+				echo $val > /tmp/default_gw_ip_addr
+				;;
+
+			mac_addr)
+				if [ -f /etc/systemd/network/50-static.network ]; then
+					sed -i '/\b\(Link\|MACAddress\)\b/d' /etc/systemd/network/50-static.network
+					echo [Link] >> /etc/systemd/network/50-static.network
+					echo MACAddress="$val" >> /etc/systemd/network/50-static.network
+					if [ -f /tmp/ip_addr ] && [ -f /tmp/subnet_mask ] && [ -f /tmp/default_gw_ip_addr ]
+					then
+						ifconfig eth0 down
+						systemctl stop systemd-networkd
+						systemctl start systemd-networkd
+						ifconfig eth0 down
+					fi
+				else
+					sed -i '/\b\(Link\|MACAddress\)\b/d' /usr/lib/systemd/network/default.network
+					echo [Link] >> /usr/lib/systemd/network/default.network
+					echo MACAddress="$val" >> /usr/lib/systemd/network/default.network
+					ifconfig eth0 down
+					systemctl stop systemd-networkd
+					systemctl start systemd-networkd
+					ifconfig eth0 up
+				fi
+				;;
+
+			*)
+				echo "Invalid parameter: $1"
+				exit 1
+				;;
+		esac
+	done
+
+	if [ ! -f /tmp/ip_addr ] || [ ! -f /tmp/subnet_mask ] || [ ! -f /tmp/default_gw_ip_addr ]
+	then
+		echo "no enaugh parameters given - fail"
+	else
+		tmp_ip_addr="$(</tmp/ip_addr)"
+		tmp_netmask="$(</tmp/subnet_mask)"
+		tmp_gateway="$(</tmp/default_gw_ip_addr)"
+		rm /tmp/ip_addr
+		rm /tmp/subnet_mask
+		rm /tmp/default_gw_ip_addr
+		sed -i '/\b\(Network\|Address\|Gateway\)\b/d' /etc/systemd/network/50-static.network
+
+		echo [Network] >> /etc/systemd/network/50-static.network
+		echo Address="$tmp_ip_addr"/"$tmp_netmask" >> /etc/systemd/network/50-static.network
+		echo Gateway="$tmp_gateway" >> /etc/systemd/network/50-static.network
+		systemctl stop systemd-networkd
+		systemctl start systemd-networkd
+	fi
+}
+
+case $op in
+    get)
+	do_get $@
+	;;
+    set)
+	do_set $@
+	;;
+
+    check)
+	do_check $@
+	;;
+
+*)
+	echo "Unknown operation: $op"
+	exit 1
+esac
diff --git a/lanserv/mellanox/mellanox.c b/lanserv/mellanox/mellanox.c
new file mode 100644
index 0000000..5bd7998
--- /dev/null
+++ b/lanserv/mellanox/mellanox.c
@@ -0,0 +1,1579 @@
+/*
+ * mellanox.c
+ *
+ * Mellanox specific module for handling MC functions.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <signal.h>
+#include <pthread.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <semaphore.h>
+#include <stdlib.h>
+
+#include <OpenIPMI/ipmi_err.h>
+#include <OpenIPMI/ipmi_msgbits.h>
+#include <OpenIPMI/ipmi_bits.h>
+#include <OpenIPMI/ipmi_mc.h>
+#include <OpenIPMI/serv.h>
+#include <OpenIPMI/ipmi_mlx.h>
+#include "../bmc.h"
+
+static lmc_data_t *bmc_mc;
+static unsigned char all_fans_failure = 0;
+
+/**************************************************************************
+ *                  Mellanox custom commands codes                        *
+ *************************************************************************/
+/* IPMI_SENSOR_EVENT_NETFN (0x04) */
+#define IPMI_OEM_MLX_SET_FAN_SPEED_CMD      0x30
+#define IPMI_OEM_MLX_GET_LED_STATE_CMD      0x31
+#define IPMI_OEM_MLX_SET_LED_STATE_CMD      0x32
+#define IPMI_OEM_MLX_SET_LED_BLINKING_CMD   0x33
+#define IPMI_OEM_MLX_GET_FAN_PWM_CMD        0x34
+#define IPMI_OEM_MLX_GET_TOTAL_POWER_CMD    0x35
+
+/* IPMI_APP_NETFN (0x06) */
+#define IPMI_OEM_MLX_SEL_BUFFER_SET_CMD     0x5B
+#define IPMI_OEM_MLX_CPU_READY_EVENT_CMD    0x5c
+#define IPMI_OEM_MLX_CPU_HARD_RESET_CMD     0x5e
+#define IPMI_OEM_MLX_CPU_SOFT_RESET_CMD     0x5f
+#define IPMI_OEM_MLX_RESET_PHY_CMD          0x60
+#define IPMI_OEM_MLX_SET_UART_TO_BMC_CMD    0x61
+#define IPMI_OEM_MLX_THERMAL_ALGORITHM_CMD  0x62
+#define IPMI_OEM_MLX_BMC_UPTIME_GET_CMD     0x63
+#define IPMI_OEM_MLX_LOG_TO_SEL_CMD         0x64
+
+#define IPMI_OEM_MLX_SEL_LOG_SIZE_MIN       0x40
+#define IPMI_OEM_MLX_SEL_LOG_SIZE_MAX       0x0fff
+
+/* Set sel log size script file path */
+#define SEL_SET_SCRIPT_NAME "sel_set_log_size.sh"
+
+/**  FAN FUNCTIONALITY DEFINES  **/
+#define MLX_FAN_MAX   8
+#define MLX_FAN_TACHO_FILE  "/bsp/fan/tacho"
+#define MLX_FAN_PWM_FILE            "/bsp/fan/pwm"
+#define MLX_FAN_PWM_ENABLE_FILE     "/bsp/fan/pwm_en"
+#define MLX_PWM_MIN                 0
+#define MLX_PWM_MAX                 9
+
+static const char* fan_tacho_en[MLX_FAN_MAX] =
+{
+    MLX_FAN_TACHO_FILE"1_en",
+    MLX_FAN_TACHO_FILE"2_en",
+    MLX_FAN_TACHO_FILE"3_en",
+    MLX_FAN_TACHO_FILE"4_en",
+    MLX_FAN_TACHO_FILE"5_en",
+    MLX_FAN_TACHO_FILE"6_en",
+    MLX_FAN_TACHO_FILE"7_en",
+    MLX_FAN_TACHO_FILE"8_en"
+};
+
+/**  LED FUNCTIONALITY DEFINES  **/
+#define LED_FAN_FILE "/bsp/leds/fan/"
+#define LED_STATUS_FILE "/bsp/leds/status/"
+#define LED_BRIGHTNESS "brightness"
+#define LED_TRIGGER    "trigger"
+#define LED_DELAY_OFF  "delay_off"
+#define LED_DELAY_ON   "delay_on"
+#define LED_TIMER      "timer"
+
+#define LED_COLOR_RED    1
+#define LED_COLOR_GREEN  2
+#define LED_COLOR_AMBER  3
+
+#define MLX_LED_BLINK_OFF 0
+#define MLX_LED_BLINK_3HZ 3
+#define MLX_LED_BLINK_6HZ 6
+
+/* Reset links */
+#define MLX_BMC_SOFT_RESET   "/bsp/reset/bmc_reset_soft"
+#define MLX_CPU_HARD_RESET   "/bsp/reset/cpu_reset_hard"
+#define MLX_CPU_SOFT_RESET   "/bsp/reset/cpu_reset_soft"
+#define MLX_SYS_HARD_RESET   "/bsp/reset/system_reset_hard"
+#define MLX_RESET_PHY        "/bsp/reset/reset_phy"
+
+#define MLX_UART_TO_BMC      "/bsp/reset/uart_sel"
+
+#define MLX_PSU_COUNT        2
+#define MLX_PSU_PIN_FILE     "/bsp/environment/psu%i_pin"
+
+/* number of thermal zones */
+#define MLX_MAX_THERMAL_ZONE 1
+#define MLX_THERMAL_ZONE     "/bsp/thermal/thermal_zone%u/mode"
+
+#define MLX_UPTIME_FILE      "/proc/uptime"
+
+static const char* reset_cause[8] =
+{
+    "/bsp/reset/ac_power_cycle",
+    "/bsp/reset/dc_power_cycle",
+    "/bsp/reset/bmc_upgrade",
+    "/bsp/reset/cpu_kernel_panic",
+    "/bsp/reset/cpu_power_down",
+    "/bsp/reset/cpu_reboot",
+    "/bsp/reset/cpu_shutdown",
+    "/bsp/reset/cpu_watchdog"
+};
+
+enum reset_cause_e {
+    MLX_RESET_CAUSE_AC_POWER_CYCLE = 0,
+    MLX_RESET_CAUSE_DC_POWER_CYCLE,
+    MLX_RESET_CAUSE_BMC_UPGRADE,
+    MLX_RESET_CAUSE_CPU_KERNEL_PANIC,
+    MLX_RESET_CAUSE_CPU_POWER_DOWN,
+    MLX_RESET_CAUSE_CPU_REBOOT,
+    MLX_RESET_CAUSE_CPU_SHUTDOWN,
+    MLX_RESET_CAUSE_CPU_WATCHDOG,
+    MLX_RESET_CAUSE_BUTTON
+};
+
+/*
+ * This timer is called periodically to monitor the system reset cause.
+ */
+static ipmi_timer_t *reset_monitor_timer = NULL;
+#define MLX_RESET_MONITOR_TIMEOUT         10
+
+/*
+ * This timer is called periodically to monitor the FANs
+ */
+static ipmi_timer_t *fans_monitor_timer = NULL;
+#define MLX_FANS_MONITOR_TIMEOUT          5
+
+
+
+static unsigned char set_fan_enable(const char* fname)
+{
+    FILE *f_en;
+
+    f_en = fopen(fname, "w");
+
+    if (!f_en) {
+            printf("\nUnable to open %s file", fname);
+            return IPMI_DESTINATION_UNAVAILABLE_CC;
+    } else
+        fprintf(f_en, "%u", 1);
+
+    fclose(f_en);
+
+    return 0;
+}
+
+/**
+ *
+ * ipmitool raw 0x04  0x030  Speed (0x00-0xFF)
+ *
+**/
+static void
+handle_set_fan_speed_cmd (lmc_data_t    *mc,
+                msg_t         *msg,
+                unsigned char *rdata,
+                unsigned int  *rdata_len,
+                void          *cb_data)
+{
+    FILE *f_pwm;
+    unsigned char pwm = 0;
+
+    pwm = msg->data[0];
+    if (pwm > MLX_PWM_MAX) {
+        rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+        *rdata_len = 1;
+        return;
+    }
+
+    f_pwm = fopen(MLX_FAN_PWM_FILE, "w");
+
+    if (!f_pwm) {
+            printf("\nUnable to open pwm file");
+            rdata[0] = IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+            *rdata_len = 1;
+            return;
+    } else {
+        if (IPMI_DESTINATION_UNAVAILABLE_CC == set_fan_enable(MLX_FAN_PWM_ENABLE_FILE)) {
+            rdata[0] = IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+            *rdata_len = 1;
+            return;
+    } else
+        fprintf(f_pwm, "%u", pwm);
+    }
+
+    fclose(f_pwm);
+    rdata[0] = 0;
+    *rdata_len = 1;
+}
+
+/**
+ *
+ * ipmitool raw 0x04  0x34
+ *
+**/
+static void
+handle_get_fan_pwm_cmd(lmc_data_t    *mc,
+                       msg_t         *msg,
+                       unsigned char *rdata,
+                       unsigned int  *rdata_len,
+                       void          *cb_data)
+{
+    unsigned char rv = 0;
+    char line_pwm[10];
+    int pwm;
+    FILE *fpwm;
+
+    fpwm = fopen(MLX_FAN_PWM_FILE, "r");
+
+    if (!fpwm) {
+        printf("\nUnable to open  PWM file");
+        rdata[0] = IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+        *rdata_len = 1;
+	return;
+    }
+
+    if (0 >= fread(line_pwm, 1, sizeof(line_pwm),fpwm))
+    {
+        fclose(fpwm);
+        rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+        *rdata_len = 1;
+	return;
+    }
+
+    pwm = strtoul(line_pwm, NULL, 0);
+
+    fclose(fpwm);
+
+    rdata[0] = 0;
+    rdata[1] = pwm;
+    *rdata_len = 2;
+    return;
+}
+
+static unsigned char set_led_command(unsigned char led,
+                            unsigned char color,
+                            unsigned char cmd)
+{
+    FILE *fbrightness;
+    FILE *ftrigger;
+    char fname[100];
+    char cmd_trigger[100];
+
+    memset(fname, 0, sizeof(fname));
+    memset(cmd_trigger, 0, sizeof(cmd_trigger));
+
+    switch (color) {
+    case LED_COLOR_RED:
+        if (led <= sys_devices.status_led_number) {
+            if (cmd)
+                sprintf(cmd_trigger,"echo timer > %sred/%s\n",LED_STATUS_FILE, LED_TRIGGER);
+
+            sprintf(fname, "%sred/%s", LED_STATUS_FILE, LED_BRIGHTNESS);
+        }
+        else {
+            if (cmd)
+                sprintf(cmd_trigger,"echo timer > %sred/%u/%s\n",LED_FAN_FILE, led - sys_devices.status_led_number, LED_TRIGGER);
+
+            sprintf(fname, "%sred/%u/%s", LED_FAN_FILE, led - sys_devices.status_led_number, LED_BRIGHTNESS);
+        }
+        break;
+    case LED_COLOR_GREEN:
+        if (led <= sys_devices.status_led_number) {
+            if (cmd)
+                sprintf(cmd_trigger,"echo timer > %sgreen/%s\n",LED_STATUS_FILE, LED_TRIGGER);
+
+            sprintf(fname, "%sgreen/%s", LED_STATUS_FILE, LED_BRIGHTNESS);
+        }
+        else {
+            if (cmd)
+                sprintf(cmd_trigger,"echo timer > %sgreen/%u/%s\n",LED_FAN_FILE, led - sys_devices.status_led_number, LED_TRIGGER);
+
+            sprintf(fname, "%sgreen/%u/%s", LED_FAN_FILE, led - sys_devices.status_led_number, LED_BRIGHTNESS);
+        }
+        break;
+    case LED_COLOR_AMBER:
+        if (cmd)
+            sprintf(cmd_trigger,"echo timer > %samber/%s\n",LED_STATUS_FILE, LED_TRIGGER);
+
+        sprintf(fname, "%samber/%s", LED_STATUS_FILE, LED_BRIGHTNESS);
+        break;
+    default:
+        break;
+    }
+
+    fbrightness = fopen(fname, "w");
+
+    if (!fbrightness) {
+        fclose(fbrightness);
+        return IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+    }
+
+    fprintf(fbrightness, "%u", cmd);
+    system(cmd_trigger);
+
+    fclose(fbrightness);
+
+    return 0;
+}
+
+/**
+ *
+ * ipmitool raw 0x04  0x32  LedNum  Color
+ *
+ * LedNum:
+ * 0x1 - status LED
+ * 0x2 - FAN1 LED
+ * 0x3 - FAN2 LED
+ * 0x4 - FAN2 LED
+ * 0x5 - FAN2 LED
+ *
+ * Color:
+ * 0x1 - red 0x2 - green 0x3 - amber
+**/
+static void
+handle_set_led_state(lmc_data_t    *mc,
+                     msg_t         *msg,
+                     unsigned char *rdata,
+                     unsigned int  *rdata_len,
+                     void          *cb_data)
+{
+    unsigned char rv = 0;
+    unsigned char led, color;
+
+    if (check_msg_length(msg, 2, rdata, rdata_len))
+        return;
+
+    led = msg->data[0];
+    if (led > sys_devices.status_led_number + sys_devices.fan_led_number ||
+        led == 0) {
+        rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+        *rdata_len = 1;
+        return;
+    }
+
+    color = msg->data[1];
+    if (color <  LED_COLOR_RED || color > LED_COLOR_AMBER) {
+        rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+        *rdata_len = 1;
+        return;
+    }
+
+    switch (color) {
+    case LED_COLOR_AMBER:
+        if (led > sys_devices.status_led_number) {
+            rv = IPMI_INVALID_DATA_FIELD_CC;
+            goto out;
+        }
+        rv = set_led_command(led, LED_COLOR_RED, 0);
+        if (rv)
+            goto out;
+        rv = set_led_command(led, LED_COLOR_GREEN, 0);
+        if (rv)
+            goto out;
+        rv = set_led_command(led, LED_COLOR_AMBER, 1);
+        if (rv)
+            goto out;
+        break;
+    case LED_COLOR_RED:
+        if (led <= sys_devices.status_led_number){
+            rv = set_led_command(led, LED_COLOR_AMBER, 0);
+            if (rv)
+                goto out;
+        }
+        rv = set_led_command(led, LED_COLOR_GREEN, 0);
+        if (rv)
+            goto out;
+        rv = set_led_command(led, LED_COLOR_RED, 1);
+        if (rv)
+            goto out;
+        break;
+    case LED_COLOR_GREEN:
+        if (led <= sys_devices.status_led_number) {
+            rv = set_led_command(led, LED_COLOR_AMBER, 0);
+            if (rv)
+                goto out;
+        }
+        rv = set_led_command(led, LED_COLOR_RED, 0);
+        if (rv)
+            goto out;
+        rv = set_led_command(led, LED_COLOR_GREEN, 1);
+        if (rv)
+            goto out;
+        break;
+    default:
+        break;
+    }
+
+ out:
+    rdata[0] = rv;
+    *rdata_len = 1;
+}
+
+/**
+ *
+ * ipmitool raw 0x04  0x33  LedNum  Color Time
+ *
+ * LedNum:
+ * 0x1 - status LED
+ * 0x2 - FAN1 LED
+ * 0x3 - FAN2 LED
+ * 0x4 - FAN2 LED
+ * 0x5 - FAN2 LED
+ *
+ * Color:
+ * 0x1 - red
+ * 0x2 - green
+ * 0x3 - amber 
+ *
+ * Time: 
+ * 0x0 - off blinking
+ * 0x3 - blinking 3HZ
+ * 0x6 - blinking 6HZ 
+ *
+ *  */ 
+static void
+handle_set_led_blinking (lmc_data_t    *mc,
+                msg_t         *msg,
+                unsigned char *rdata,
+                unsigned int  *rdata_len,
+                void          *cb_data)
+{
+    unsigned char led;
+    unsigned char time;
+    unsigned char color;
+    FILE *f_delayon;
+    FILE *f_delayoff;
+    char fname[100];
+
+    if (check_msg_length(msg, 3, rdata, rdata_len))
+        return;
+
+    led = msg->data[0];
+    color = msg->data[1];
+    time = msg->data[2];
+    if (led == 0 ||
+        led > sys_devices.status_led_number + sys_devices.fan_led_number || 
+        color > LED_COLOR_AMBER ||
+        color < LED_COLOR_RED ||
+        (time != MLX_LED_BLINK_OFF && 
+         time != MLX_LED_BLINK_3HZ && 
+         time != MLX_LED_BLINK_6HZ)) {
+        rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+        *rdata_len = 1;
+        return;
+    }
+
+    if (led <= sys_devices.status_led_number) {
+        switch (color) {
+        case LED_COLOR_RED:
+            memset(fname, 0, sizeof(fname));
+            sprintf(fname, "%sred/%s", LED_STATUS_FILE, LED_DELAY_OFF);
+            f_delayoff = fopen(fname, "w");
+            memset(fname, 0, sizeof(fname));
+            sprintf(fname, "%sred/%s", LED_STATUS_FILE,LED_DELAY_ON);
+            f_delayon = fopen(fname, "w");
+            break;
+        case LED_COLOR_GREEN:
+            memset(fname, 0, sizeof(fname));
+            sprintf(fname, "%sgreen/%s", LED_STATUS_FILE, LED_DELAY_OFF);
+            f_delayoff = fopen(fname, "w");
+            memset(fname, 0, sizeof(fname));
+            sprintf(fname, "%sgreen/%s", LED_STATUS_FILE,LED_DELAY_ON);
+            f_delayon = fopen(fname, "w");
+            break;
+        case LED_COLOR_AMBER:
+            memset(fname, 0, sizeof(fname));
+            sprintf(fname, "%samber/%s", LED_STATUS_FILE, LED_DELAY_OFF);
+            f_delayoff = fopen(fname, "w");
+            memset(fname, 0, sizeof(fname));
+            sprintf(fname, "%samber/%s", LED_STATUS_FILE,LED_DELAY_ON);
+            f_delayon = fopen(fname, "w");
+            break;
+        default:
+            break;
+        }
+    }
+    else if (led > sys_devices.status_led_number && 
+             led < sys_devices.status_led_number + sys_devices.fan_led_number) {
+        switch (color) {
+        case LED_COLOR_RED:
+            memset(fname, 0, sizeof(fname));
+            sprintf(fname, "%sred/%u/%s", LED_FAN_FILE, led - sys_devices.status_led_number, LED_DELAY_OFF);
+            f_delayoff = fopen(fname, "w");
+            memset(fname, 0, sizeof(fname));
+            sprintf(fname, "%sred/%s", LED_FAN_FILE, led - sys_devices.status_led_number,LED_DELAY_ON);
+            f_delayon = fopen(fname, "w");
+            break;
+        case LED_COLOR_GREEN:
+            memset(fname, 0, sizeof(fname));
+            sprintf(fname, "%sgreen/%u/%s", LED_FAN_FILE, led - sys_devices.status_led_number, LED_DELAY_OFF);
+            f_delayoff = fopen(fname, "w");
+            memset(fname, 0, sizeof(fname));
+            sprintf(fname, "%sgreen/%u/%s", LED_FAN_FILE, led - sys_devices.status_led_number,LED_DELAY_ON);
+            f_delayon = fopen(fname, "w");
+            break;
+        default:
+            break;
+        }
+    }
+
+    if (!f_delayon || !f_delayoff) {
+        if (f_delayoff)
+            fclose(f_delayoff);
+        if (f_delayon)
+            fclose(f_delayon);
+
+        rdata[0] = IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+        *rdata_len = 1;
+        return;
+    }
+
+    switch (time) {
+    case MLX_LED_BLINK_OFF:
+        fprintf(f_delayoff, "%u", 0);
+        fprintf(f_delayon, "%u", 0);
+        break;
+    case MLX_LED_BLINK_3HZ:
+        fprintf(f_delayoff, "%u", 83);
+        fprintf(f_delayon, "%u", 83);
+        break;
+    case MLX_LED_BLINK_6HZ:
+        fprintf(f_delayoff, "%u", 167);
+        fprintf(f_delayon, "%u", 167);
+        break;
+    default:
+        break;
+    }
+
+    fclose(f_delayon);
+    fclose(f_delayoff);
+
+    rdata[0] = 0;
+    *rdata_len = 1;
+}
+
+
+static unsigned char get_led_color(unsigned int led, unsigned char *color)
+{
+    FILE *f_green;
+    FILE *f_red;
+    FILE *f_amber;
+    char line_green[10];
+    char line_red[10];
+    char line_amber[10];
+    int red, green, amber;
+    char fname[100];
+
+    if (led <= sys_devices.status_led_number) {
+        memset(fname, 0, sizeof(fname));
+        sprintf(fname, "%samber/%s", LED_STATUS_FILE, LED_BRIGHTNESS);
+
+        f_amber = fopen(fname, "r");
+        if (!f_amber) {
+            printf("\nUnable to open LED status file");
+            return IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+        }
+
+        if (0 >= fread(line_amber, 1, sizeof(line_amber),f_amber)) {
+            fclose(f_amber);
+            return IPMI_INVALID_DATA_FIELD_CC;
+        }
+
+        amber = strtoul(line_amber, NULL, 0);
+
+        memset(fname, 0, sizeof(fname));
+        sprintf(fname, "%sgreen/%s", LED_STATUS_FILE, LED_BRIGHTNESS);
+        f_green = fopen(fname, "r");
+
+        memset(fname, 0, sizeof(fname));
+        sprintf(fname, "%sred/%s", LED_STATUS_FILE, LED_BRIGHTNESS);
+        f_red = fopen(fname, "r");
+    }
+    else {
+        memset(fname, 0, sizeof(fname));
+        sprintf(fname, "%sgreen/%u/%s", LED_FAN_FILE, led - sys_devices.status_led_number, LED_BRIGHTNESS);
+        f_green = fopen(fname, "r");
+
+        memset(fname, 0, sizeof(fname));
+        sprintf(fname, "%sred/%u/%s", LED_FAN_FILE, led - sys_devices.status_led_number, LED_BRIGHTNESS);
+        f_red = fopen(fname, "r");
+    }
+
+    if (!f_green || !f_red) {
+        printf("\nUnable to open LED status file");
+        if (led <= sys_devices.status_led_number)
+            fclose(f_amber);
+        if (f_red)
+            fclose(f_red);
+        if (f_green)
+            fclose(f_green);
+
+        return IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+    }
+
+    if ((0 >= fread(line_green, 1, sizeof(line_green),f_green))||
+         (0 >= fread(line_red, 1, sizeof(line_red),f_red)))
+    {
+        if (led <= sys_devices.status_led_number)
+            fclose(f_amber);
+        fclose(f_green);
+        fclose(f_red);
+        return IPMI_INVALID_DATA_FIELD_CC;
+    }
+
+    red = strtoul(line_red, NULL, 0);
+    green = strtoul(line_green, NULL, 0);
+
+    if (led <= sys_devices.status_led_number) {
+        if (amber && !green && !red)
+            *color = LED_COLOR_AMBER;
+        else if (!amber && green && !red)
+            *color = LED_COLOR_GREEN;
+        else
+            *color = LED_COLOR_RED;
+
+        fclose(f_amber);
+    }
+    else {
+        if (!red && green)
+            *color = LED_COLOR_GREEN;
+        else
+            *color = LED_COLOR_RED;
+    }
+
+    fclose(f_green);
+    fclose(f_red);
+
+    return 0;
+}
+
+/**
+ *
+ * ipmitool raw 0x04  0x31  LedNum
+ *
+ * LedNum:
+ * 0x0 - status LED
+ * 0x1 - FAN1 LED
+ * 0x2 - FAN2 LED
+ * 0x3 - FAN2 LED
+ * 0x4 - FAN2 LED
+ *
+**/
+static void
+handle_get_led_state(lmc_data_t    *mc,
+                     msg_t         *msg,
+                     unsigned char *rdata,
+                     unsigned int  *rdata_len,
+                     void          *cb_data)
+{
+    unsigned int led;
+    unsigned char color = LED_COLOR_RED;
+    unsigned char rv = 0;
+
+    if (check_msg_length(msg, 1, rdata, rdata_len))
+	return;
+
+    led = msg->data[0];
+    if (led > sys_devices.status_led_number + sys_devices.fan_led_number) {
+        rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+        *rdata_len = 1;
+        return;
+    }
+
+    rdata[0] = 0;
+    rdata[1] = 0;
+
+    rv = get_led_color(led, &color);
+
+    if (rv) {
+        rdata[0] = rv;
+        *rdata_len = 1;
+        return;
+    }
+
+    rdata[1] = color;
+    *rdata_len = 2;
+    return;
+}
+
+/**
+ *
+ *  ipmitool raw 0x06  0x02
+ *
+ **/
+static void
+handle_bmc_cold_reset(lmc_data_t    *mc,
+			  msg_t         *msg,
+			  unsigned char *rdata,
+			  unsigned int  *rdata_len,
+			  void          *cb_data)
+{
+    sys_data_t *sys = cb_data;
+    FILE *freset;
+
+    freset = fopen(MLX_BMC_SOFT_RESET, "w");
+
+    if (!freset) {
+            printf("\nUnable to open reset file");
+            rdata[0] = IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+            *rdata_len = 1;
+            return;
+    } else {
+        mlx_add_event_to_sel(mc, IPMI_SENSOR_TYPE_SYSTEM_BOOT_INITIATED, mc->ipmb, 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x6);
+
+        if (reset_monitor_timer)
+            sys->free_timer(reset_monitor_timer);
+
+        fprintf(freset, "%u", 0);
+    }
+
+    fclose(freset);
+    rdata[0] = 0;
+    *rdata_len = 1;
+}
+
+/**
+ *
+ *  ipmitool raw 0x06 0x5c [0x0]
+ *
+ **/
+static void
+handle_cpu_ready_event(lmc_data_t    *mc,
+			  msg_t         *msg,
+			  unsigned char *rdata,
+			  unsigned int  *rdata_len,
+			  void          *cb_data)
+{
+    unsigned char status_led_run_str[32];
+    unsigned int ready;
+
+    if (check_msg_length(msg, 1, rdata, rdata_len)) {
+        ready = 1;
+    }
+    else {
+        ready = msg->data[0];
+        if (ready != 0 ) {
+            rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+            *rdata_len = 1;
+            return;
+        }
+    }
+
+
+   if (sprintf(status_led_run_str,"status_led.py 0x%02x %d 0x%02x\n",0xbb, ready, IPMI_SENSOR_TYPE_PROCESSOR))
+       system(status_led_run_str);
+
+   if (ready) {
+        /* set "Presence detected" if CPU started successfully */
+        system("echo 128 > /bsp/environment/cpu_status");
+   }
+   else {
+        /* set "IERR" in case something goes wrong on CPU sturtup */
+        system("echo 1 > /bsp/environment/cpu_status");
+   }
+    rdata[0] = 0;
+    *rdata_len = 1;
+}
+
+/**
+ *
+ *  ipmitool raw 0x06  0x5e [off/on] [0x1]
+ *
+ **/
+static void
+handle_cpu_hard_reset(lmc_data_t    *mc,
+			  msg_t         *msg,
+			  unsigned char *rdata,
+			  unsigned int  *rdata_len,
+			  void          *cb_data)
+{
+    printf("\n %d: %s, %s()", __LINE__, __FILE__, __FUNCTION__);
+
+    FILE *freset;
+    unsigned int reset;
+    unsigned char cpu_reboot_cmd = 0;
+
+    if (check_msg_length(msg, 1, rdata, rdata_len)) {
+        reset = 0;
+    }
+    else {
+        if (check_msg_length(msg, 2, rdata, rdata_len)) {
+            reset = msg->data[0];
+        }
+        else {
+            reset = msg->data[0];
+            cpu_reboot_cmd = msg->data[1];
+        }
+
+        if (reset > 1 || cpu_reboot_cmd > 1) {
+            rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+            *rdata_len = 1;
+            return;
+        }
+    }
+
+    freset = fopen(MLX_CPU_HARD_RESET, "w");
+
+    if (!freset) {
+            printf("\nUnable to open reset file");
+            rdata[0] = IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+            *rdata_len = 1;
+            return;
+    } else {
+        fprintf(freset, "%u", reset);
+    }
+
+    fclose(freset);
+
+    if (!reset) {
+        if (cpu_reboot_cmd)
+            mlx_add_event_to_sel(mc, IPMI_SENSOR_TYPE_OS_CRITICAL_STOP , 40, 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x3);
+        else
+            mlx_add_event_to_sel(mc, IPMI_SENSOR_TYPE_OS_CRITICAL_STOP , 0, 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x3);
+
+    }
+
+    rdata[0] = 0;
+    *rdata_len = 1;
+}
+
+/**
+ *
+ *  ipmitool raw 0x06  0x5f [0x1]
+ *
+ **/
+static void
+handle_cpu_soft_reset(lmc_data_t    *mc,
+                      msg_t         *msg,
+                      unsigned char *rdata,
+                      unsigned int  *rdata_len,
+                      void          *cb_data)
+{
+    FILE *freset;
+    unsigned char cpu_reboot_cmd = 0;
+
+    if (!check_msg_length(msg, 1, rdata, rdata_len)) {
+        cpu_reboot_cmd = msg->data[0];
+        if (cpu_reboot_cmd != 1 ) {
+            rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+            *rdata_len = 1;
+            return;
+        }
+    }
+
+    freset = fopen(MLX_CPU_SOFT_RESET, "w");
+
+    if (!freset) {
+            printf("\nUnable to open reset file");
+            rdata[0] = IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+            *rdata_len = 1;
+            return;
+    } else {
+        fprintf(freset, "%u", 0);
+    }
+
+    fclose(freset);
+
+    if (cpu_reboot_cmd) {
+        mlx_add_event_to_sel(mc, IPMI_SENSOR_TYPE_SYSTEM_BOOT_INITIATED, 40, 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x7); 
+    }
+    else
+        mlx_add_event_to_sel(mc, IPMI_SENSOR_TYPE_SYSTEM_BOOT_INITIATED, 0, 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x7); 
+
+    rdata[0] = 0;
+    *rdata_len = 1;
+}
+
+/**
+ *
+ *  ipmitool raw 0x06  0x60
+ *
+ **/
+static void
+handle_reset_phy(lmc_data_t    *mc,
+                     msg_t         *msg,
+                     unsigned char *rdata,
+                     unsigned int  *rdata_len,
+                     void          *cb_data)
+{
+    printf("\n %d: %s, %s()", __LINE__, __FILE__, __FUNCTION__);
+
+    FILE *freset;
+
+    freset = fopen(MLX_RESET_PHY, "w");
+
+    if (!freset) {
+            printf("\nUnable to open reset file");
+            rdata[0] = IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+            *rdata_len = 1;
+            return;
+    } else {
+        fprintf(freset, "%u", 0);
+    }
+
+    fclose(freset);
+    rdata[0] = 0;
+    *rdata_len = 1;
+}
+
+/**
+ *
+ *  ipmitool raw 0x06  0x61 (BMC - no value)
+ *  ipmitool raw 0x06  0x61 1 (CPU)
+ *
+ **/
+static void
+handle_set_uart_to_bmc(lmc_data_t    *mc,
+                     msg_t         *msg,
+                     unsigned char *rdata,
+                     unsigned int  *rdata_len,
+                     void          *cb_data)
+{
+    printf("\n %d: %s, %s()", __LINE__, __FILE__, __FUNCTION__);
+
+    FILE *fset;
+    unsigned int uart;
+
+    if (check_msg_length(msg, 1, rdata, rdata_len)) {
+        uart = 0;
+    }
+    else {
+        uart = msg->data[0];
+        if (uart != 1 ) {
+            rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+            *rdata_len = 1;
+            return;
+        }
+    }
+
+    fset = fopen(MLX_UART_TO_BMC, "w");
+
+    if (!fset) {
+            printf("\nUnable to open file");
+            rdata[0] = IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+            *rdata_len = 1;
+            return;
+    } else {
+        fprintf(fset, "%u", uart);
+    }
+
+    fclose(fset);
+    rdata[0] = 0;
+    *rdata_len = 1;
+}
+
+/**
+ *
+ *  ipmitool raw 0x06  0x5B size_LSB size_MSB
+ *
+ **/
+static void
+handle_sel_buffer_set(lmc_data_t    *mc,
+              msg_t         *msg,
+              unsigned char *rdata,
+              unsigned int  *rdata_len,
+              void          *cb_data)
+{
+    uint16_t max_entries = 0;
+    char sel_set_cmd_buf[100];
+
+    if (check_msg_length(msg, 2, rdata, rdata_len)){
+        return;
+    }
+
+    max_entries = msg->data[0] | (((uint16_t) msg->data[1]) << 8);
+
+    if ((max_entries < IPMI_OEM_MLX_SEL_LOG_SIZE_MIN) ||
+        (max_entries > IPMI_OEM_MLX_SEL_LOG_SIZE_MAX)){
+        rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+        *rdata_len = 1;
+        return;
+    }
+
+    snprintf(sel_set_cmd_buf, sizeof(sel_set_cmd_buf), "%s %d", SEL_SET_SCRIPT_NAME, max_entries);
+    rdata[0] = system(sel_set_cmd_buf);
+
+    ipmi_mc_enable_sel(mc, max_entries, mc->sel.flags);
+    *rdata_len = 1;
+}
+
+/**
+ *
+ *  ipmitool raw 0x06  0x62 [zone] [enable/disable]
+ *
+ **/
+static void
+handle_thermal_algorithm_set(lmc_data_t    *mc,
+                     msg_t         *msg,
+                     unsigned char *rdata,
+                     unsigned int  *rdata_len,
+                     void          *cb_data)
+{
+    unsigned int zone, state;
+    FILE *file;
+    char fname[100];
+
+    if (check_msg_length(msg, 2, rdata, rdata_len))
+        return;
+
+    zone = msg->data[0];
+    if (zone >= MLX_MAX_THERMAL_ZONE) {
+        rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+        *rdata_len = 1;
+        return;
+    }
+
+    state = msg->data[1];
+    if (state > 1) {
+        rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+        *rdata_len = 1;
+        return;
+    }
+
+    memset(fname, 0, sizeof(fname));
+    sprintf(fname, MLX_THERMAL_ZONE, zone);
+    file = fopen(fname, "w");
+
+    if (!file) {
+        rdata[0] = IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+        *rdata_len = 1;
+     return;
+    } else {
+        if (state) 
+            fprintf(file, "enabled");
+        else
+            fprintf(file, "disabled");
+
+        fclose(file);
+    }
+
+    rdata[0] = 0;
+    *rdata_len = 1;
+}
+
+/**
+ *
+ *  ipmitool raw 0x04  0x15
+ *
+ **/
+static void handle_get_last_processed_event(lmc_data_t    *mc,
+              msg_t         *msg,
+              unsigned char *rdata,
+              unsigned int  *rdata_len,
+              void          *cb_data)
+{
+    sel_entry_t *entry;
+    sel_entry_t *p_entry = NULL;
+    int         offset;
+    int         count;
+
+    if (mc->sel.count == 0) {
+        rdata[0] = IPMI_NOT_PRESENT_CC;
+        *rdata_len = 1;
+        return;
+    }
+
+    entry = mc->sel.entries;
+    if (entry) {
+        while (entry->next) {
+            p_entry = entry;
+            entry = entry->next;
+            }
+    }
+
+    rdata[0] = 0;
+    rdata[1] = 0xff;
+    rdata[2] = 0xff;
+
+    ipmi_set_uint16(rdata+4, entry->record_id);
+    *rdata_len = 3;
+
+    offset = 0x00;
+    count = 0xff;
+
+    if ((offset+count) > 16)
+        count = 16 - offset;
+    memcpy(rdata+5, entry->data+offset, count);
+    *rdata_len = count + 5;
+}
+
+/*
+ * Chassis control for the chassis
+ */
+static int
+bmc_set_chassis_control(lmc_data_t *mc, int op, unsigned char *val,
+                        void *cb_data)
+{
+    FILE *freset;
+
+    switch (op) {
+    case CHASSIS_CONTROL_POWER:
+    case CHASSIS_CONTROL_BOOT_INFO_ACK:
+    case CHASSIS_CONTROL_BOOT:
+    case CHASSIS_CONTROL_GRACEFUL_SHUTDOWN:
+        break;
+    case CHASSIS_CONTROL_RESET:
+        freset = fopen(MLX_SYS_HARD_RESET, "w");
+
+        if (!freset) {
+                return ETXTBSY;
+        } else {
+            mlx_add_event_to_sel(mc, IPMI_SENSOR_TYPE_SYSTEM_EVENT, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x1);
+            fprintf(freset, "%u", 0);
+        }
+
+        fclose(freset);
+        break;
+    default:
+        return EINVAL;
+    }
+
+    return 0;
+}
+
+/**
+ *
+ * ipmitool raw 0x04  0x35
+ *
+**/
+static void
+handle_get_total_power_cmd(lmc_data_t    *mc,
+                           msg_t         *msg,
+                           unsigned char *rdata,
+                           unsigned int  *rdata_len,
+                           void          *cb_data)
+{
+    unsigned char rv = 0;
+    char line_pin[10];
+    unsigned char total = 0;
+    FILE *fpin;
+
+    for (int i = 0; i < MLX_PSU_COUNT; ++i) {
+        char filename[50];
+        unsigned int tmp = 0;
+        memset(filename, 0, sizeof(filename));
+        sprintf(filename, MLX_PSU_PIN_FILE, i+1);
+
+        fpin = fopen(filename, "r");
+        if (fpin) {
+            if (0 >= fread(line_pin, 1, sizeof(line_pin),fpin))
+            {
+                fclose(fpin);
+                rdata[0] = IPMI_INVALID_DATA_FIELD_CC;
+                *rdata_len = 1;
+                return;
+            }
+            tmp = strtoul(line_pin, NULL, 0);
+            total += tmp/1000000;
+            fclose(fpin);
+        }
+    }
+
+    rdata[0] = 0;
+    rdata[1] = total;
+    *rdata_len = 2;
+    return;
+}
+
+/**
+ *
+ * ipmitool raw 0x06  0x63
+ *
+**/
+static void
+handle_bmc_uptime_get(lmc_data_t    *mc,
+                       msg_t         *msg,
+                       unsigned char *rdata,
+                       unsigned int  *rdata_len,
+                       void          *cb_data)
+{
+    unsigned char rv = 0;
+    char uptime[10];
+    unsigned int val = 0;
+    unsigned char seconds = 0;
+    unsigned char minutes = 0;
+    unsigned char hours = 0;
+    unsigned char days = 0;
+    FILE *fuptime;
+    sys_data_t *sys = cb_data;
+
+    memset(uptime, 0, sizeof(uptime));
+    fuptime = fopen(MLX_UPTIME_FILE, "r");
+
+    if (!fuptime) {
+        sys->log(sys, OS_ERROR, NULL,"Unable to open  uptime file");
+        rdata[0] = IPMI_COULD_NOT_PROVIDE_RESPONSE_CC;
+        *rdata_len = 1;
+        return;
+    }
+
+    fscanf(fuptime, "%s", uptime);
+    val = strtoul(uptime, NULL, 0);
+
+    fclose(fuptime);
+
+    seconds = val%60;
+    days = (val - seconds)/86400; /* 60*60*24 */
+    hours = (val - seconds)/3600 - days*24;
+    minutes = (val - seconds)/60 - (hours*60 + days*24*60);
+
+    rdata[0] = 0;
+    rdata[1] = days;
+    rdata[2] = hours;
+    rdata[3] = minutes;
+    rdata[4] = seconds;
+    *rdata_len = 5;
+    return;
+}
+
+/**
+ *
+ * ipmitool raw 0x06  0x64 [sdr_type] [direction] [event_type]
+ *
+**/
+static void
+handle_log_to_sel(lmc_data_t    *mc,
+                  msg_t         *msg,
+                  unsigned char *rdata,
+                  unsigned int  *rdata_len,
+                  void          *cb_data)
+{
+    unsigned char sdr_type;
+    unsigned char direction;
+    unsigned char event_type;
+
+    if (check_msg_length(msg, 3, rdata, rdata_len)) {
+        return;
+    }
+
+    sdr_type = msg->data[0];
+    direction = msg->data[1];
+    event_type = msg->data[2];
+
+    mlx_add_event_to_sel(mc, sdr_type , 0, direction, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, event_type);
+
+    rdata[0] = 0;
+    *rdata_len = 1;
+    return;
+}
+
+static void
+reset_monitor_timeout(void *cb_data)
+{
+    sys_data_t *sys = cb_data;
+    int i;
+    struct timeval tv;
+    int fd;
+    int rv;
+
+    for (i = 0; i < 8; ++i) {
+        unsigned char c = 0;
+        int active = 0;
+
+        fd = open(reset_cause[i], O_RDONLY);
+
+        rv = read(fd, &c, 1);
+        if (rv != 1) {
+            sys->log(sys, OS_ERROR, NULL, "Warning: filed to read '%s' file", reset_cause[i]);
+            continue;
+        }
+        active = atoi(&c);
+        if (active) {
+            switch (i) {
+            case MLX_RESET_CAUSE_AC_POWER_CYCLE:
+                //"Power Unit", "Power cycle"
+                mlx_add_event_to_sel(sys->mc, IPMI_SENSOR_TYPE_POWER_UNIT, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x1);
+                break;
+            case MLX_RESET_CAUSE_DC_POWER_CYCLE:
+                //"System Event", "OEM System boot event"
+                mlx_add_event_to_sel(sys->mc, IPMI_SENSOR_TYPE_SYSTEM_EVENT, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x1);
+                break;
+            case MLX_RESET_CAUSE_BMC_UPGRADE:
+                //"Version Change", "Firmware or software change success"
+                mlx_add_event_to_sel(sys->mc, IPMI_SENSOR_TYPE_VERSION_CHANGE, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x7);
+                break;
+            case MLX_RESET_CAUSE_CPU_KERNEL_PANIC:
+                //"System Firmware Error", "Unknown Error"
+                mlx_add_event_to_sel(sys->mc, IPMI_SENSOR_TYPE_SYSTEM_FIRMWARE_PROGRESS, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x0);
+                break;
+            case MLX_RESET_CAUSE_CPU_POWER_DOWN:
+                //"Power Unit", "Power off/down"
+                mlx_add_event_to_sel(sys->mc, IPMI_SENSOR_TYPE_POWER_UNIT, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x0);
+                break;
+            case MLX_RESET_CAUSE_CPU_REBOOT:
+                //"System Boot Initiated", "System Restart" 
+                mlx_add_event_to_sel(sys->mc, IPMI_SENSOR_TYPE_SYSTEM_BOOT_INITIATED, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x7);
+                break;
+            case MLX_RESET_CAUSE_CPU_SHUTDOWN:
+                //"OS Stop/Shutdown", "OS graceful shutdown"
+                mlx_add_event_to_sel(sys->mc, IPMI_SENSOR_TYPE_OS_CRITICAL_STOP, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x3);
+                break;
+            case MLX_RESET_CAUSE_CPU_WATCHDOG:
+                //"Watchdog 2", "Power cycle"
+                mlx_add_event_to_sel(sys->mc, IPMI_SENSOR_TYPE_WATCHDOG_2, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x3);
+                break;
+            case MLX_RESET_CAUSE_BUTTON:
+                //"Button", "Reset Button pressed"
+                mlx_add_event_to_sel(sys->mc, IPMI_SENSOR_TYPE_BUTTON, 0 , 0, IPMI_EVENT_READING_TYPE_SENSOR_SPECIFIC, 0x2);
+                break;
+            }
+        }
+        close(fd);
+    }
+
+    tv.tv_sec = MLX_RESET_MONITOR_TIMEOUT;
+    tv.tv_usec = 0;
+    sys->start_timer(reset_monitor_timer, &tv);
+}
+
+static void
+fans_monitor_timeout(void *cb_data)
+{
+    sys_data_t *sys = cb_data;
+    struct timeval tv;
+    int failed = 0;
+    int i = 0;
+    unsigned char fname[30];
+
+    for (i = 1; i <= sys_devices.fan_tacho_number; ++i) {
+        memset(fname, 0, sizeof(fname));
+        sprintf(fname, "/bsp/fan/tacho%i_rpm", i);
+        if (access(fname, F_OK) != 0)
+            ++failed;
+    }
+
+    if (failed == sys_devices.fan_tacho_number) {
+        if (all_fans_failure == 0) {
+            mlx_add_event_to_sel(sys->mc, IPMI_SENSOR_TYPE_FAN, 0 , 0, IPMI_EVENT_READING_TYPE_DISCRETE_DEVICE_ENABLE, 0x0);
+            all_fans_failure = 1;
+        }
+    }
+    else if (all_fans_failure == 1) {
+        mlx_add_event_to_sel(sys->mc, IPMI_SENSOR_TYPE_FAN, 0 , 1, IPMI_EVENT_READING_TYPE_DISCRETE_DEVICE_ENABLE, 0x0);
+        all_fans_failure = 0;
+    }
+
+    tv.tv_sec = MLX_FANS_MONITOR_TIMEOUT;
+    tv.tv_usec = 0;
+    sys->start_timer(fans_monitor_timer, &tv);
+}
+
+/*
+ * Chassis control get for the chassis.
+ */
+static int
+bmc_get_chassis_control(lmc_data_t *mc, int op, unsigned char *val,
+			void *cb_data)
+{
+    *val = 1;
+    return 0;
+}
+
+int
+ipmi_sim_module_print_version(sys_data_t *sys, char *initstr)
+{
+    printf("IPMI Simulator Mellanox module version 0.1\n");
+    return 0;
+}
+
+/**************************************************************************
+ * Module initialization
+ *************************************************************************/
+/**
+ *
+ * This is used to initialize the module.  It is called after the
+ * configuration has been read from the LAN configuration file, but
+ * before the *.hw commands are run.
+ *
+ **/
+int
+ipmi_sim_module_init(sys_data_t *sys, const char *initstr_i)
+{
+    int rv;
+    unsigned int i;
+    struct timeval tv;
+
+    printf("IPMI Mellanox module");
+
+    rv = ipmi_mc_alloc_unconfigured(sys, 0x20, &bmc_mc);
+    if (rv) {
+	sys->log(sys, OS_ERROR, NULL,
+		 "Unable to allocate an mc: %s", strerror(rv));
+	return rv;
+    }
+
+    rv = set_fan_enable(MLX_FAN_PWM_ENABLE_FILE);
+
+    if (rv) {
+        sys->log(sys, OS_ERROR, NULL,
+                 "Unable to enable pwm_en: %s", strerror(rv));
+    }
+
+    for (i = 0; i < MLX_FAN_MAX; ++i) {
+        rv = set_fan_enable(fan_tacho_en[i]);
+
+        if (rv) {
+            sys->log(sys, OS_ERROR, NULL,
+                     "Unable to enable tacho for FAN%i: %s", i, strerror(rv));
+        }
+    }
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_SENSOR_EVENT_NETFN, IPMI_OEM_MLX_SET_FAN_SPEED_CMD,
+                                       handle_set_fan_speed_cmd, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_SENSOR_EVENT_NETFN, IPMI_OEM_MLX_GET_FAN_PWM_CMD,
+                                       handle_get_fan_pwm_cmd, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_SENSOR_EVENT_NETFN, IPMI_OEM_MLX_GET_LED_STATE_CMD,
+                                       handle_get_led_state, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_SENSOR_EVENT_NETFN, IPMI_OEM_MLX_SET_LED_STATE_CMD,
+                                       handle_set_led_state, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_SENSOR_EVENT_NETFN, IPMI_OEM_MLX_SET_LED_BLINKING_CMD,
+                                       handle_set_led_blinking, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_APP_NETFN, IPMI_COLD_RESET_CMD,
+                                       handle_bmc_cold_reset, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_APP_NETFN, IPMI_OEM_MLX_CPU_READY_EVENT_CMD,
+                                       handle_cpu_ready_event, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_APP_NETFN, IPMI_OEM_MLX_CPU_HARD_RESET_CMD,
+                                       handle_cpu_hard_reset, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_APP_NETFN, IPMI_OEM_MLX_CPU_SOFT_RESET_CMD,
+                                       handle_cpu_soft_reset, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_APP_NETFN, IPMI_OEM_MLX_RESET_PHY_CMD,
+                                       handle_reset_phy, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_APP_NETFN, IPMI_OEM_MLX_SET_UART_TO_BMC_CMD,
+                                       handle_set_uart_to_bmc, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_APP_NETFN, IPMI_OEM_MLX_SEL_BUFFER_SET_CMD,
+                                       handle_sel_buffer_set, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_APP_NETFN, IPMI_OEM_MLX_THERMAL_ALGORITHM_CMD,
+                                       handle_thermal_algorithm_set, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_SENSOR_EVENT_NETFN, IPMI_GET_LAST_PROCESSED_EVENT_ID_CMD,
+                                       handle_get_last_processed_event, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_SENSOR_EVENT_NETFN, IPMI_OEM_MLX_GET_TOTAL_POWER_CMD,
+                                       handle_get_total_power_cmd, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_APP_NETFN, IPMI_OEM_MLX_BMC_UPTIME_GET_CMD,
+                                       handle_bmc_uptime_get, sys);
+
+    rv = ipmi_emu_register_cmd_handler(IPMI_APP_NETFN, IPMI_OEM_MLX_LOG_TO_SEL_CMD,
+                                       handle_log_to_sel, sys);
+
+    ipmi_mc_set_chassis_control_func(bmc_mc, bmc_set_chassis_control,
+                                     bmc_get_chassis_control, sys);
+
+    if (rv) {
+	sys->log(sys, OS_ERROR, NULL,
+		 "Unable to register NEW handler: %s", strerror(rv));
+    }
+
+    rv = sys->alloc_timer(sys, reset_monitor_timeout, sys, &reset_monitor_timer);
+    if (rv) {
+        int errval = errno;
+        sys->log(sys, SETUP_ERROR, NULL, "Unable to create reset monitoring timer");
+        return errval;
+    } else {
+        tv.tv_sec = MLX_RESET_MONITOR_TIMEOUT;
+        tv.tv_usec = 0;
+        sys->start_timer(reset_monitor_timer, &tv);
+    }
+
+    /* set "Disabled" state at startup */
+    system("echo 256 > /bsp/environment/cpu_status");
+
+    return 0;
+}
+
+/**
+ * This is called after the emulator command file is run. This
+ * can be used to finish up configuration of things, add
+ * functions to sensors, do any sensor initialization, or
+ * anything else that needs to be done after the emulator
+ * commands are run.
+**/
+int
+ipmi_sim_module_post_init(sys_data_t *sys)
+{
+    unsigned int fw_maj = 0;
+    unsigned int fw_min = 0;
+    unsigned char id_line[50];
+    unsigned char id_maj[2];
+    unsigned char id_min[2];
+    unsigned int  productId;
+    struct timeval tv;
+    int rv;
+    FILE *fid;
+
+    memset(id_line, 0, sizeof(id_line));
+    memset(id_min, 0, sizeof(id_min));
+    memset(id_maj, 0, sizeof(id_maj));
+
+    system("grep ID_LIKE /etc/os-release > /tmp/release");
+    fid = fopen("/tmp/release", "r");
+
+    if (!fid) {
+        sys->log(sys, OS_ERROR, NULL, "Unable to open  FW ID file");
+        return 0;
+    }
+
+    if (0 >= fread(id_line, 1, sizeof(id_line),fid))
+    {
+        fclose(fid);
+        sys->log(sys, OS_ERROR, NULL, "Unable to read  FW ID file");
+        return 0;
+    }
+
+    fclose(fid);
+
+    memcpy(id_maj, id_line+13, sizeof(id_maj));
+    memcpy(id_min, id_line+15, sizeof(id_min));
+
+    fw_maj = strtoul(id_maj, NULL, 0);
+    fw_min = strtoul(id_min, NULL, 0);
+
+    ipmi_mc_set_fw_revision(bmc_mc, fw_maj, fw_min);
+
+    productId = (sys->mc->product_id[1] << 8) | sys->mc->product_id[0];
+    switch (productId) {
+    case 1: /* Baidu BMC */
+        sys_devices.fan_number = 4;
+        sys_devices.fan_tacho_number = 8;
+        sys_devices.fan_eeprom_number = 4;
+        sys_devices.psu_number = 2;
+        sys_devices.status_led_number = 1;
+        sys_devices.fan_led_number = 4;
+        break;
+    default:
+        break;
+    }
+
+    rv = sys->alloc_timer(sys, fans_monitor_timeout, sys, &fans_monitor_timer);
+    if (rv) {
+        int errval = errno;
+        sys->log(sys, SETUP_ERROR, NULL, "Unable to create FANs monitoring timer");
+        return errval;
+    }
+    else {
+        tv.tv_sec = MLX_FANS_MONITOR_TIMEOUT;
+        tv.tv_usec = 0;
+        sys->start_timer(fans_monitor_timer, &tv);
+    }
+
+    return 0;
+}
diff --git a/lanserv/mellanox/mellanox.hw b/lanserv/mellanox/mellanox.hw
new file mode 100644
index 0000000..bffd10f
--- /dev/null
+++ b/lanserv/mellanox/mellanox.hw
@@ -0,0 +1,324 @@
+########################################################################
+# Copyright (c) 2017 Mellanox Technologies.
+# Copyright (c) 2017 Nataliya Yakuts <nataliyay@mellanox.com>
+#
+# Licensed under the GNU General Public License Version 2
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+
+#
+# HW configuration file for the Mellanox BMC
+#
+
+# The BMC is the MC at address 20
+mc_setbmc 0x20
+
+
+#Product ID:
+# 1 - Baidu BMC
+
+# Now add the BMC
+#      IPMB DevID DevSDRs?       Rev   Maj   Min   Dev   MFG      Prod
+#                                      FW    FW    Sup   ID       Id
+#                                      Rev   Rev
+mc_add 0x20 1 no-device-sdrs  0x01  0x00  0x00  0x9f  0x00500f 0x0001 persist_sdr
+
+#Enable SEL device
+sel_enable 0x20 1000 0x0a
+
+
+#          MC LUN Sens# type reading
+
+########## Temperature ############
+
+# Ambient board Temp
+sensor_add 0x20  0    1     1     1 \
+	poll 5000 \
+	file "/bsp/thermal/amb_carrier_temp" sub=-128000 div=1000
+
+# Ambient switch Temp
+sensor_add 0x20  0    2     1     1 \
+	poll 5000 \
+	file "/bsp/thermal/amb_switch_temp" sub=-128000  div=1000
+
+# PSU1 Temp
+sensor_add 0x20  0    3     1     1 \
+        poll 5000 \
+        file "/bsp/thermal/psu1_temp" sub=-128000 div=1000
+
+# PSU2 Temp
+sensor_add 0x20  0    4     1     1 \
+        poll 5000 \
+        file "/bsp/thermal/psu2_temp" sub=-128000 div=1000
+
+# asic Temp
+sensor_add 0x20  0    5     1     1 \
+        poll 5000 \
+        file "/bsp/thermal/asic_temp" sub=-128000 div=1000
+
+########## FAN ############
+
+#Fan1_1 (max scale 25.000(25.000rpm) -> 250 k=100)
+sensor_add 0x20 0 0x70 4 1\
+        poll 5000 \
+        file "/bsp/fan/tacho1_rpm" div=100
+
+#Fan1_2 (max scale 25.000(25.000rpm) -> 250 k=100)
+sensor_add 0x20 0 0x71 4 1\
+        poll 5000 \
+        file "/bsp/fan/tacho2_rpm" div=100
+
+#Fan2_1 (max scale 25.000(25.000rpm) -> 250 k=100)
+sensor_add 0x20 0 0x72 4 1\
+        poll 5000 \
+        file "/bsp/fan/tacho3_rpm" div=100
+
+#Fan2_2 (max scale 25.000(25.000rpm) -> 250 k=100)
+sensor_add 0x20 0 0x73 4 1\
+        poll 5000 \
+        file "/bsp/fan/tacho4_rpm" div=100
+
+#Fan3_1 (max scale 25.000(25.000rpm) -> 250 k=100)
+sensor_add 0x20 0 0x74 4 1\
+        poll 5000 \
+        file "/bsp/fan/tacho5_rpm" div=100
+
+#Fan3_2 (max scale 25.000(25.000rpm) -> 250 k=100)
+sensor_add 0x20 0 0x75 4 1\
+        poll 5000 \
+        file "/bsp/fan/tacho6_rpm" div=100
+
+#Fan4_1 (max scale 25.000(25.000rpm) -> 250 k=100)
+sensor_add 0x20 0 0x76 4 1\
+        poll 5000 \
+        file "/bsp/fan/tacho7_rpm" div=100
+
+#Fan4_2 (max scale 25.000(25.000rpm) -> 250 k=100)
+sensor_add 0x20 0 0x77 4 1\
+        poll 5000 \
+        file "/bsp/fan/tacho8_rpm" div=100
+
+#PSU1_fan (max scale 25.000(25.000rpm) -> 250 k=100)
+sensor_add 0x20 0 0x78 4 1\
+        poll 5000 \
+        file "/bsp/fan/psu1_fan_input" div=100
+
+#PSU2_fan (max scale 25.000(25.000rpm) -> 250 k=100)
+sensor_add 0x20 0 0x79 4 1\
+        poll 5000 \
+        file "/bsp/fan/psu2_fan_input" div=100
+
+########## Voltage ############
+
+#PSU1 Vin (max scale 255.000(255V) -> 255 k=1000)
+sensor_add 0x20 0 154 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu1_vin" div=1000
+
+#PSU1 Vout (max scale 14.000(14V) -> 255 k=54.9)
+sensor_add 0x20 0 155 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu1_vout" div=165 mult=3
+
+#PSU2 Vin (max 255000(255V) -> 255 k=1000)
+sensor_add 0x20 0 156 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu2_vin" div=1000
+
+#PSU2 Vout max scale 14.000(14V) -> 255 k=54.9)
+sensor_add 0x20 0 157 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu2_vout" div=165 mult=3
+
+#A2D Voltage 
+
+#A2D 1.8V sensor (max scale 270(2.16V) -> 255 k=1.0588)
+sensor_add 0x20 0 158 1 1\
+        poll 5000 \
+        file "/bsp/environment/A2D_1_8v" div=18 mult=17
+
+#A2D 1.2V sensor (max scale 180(1.44V) -> 255 k=0.70588)
+sensor_add 0x20 0 159 1 1\
+        poll 5000 \
+        file "/bsp/environment/A2D_1_2v" div=12 mult=17
+
+#A2D Vcore 0.95v sensor (max scale 143(1.14V) -> 255 k=0.5588)
+sensor_add 0x20 0 160 1 1\
+        poll 5000 \
+        file "/bsp/environment/A2D_vcore" div=9 mult=16
+
+#A2D 12V SWB sensor (max scale 245(14.4V) -> 255 k=0.9617)
+sensor_add 0x20 0 161 1 1\
+        poll 5000 \
+        file "/bsp/environment/A2D_swb_12v" div=26 mult=27
+
+#A2D 3.3V AUX SWB sensor (max scale 247(3.96V) -> 255 k=0.9706)
+sensor_add 0x20 0 162 1 1\
+        poll 5000 \
+        file "/bsp/environment/A2D_swb_3_3v_aux" div=33 mult=34
+
+#A2D 3.3V SEN SWB sensor (max scale 247(3.96V) -> 255 k=0.9706)
+sensor_add 0x20 0 163 1 1\
+        poll 5000 \
+        file "/bsp/environment/A2D_swb_3_3v_sen" div=17 mult=20
+
+
+#ADC Voltage
+#ADC 12V sensor (max scale 904(14.4V) -> 255 k=3.5459)
+sensor_add 0x20 0 164 1 1\
+        poll 5000 \
+        file "/bsp/environment/ADC_12v" div=32 mult=9
+
+#ADC 5V sensor (max scale 913(6V) -> 255 k=3.579)
+sensor_add 0x20 0 165 1 1\
+        poll 5000 \
+        file "/bsp/environment/ADC_5v" div=18 mult=5
+
+#ADC 5V_USB sensor (max scale 913(6V) -> 255 k=3.579)
+sensor_add 0x20 0 166 1 1\
+        poll 5000 \
+        file "/bsp/environment/ADC_5v_usb" div=18 mult=5
+
+#ADC 3.3V_AUX sensor (max scale 901(3.96V) -> 255 k=3.5338)
+sensor_add 0x20 0 167 1 1\
+        poll 5000 \
+        file "/bsp/environment/ADC_3_3v_aux" div=32 mult=9
+
+#ADC 3.3V_BMC sensor (max scale 927(3.96V) -> 255 k=3.6356)
+sensor_add 0x20 0 168 1 1\
+        poll 5000 \
+        file "/bsp/environment/ADC_3_3v_bmc" div=40 mult=11
+
+#ADC 2.5V_DDR sensor (max scale 853(3V) -> 255 k=3.3464)
+sensor_add 0x20 0 169 1 1\
+        poll 5000 \
+        file "/bsp/environment/ADC_2_5v_ddr" div=37 mult=11
+
+#ADC 1.2V_DDR sensor (max scale 819(1.44V) -> 255 k=3.2125)
+sensor_add 0x20 0 170 1 1\
+        poll 5000 \
+        file "/bsp/environment/ADC_1_2v_ddr" div=29 mult=9
+
+#ADC 1.15_VCORE sensor (max scale 785(1.38V) -> 255 k=3.0787)
+sensor_add 0x20 0 171 1 1\
+        poll 5000 \
+        file "/bsp/environment/ADC_1_15v_Vcore" div=34 mult=11
+
+
+#UCD Voltage
+
+#3.3V_SEN sensor (max scale 4000(4V) -> 254 k=15.75)
+sensor_add 0x20 0 172 1 1\
+        poll 5000 \
+        file "/bsp/environment/UCD_3_3v_sen"  div=63 mult=4
+
+#1.2V_SEN sensor (max scale 1800(4V) -> 180 k=10)
+sensor_add 0x20 0 173 1 1\
+        poll 5000 \
+        file "/bsp/environment/UCD_1_2v" div=10
+
+#0.9Vcore sensor (max scale 1200(1.2V) -> 240 k=5)
+sensor_add 0x20 0 174 1 1\
+        poll 5000 \
+        file "/bsp/environment/VcoreUCD" div=5
+
+########## Power ############
+#PSU1 power sensor (max scale 880.000.000(880W) -> 220 k=4000000)
+sensor_add 0x20 0 20 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu1_pin" div=4000000
+
+#PSU1 power sensor (max scale 408.000.000(408W) -> 204 k=2000000)
+sensor_add 0x20 0 21 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu1_pout" div=2000000
+
+#PSU1 power sensor (max scale 880.000.000(880W) -> 220 k=4000000)
+sensor_add 0x20 0 22 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu2_pin" div=4000000
+
+#PSU2 power sensor (max scale 408.000.000(408W) -> 204 k=2000000)
+sensor_add 0x20 0 23 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu2_pout" div=2000000
+
+
+########### Current #########
+#PSU1 Current (max scale 4000(4A) -> 254 k=15.75)
+sensor_add 0x20 0 30 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu1_iin"  div=63 mult=4
+
+#PSU1 Current (max scale 34000(34A) -> 254 k=133.8582)
+sensor_add 0x20 0 31 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu1_iout" div=134
+
+#PSU2 Current (max scale 4000(4A) -> 254 k=15.75)
+sensor_add 0x20 0 32 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu2_iin" div=63 mult=4
+
+#PSU2 Current (max scale 34000(34A) -> 254 k=133.8582)
+sensor_add 0x20 0 33 1 1\
+        poll 5000 \
+        file "/bsp/environment/psu2_iout" div=134
+
+#VcoreUCD_curr(max scale 89000(89A) -> 178 k=2)
+sensor_add 0x20 0 34 1 1\
+        poll 5000 \
+        file "/bsp/environment/VcoreUCD_curr" div=500
+
+#UCD_3_3v_sen_curr(max scale 33000(33A) -> 231 k=129.9212)
+sensor_add 0x20 0 35 1 1\
+        poll 5000 \
+        file "/bsp/environment/UCD_3_3v_sen_curr" div=143
+
+#UCD_1_2v_curr(max scale 27000(27A) -> 216 k=106.2992)
+sensor_add 0x20 0 36 1 1\
+        poll 5000 \
+        file "/bsp/environment/UCD_1_2v_curr" div=125
+
+# CPU status
+sensor_add 0x20 0 40 7 0x6f\
+        poll 1000 \
+        file "/bsp/environment/cpu_status"
+
+#############EEPROM############
+mc_add_fru_data 0x20 0 1024 \
+  file 0 "/bsp/fru/sys_fru_eeprom"
+
+mc_add_fru_data 0x20 1 1024 \
+  file 0 "/bsp/fru/swboard_eeprom"
+
+mc_add_fru_data 0x20 2 1024 \
+  file 0 "/bsp/fru/carier_board_eeprom"
+
+mc_add_fru_data 0x20 3 1024 \
+  file 0 "/bsp/fru/bmc_eeprom"
+
+mc_add_fru_data 0x20 4 256 \
+  file 0 "/bsp/fru/psu1_eeprom"
+
+mc_add_fru_data 0x20 5 256 \
+  file 0 "/bsp/fru/psu2_eeprom"
+
+mc_add_fru_data 0x20 6 4096 \
+  file 0 "/bsp/fru/fan1_eeprom"
+
+mc_add_fru_data 0x20 7 4096 \
+  file 0 "/bsp/fru/fan2_eeprom"
+
+mc_add_fru_data 0x20 8 4096 \
+  file 0 "/bsp/fru/fan3_eeprom"
+
+mc_add_fru_data 0x20 9 4096 \
+  file 0 "/bsp/fru/fan4_eeprom"
+
+# Turn on the BMC
+mc_enable 0x20
diff --git a/lanserv/mellanox/mellanox.lan.conf b/lanserv/mellanox/mellanox.lan.conf
new file mode 100644
index 0000000..4099062
--- /dev/null
+++ b/lanserv/mellanox/mellanox.lan.conf
@@ -0,0 +1,77 @@
+########################################################################
+# Copyright (c) 2017 Mellanox Technologies.
+# Copyright (c) 2017 Nataliya Yakuts <nataliyay@mellanox.com>
+#
+# Licensed under the GNU General Public License Version 2
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+
+# mellanox.lan.conf
+# A configuration file for lanserv to configure the various
+# communication parameters for the device.
+
+# This is a name used to identify this instance, and used to create
+# the default name of the emulator startup command file and eventually
+# the storage facility for permanent storage.
+name "mellanox"
+
+#
+# Work on the BMC first
+set_working_mc 0x20
+
+  # Define a LAN channel on channel 1
+  startlan 1
+    # Define an IP address and port to listen on.  You can define more
+    # than one address/port to listen on multiple addresses.  The ::
+    # listens on all addresses.
+    addr 0.0.0.0 623
+
+    # Maximum privilege limit on the channel.
+    priv_limit admin
+
+    # Allowed IPMI 1.5 authorization types
+    #allowed_auths_callback none md2 md5 straight
+    #allowed_auths_user none md2 md5 straight
+    #allowed_auths_operator none md2 md5 straight
+    #allowed_auths_admin none md2 md5 straight
+
+    # guid for IPMI 2.0 authorization  You can also use a string
+    guid "guidforauthorization"
+
+    # You can specify a BMC key for IPMI 2.0 authorization.  See the
+    # spec for details.
+    #bmc_key "abcdefghijklmnopqrst"
+
+    # A program to get and set the LAN configuration of the interface.
+    lan_config_program "/etc/ipmi/lancontrol eth0"
+  endlan
+
+  #chassis_control "./ipmi_sim_chassiscontrol 0x20"
+
+  #sol "telnet:0.0.0.0:9012" 115200
+
+  # Start startcmd at startup?  Default is false.
+  startnow false
+
+  # Now add some users.  User 0 is invalid, user 1 is the special "anonymous"
+  # user and cannot take a username.  Note that the users here are only
+  # used if the persistent user config doesn't exist.
+  #    # valid name      passw  priv-lim max-sess allowed-auths
+  user 1 true  ""        "test" user     10       none md2 md5 straight
+  user 2 true  "ADMIN" "ADMIN" admin    10       md2 md5 straight
+
+  sol "/dev/ttyS0" 115200 nortscts history=65530 historyfru=10
+
+  serial bt localhost 9012 codec BT_Mode
+
+# Dynamically load a module to extend the simulator.  After the module is
+# loaded, if the function "ipmi_sim_module_init" is defined in the module,
+# it will be called with the following parameters:
+#  int ipmi_sim_module_init(sys_data_t *sys, char *initstr);
+# where initstr is the init string passed on the module load line.
+# It should return 0 on success or an errno no failure.
+loadlib "/usr/lib/mlx_ipmid/mellanox.so" ""
diff --git a/lanserv/mellanox/mellanox.sdrs b/lanserv/mellanox/mellanox.sdrs
new file mode 100755
index 0000000..e9df672
--- /dev/null
+++ b/lanserv/mellanox/mellanox.sdrs
@@ -0,0 +1,2324 @@
+########################################################################
+# Copyright (c) 2017 Mellanox Technologies.
+# Copyright (c) 2017 Nataliya Yakuts <nataliyay@mellanox.com>
+#
+# Licensed under the GNU General Public License Version 2
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+
+#ambient board temp sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           1
+        entity_id               connectivity_switch
+        entity_instance         1
+        sensor_type             Temperature
+        event_reading_type_code 1
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_lnc              true
+        return_lc               true
+        return_unc              true
+        return_uc               true
+        deassert_lncgl          true
+        deassert_uncgh          true
+        deassert_lcgl           true
+        deassert_ucgh           true
+        assert_lncgl            true
+        assert_uncgh            true
+        assert_lcgl             true
+        assert_ucgh             true
+        lnc_thrsh_settable      true
+        unc_thrsh_settable      true
+        lc_thrsh_settable       true
+        uc_thrsh_settable       true
+        lnc_thrsh_readable      true
+        unc_thrsh_readable      true
+        lc_thrsh_readable       true
+        uc_thrsh_readable       true
+        base_unit               degrees_C
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        nominal_specified       true
+        nominal_reading         153
+        sensor_maximum          248
+        sensor_minimum          78
+        m                       1
+        b                       -128
+        r_exp                   0
+        b_exp                   0
+        lc_fthresh              -22
+        lnc_fthresh             1
+        unc_fthresh             60
+        uc_fthresh              82
+        positive_hysteresis     1
+        negative_hysteresis     1
+        id_string               "ambient carrier temp"
+endsdr
+
+#Ambient switch temp sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           2
+        entity_id               connectivity_switch
+        entity_instance         1
+        sensor_type             Temperature
+        event_reading_type_code 1
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_lnc              true
+        return_lc               true
+        return_unc              true
+        return_uc               true
+        deassert_lncgl          true
+        deassert_uncgh          true
+        deassert_lcgl           true
+        deassert_ucgh           true
+        assert_lncgl            true
+        assert_uncgh            true
+        assert_lcgl             true
+        assert_ucgh             true
+        lnc_thrsh_settable      true
+        unc_thrsh_settable      true
+        lc_thrsh_settable       true
+        uc_thrsh_settable       true
+        lnc_thrsh_readable      true
+        unc_thrsh_readable      true
+        lc_thrsh_readable       true
+        uc_thrsh_readable       true
+        base_unit               degrees_C
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        nominal_specified       true
+        nominal_reading         153
+        sensor_maximum          248
+        sensor_minimum          78
+        m                       1
+        b                       -128
+        r_exp                   0
+        b_exp                   0
+        lc_fthresh              -22
+        lnc_fthresh             1
+        unc_fthresh             60
+        uc_fthresh              82
+        positive_hysteresis     1
+        negative_hysteresis     1
+        id_string               "ambient switch temp"
+endsdr
+
+#PSU1 temp sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           3
+        entity_id               connectivity_switch
+        entity_instance         1
+        sensor_type             Temperature
+        event_reading_type_code 1
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_lnc              true
+        return_lc               true
+        return_unc              true
+        return_uc               true
+        deassert_lncgl          true
+        deassert_uncgh          true
+        deassert_lcgl           true
+        deassert_ucgh           true
+        assert_lncgl            true
+        assert_uncgh            true
+        assert_lcgl             true
+        assert_ucgh             true
+        lnc_thrsh_settable      true
+        unc_thrsh_settable      true
+        lc_thrsh_settable       true
+        uc_thrsh_settable       true
+        lnc_thrsh_readable      true
+        unc_thrsh_readable      true
+        lc_thrsh_readable       true
+        uc_thrsh_readable       true
+        base_unit               degrees_C
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        nominal_specified       true
+        nominal_reading         153
+        sensor_maximum          248
+        sensor_minimum          78
+        m                       1
+        b                       -128
+        r_exp                   0
+        b_exp                   0
+        lc_fthresh              -22
+        lnc_fthresh             1
+        unc_fthresh             60
+        uc_fthresh              82
+        positive_hysteresis     1
+        negative_hysteresis     1
+        id_string               "PSU1 temp"
+endsdr
+
+#PSU2 temp sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           4
+        entity_id               connectivity_switch
+        entity_instance         1
+        sensor_type             Temperature
+        event_reading_type_code 1
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_lnc              true
+        return_lc               true
+        return_unc              true
+        return_uc               true
+        deassert_lncgl          true
+        deassert_uncgh          true
+        deassert_lcgl           true
+        deassert_ucgh           true
+        assert_lncgl            true
+        assert_uncgh            true
+        assert_lcgl             true
+        assert_ucgh             true
+        lnc_thrsh_settable      true
+        unc_thrsh_settable      true
+        lc_thrsh_settable       true
+        uc_thrsh_settable       true
+        lnc_thrsh_readable      true
+        unc_thrsh_readable      true
+        lc_thrsh_readable       true
+        uc_thrsh_readable       true
+        base_unit               degrees_C
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        nominal_specified       true
+        nominal_reading         153
+        sensor_maximum          248
+        sensor_minimum          78
+        m                       1
+        b                       -128
+        r_exp                   0
+        b_exp                   0
+        lc_fthresh              -22
+        lnc_fthresh             1
+        unc_fthresh             60
+        uc_fthresh              82
+        positive_hysteresis     1
+        negative_hysteresis     1
+        id_string               "PSU2 temp"
+endsdr
+
+#asic temp sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           5
+        entity_id               connectivity_switch
+        entity_instance         1
+        sensor_type             Temperature
+        event_reading_type_code 1
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_lnc              true
+        return_lc               true
+        return_unc              true
+        return_uc               true
+        deassert_lncgl          true
+        deassert_uncgh          true
+        deassert_lcgl           true
+        deassert_ucgh           true
+        assert_lncgl            true
+        assert_uncgh            true
+        assert_lcgl             true
+        assert_ucgh             true
+        lnc_thrsh_settable      true
+        unc_thrsh_settable      true
+        lc_thrsh_settable       true
+        uc_thrsh_settable       true
+        lnc_thrsh_readable      true
+        unc_thrsh_readable      true
+        lc_thrsh_readable       true
+        uc_thrsh_readable       true
+        base_unit               degrees_C
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        nominal_specified       true
+        nominal_reading         153
+        sensor_maximum          248
+        sensor_minimum          78
+        m                       1
+        b                       -128
+        r_exp                   0
+        b_exp                   0
+        lc_fthresh              -22
+        lnc_fthresh             1
+        unc_fthresh             60
+        uc_fthresh              82
+        positive_hysteresis     1
+        negative_hysteresis     1
+        id_string               "asic temp"
+endsdr
+
+# PSU1 voltage sensor 1
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            154
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        sensor_auto_rearm        true
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        100
+        b                        0
+        r_exp                    -2
+        b_exp                    0
+        nominal_specified        true
+        nominal_reading          230
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               250
+        lc_fthresh               170
+        positive_hysteresis      2
+        negative_hysteresis      2
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "PSU1 vin"
+endsdr
+
+# PSU1 voltage sensor 2
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            155
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        56
+        b                        0
+        r_exp                    -3
+        b_exp                    0
+        nominal_specified        true
+        nominal_reading          12
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               13.2
+        lc_fthresh               10.8
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "PSU1 vout"
+endsdr
+
+# PSU2 voltage sensor 1
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            156
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        sensor_auto_rearm        true
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        100
+        b                        0
+        r_exp                    -2
+        b_exp                    0
+        nominal_specified        true
+        nominal_reading          230
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               250
+        lc_fthresh               170
+        positive_hysteresis      2
+        negative_hysteresis      2
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "PSU2 vin"
+endsdr
+
+# PSU2 voltage sensor 2
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            157
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        56
+        b                        0
+        r_exp                    -3
+        b_exp                    0
+        nominal_specified        true
+        nominal_reading          12
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               13.2
+        lc_fthresh               10.8
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "PSU2 vout"
+endsdr
+
+# A2D voltage sensors
+#1.8V
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            158
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        85
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         1.8
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               1.98
+        lc_fthresh               1.71
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "A2D 1.8v"
+endsdr
+
+#1.2V
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            159
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        56
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         1.2
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               1.32
+        lc_fthresh               1.08
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "A2D 1.2v"
+endsdr
+
+#VCORE
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            160
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        447
+        b                        0
+        r_exp                    -5
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         0.95
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               0.9975
+        lc_fthresh               0.9025
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "A2D Vcore"
+endsdr
+
+#12V SWB
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            161
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        56
+        b                        0
+        r_exp                    -3
+        b_exp                    0
+        nominal_specified        true
+        nominal_reading          12
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               12.6
+        lc_fthresh               11.4
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "SWB 12v"
+endsdr
+
+#3.3_AUX SWB
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            162
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        156
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         3.3
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               3.465
+        lc_fthresh               3.135
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "SWB 3.3v_aux"
+endsdr
+
+#3.3_SEN SWB
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            163
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        156
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         3.3
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               3.465
+        lc_fthresh               3.135
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "SWB 3.3v_sen"
+endsdr
+
+# ADC voltage sensors
+#12V
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            164
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        56
+        b                        0
+        r_exp                    -3
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         12.0
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               12.6
+        lc_fthresh               11.4
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "ADC 12v"
+endsdr
+
+#5V
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            165
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        235
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         5.0
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               5.25
+        lc_fthresh               4.75
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "ADC 5v"
+endsdr
+
+#5V USB
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            166
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        235
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_reading          5
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               5.25
+        lc_fthresh               4.75
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "ADC 5v usb"
+endsdr
+
+#3.3V_AUX
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            167
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        156
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         3.3
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               3.465
+        lc_fthresh               3.135
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "ADC 3.3v_aux"
+endsdr
+
+#3.3V_BMC
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            168
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        155
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         3.3
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               3.465
+        lc_fthresh               3.135
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "ADC 3.3v_bmc"
+endsdr
+
+#2.5V_DDR
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            169
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        118
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         2.5
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               2.625
+        lc_fthresh               2.375
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned       
+        linearization            linear
+        sensor_direction         input
+        id_string                "ADC 2.5v_ddr"
+endsdr
+
+#1.2_DDR
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            170
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        56
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         1.2
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               1.26
+        lc_fthresh               1.14
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "ADC 1.2v_ddr"
+endsdr
+
+#1.15_VCORE
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            171
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        56
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         1.15
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               1.2075
+        lc_fthresh               1.0925
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "ADC 1.15v_Vcore"
+endsdr
+
+
+# UCD voltage sensors
+#3.3V_SEN
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            172
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        156
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         3.3
+        sensor_maximum           255
+        sensor_minimum           0
+        uc_fthresh               3.63
+        lc_fthresh               2.97
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "UCD 3.3v_sen"
+endsdr
+
+#1.2V_UCD
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            173
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        100
+        b                        0
+        r_exp                    -4
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         1.2
+        sensor_maximum           180
+        sensor_minimum           0
+        uc_fthresh               1.32
+        lc_fthresh               1.08
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "UCD 1.2v"
+endsdr
+
+#VcoreUCD
+sdr type 1
+        sensor_owner_id          0x20
+        sensor_owner_lun         0
+        channel_number           0
+        sensor_number            174
+        entity_id                power_supply
+        entity_instance          1
+        sensor_type              Voltage
+        event_reading_type_code  1
+        sensor_event_msg_ctrl    per_state
+        sensor_threshold_access  settable
+        return_lc                true
+        return_uc                true
+        deassert_lcgl            true
+        assert_lcgl              true
+        assert_ucgh              true
+        deassert_ucgh            true
+        lc_thrsh_settable        true
+        uc_thrsh_settable        true
+        lc_thrsh_readable        true
+        uc_thrsh_readable        true
+        base_unit                Volts
+        accuracy                 1
+        accuracy_exp             0
+        m                        500
+        b                        0
+        r_exp                    -5
+        b_exp                    0
+        nominal_specified        true
+        nominal_freading         0.9
+        sensor_maximum           240
+        sensor_minimum           0
+        uc_fthresh               0.99
+        lc_fthresh               0.81
+        positive_hysteresis      2
+        negative_hysteresis      2
+        init_scanning            true
+        init_events              true
+        init_thresholds          true
+        init_hysteresis          true
+        init_sensor_type         true
+        sensor_auto_rearm        true
+        default_event_gen_on     true
+        default_sensor_scan_on   true
+        analog_data_format       unsigned
+        linearization            linear
+        sensor_direction         input
+        id_string                "UCD Vcore"
+endsdr
+
+#################################################
+# PSU1_pin power sensor (/sys/bus/i2c/devices/10-0059/hwmon/hwmon4/power1_input)
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           20
+        entity_id               power_supply
+        entity_instance         1
+        sensor_type             Power_Supply
+        event_reading_type_code 1
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_uc               true
+        assert_ucgh             true
+        deassert_ucgh           true
+        uc_thrsh_settable       true
+        uc_thrsh_readable       true
+        base_unit               Watts
+        accuracy                1
+        accuracy_exp            0
+        m                       400
+        b                       0
+        r_exp                   -2
+        b_exp                   0
+        nominal_specified       true
+        nominal_freading        500
+        sensor_maximum          220
+        sensor_minimum          0
+        uc_fthresh              750
+        positive_hysteresis     2
+        negative_hysteresis     2
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        sensor_auto_rearm       true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        id_string               "PSU1_pin"
+endsdr
+
+# PSU1_pout power sensor (/sys/bus/i2c/devices/10-0059/hwmon/hwmon4/power2_input)
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           21
+        entity_id               power_supply
+        entity_instance         1
+        sensor_type             Power_Supply
+        event_reading_type_code 1
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_uc               true
+        assert_ucgh             true
+        deassert_ucgh           true
+        uc_thrsh_settable       true
+        uc_thrsh_readable       true
+        base_unit               Watts
+        accuracy                1
+        accuracy_exp            0
+        m                       200
+        b                       0
+        r_exp                   -2
+        b_exp                   0
+        nominal_specified       true
+        nominal_freading        100
+        sensor_maximum          204
+        sensor_minimum          0
+        uc_fthresh              380
+        positive_hysteresis     2
+        negative_hysteresis     2
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        sensor_auto_rearm       true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        id_string               "PSU1_pout"
+endsdr
+
+# PSU2_pin power sensor (/sys/bus/i2c/devices/10-0058/hwmon/hwmon5/power1_input)
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           22
+        entity_id               power_supply
+        entity_instance         1
+        sensor_type             Power_Supply
+        event_reading_type_code 1
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_uc               true
+        assert_ucgh             true
+        deassert_ucgh           true
+        uc_thrsh_settable       true
+        uc_thrsh_readable       true
+        base_unit               Watts
+        accuracy                1
+        accuracy_exp            0
+        m                       400
+        b                       0
+        r_exp                   -2
+        b_exp                   0
+        nominal_specified       true
+        nominal_freading        500
+        sensor_maximum          220
+        sensor_minimum          0
+        uc_fthresh              750
+        positive_hysteresis     2
+        negative_hysteresis     2
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        sensor_auto_rearm       true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        id_string               "PSU2_pin"
+endsdr
+
+# PSU2_pout power sensor (/sys/bus/i2c/devices/10-0058/hwmon/hwmon5/power2_input)
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           23
+        entity_id               power_supply
+        entity_instance         1
+        sensor_type             Power_Supply
+        event_reading_type_code 1
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_uc               true
+        assert_ucgh             true
+        deassert_ucgh           true
+        uc_thrsh_settable       true
+        uc_thrsh_readable       true
+        base_unit               Watts
+        accuracy                1
+        accuracy_exp            0
+        m                       200
+        b                       0
+        r_exp                   -2
+        b_exp                   0
+        nominal_specified       true
+        nominal_freading        100
+        sensor_maximum          204
+        sensor_minimum          0
+        uc_fthresh              380
+        positive_hysteresis     2
+        negative_hysteresis     2
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        sensor_auto_rearm       true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        id_string               "PSU2_pout"
+endsdr
+
+# PSU1-in current sensor (/sys/bus/i2c/devices/10-0059/hwmon/hwmon4/current1_input)
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           30
+        entity_id               power_supply
+        entity_instance         1
+        sensor_type             Current
+        event_reading_type_code 1
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_uc               true
+        assert_ucgh             true
+        deassert_ucgh           true
+        uc_thrsh_settable       true
+        uc_thrsh_readable       true
+        base_unit               Amps
+        accuracy                1
+        accuracy_exp            0
+        m                       157
+        b                       0
+        r_exp                   -4
+        b_exp                   0
+        nominal_specified       true
+        nominal_freading        1.5
+        sensor_maximum          254
+        sensor_minimum          0
+        uc_fthresh              3
+        positive_hysteresis     2
+        negative_hysteresis     2
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        sensor_auto_rearm       true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        id_string               "PSU1_iin"
+endsdr
+
+# PSU1_out vcurrent sensor (/sys/bus/i2c/devices/10-0059/hwmon/hwmon4/current2_input)
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           31
+        entity_id               power_supply
+        entity_instance         1
+        sensor_type             Current
+        event_reading_type_code 1
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_uc               true
+        assert_ucgh             true
+        deassert_ucgh           true
+        uc_thrsh_settable       true
+        uc_thrsh_readable       true
+        base_unit               Amps
+        accuracy                1
+        accuracy_exp            0
+        m                       134
+        b                       0
+        r_exp                   -3
+        b_exp                   0
+        nominal_specified       true
+        nominal_freading        10
+        sensor_maximum          254
+        sensor_minimum          0
+        uc_fthresh              32
+        positive_hysteresis     2
+        negative_hysteresis     2
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        sensor_auto_rearm       true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        id_string               "PSU1_iout"
+endsdr
+
+# PSU2_in current sensor (/sys/bus/i2c/devices/10-0058/hwmon/hwmon5/current1_input)
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           32
+        entity_id               power_supply
+        entity_instance         1
+        sensor_type             Current
+        event_reading_type_code 1
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_uc               true
+        assert_ucgh             true
+        deassert_ucgh           true
+        uc_thrsh_settable       true
+        uc_thrsh_readable       true
+        base_unit               Amps
+        accuracy                1
+        accuracy_exp            0
+        m                       157
+        b                       0
+        r_exp                   -4
+        b_exp                   0
+        nominal_specified       true
+        nominal_freading        1.5
+        sensor_maximum          254
+        sensor_minimum          0
+        uc_fthresh              3
+        positive_hysteresis     2
+        negative_hysteresis     2
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        sensor_auto_rearm       true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        id_string               "PSU2_iin"
+endsdr
+
+# PSU2_out current sensor (/sys/bus/i2c/devices/10-0058/hwmon/hwmon5/current2_input)
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           33
+        entity_id               power_supply
+        entity_instance         1
+        sensor_type             Current
+        event_reading_type_code 1
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_uc               true
+        assert_ucgh             true
+        deassert_ucgh           true
+        uc_thrsh_settable       true
+        uc_thrsh_readable       true
+        base_unit               Amps
+        accuracy                1
+        accuracy_exp            0
+        m                       134
+        b                       0
+        r_exp                   -3
+        b_exp                   0
+        nominal_specified       true
+        nominal_freading        10
+        sensor_maximum          254
+        sensor_minimum          0
+        uc_fthresh              32
+        positive_hysteresis     2
+        negative_hysteresis     2
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        sensor_auto_rearm       true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        id_string               "PSU2_iout"
+endsdr
+
+# VcoreUCD_curr current sensor (/sys/bus/i2c/devices/10-0041/hwmon/hwmon*/curr2_input)
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           34
+        entity_id               power_supply
+        entity_instance         1
+        sensor_type             Current
+        event_reading_type_code 1
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_uc               true
+        assert_ucgh             true
+        deassert_ucgh           true
+        uc_thrsh_settable       true
+        uc_thrsh_readable       true
+        base_unit               Amps
+        accuracy                1
+        accuracy_exp            0
+        m                       500
+        b                       0
+        r_exp                   -3
+        b_exp                   0
+        nominal_specified       true
+        #nominal_freading        10
+        sensor_maximum          178
+        sensor_minimum          0
+        uc_fthresh              87
+        positive_hysteresis     2
+        negative_hysteresis     2
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        sensor_auto_rearm       true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        id_string               "VcoreUCD_curr"
+endsdr
+
+# UCD_3_3v_sen_curr current sensor (/sys/bus/i2c/devices/10-0027/hwmon/hwmon*/curr2_input)
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           35
+        entity_id               power_supply
+        entity_instance         1
+        sensor_type             Current
+        event_reading_type_code 1
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_uc               true
+        assert_ucgh             true
+        deassert_ucgh           true
+        uc_thrsh_settable       true
+        uc_thrsh_readable       true
+        base_unit               Amps
+        accuracy                1
+        accuracy_exp            0
+        m                       142
+        b                       0
+        r_exp                   -3
+        b_exp                   0
+        nominal_specified       true
+        #nominal_freading        10
+        sensor_maximum          231
+        sensor_minimum          0
+        uc_fthresh              31
+        positive_hysteresis     2
+        negative_hysteresis     2
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        sensor_auto_rearm       true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        id_string               "UCD_3_3v_sen_curr"
+endsdr
+
+#UCD_1_2v_curr current sensor (/sys/bus/i2c/devices/10-0027/hwmon/hwmon*/curr3_input)
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           36
+        entity_id               power_supply
+        entity_instance         1
+        sensor_type             Current
+        event_reading_type_code 1
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        return_uc               true
+        assert_ucgh             true
+        deassert_ucgh           true
+        uc_thrsh_settable       true
+        uc_thrsh_readable       true
+        base_unit               Amps
+        accuracy                1
+        accuracy_exp            0
+        m                       125
+        b                       0
+        r_exp                   -3
+        b_exp                   0
+        nominal_specified       true
+        #nominal_freading        10
+        sensor_maximum          216
+        sensor_minimum          0
+        uc_fthresh              25
+        positive_hysteresis     2
+        negative_hysteresis     2
+        init_scanning           true
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_sensor_type        true
+        sensor_auto_rearm       true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        analog_data_format      unsigned
+        linearization           linear
+        sensor_direction        input
+        id_string               "UCD_1_2v_curr"
+endsdr
+
+#############################################################
+
+#fan1_1 sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           0x70
+        entity_id               fan_cooling_device
+        entity_instance         1
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_scanning           true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable       
+        event_reading_type_code 1
+        sensor_type             Fan
+        return_lc               true
+        deassert_lcgl           true
+        assert_lcgl             true
+        lc_thrsh_readable       true
+        base_unit               RPM
+        r_exp                   0
+        b_exp                   0
+        b                       0
+        m                       100
+        nominal_specified       true
+        nominal_freading        10000
+        accuracy                1
+        accuracy_exp            0
+        sensor_maximum          250
+        sensor_minimum          0
+        lc_fthresh              500
+        positive_hysteresis     2
+        negative_hysteresis     2
+        id_string               "fan1_1"
+endsdr
+
+
+
+#fan1_2 sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           0x71
+        entity_id              fan_cooling_device
+        entity_instance         1
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_scanning           true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        event_reading_type_code 1
+        sensor_type             Fan
+        return_lc               true
+        deassert_lcgl           true
+        assert_lcgl             true
+        lc_thrsh_readable       true
+        base_unit               RPM
+        r_exp                   0
+        b_exp                   0
+        b                       0
+        m                       100
+        nominal_specified       true
+        nominal_freading        10000
+        accuracy                1
+        accuracy_exp            0
+        sensor_maximum          250
+        sensor_minimum          0
+        lc_fthresh              500
+        positive_hysteresis     2
+        negative_hysteresis     2
+        id_string               "fan1_2"
+endsdr
+
+#fan2_1 sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           0x72
+        entity_id               fan_cooling_device
+        entity_instance         1
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_scanning           true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        event_reading_type_code 1
+        sensor_type             Fan
+        return_lc               true
+        deassert_lcgl           true
+        assert_lcgl             true
+        lc_thrsh_readable       true
+        base_unit               RPM
+        r_exp                   0
+        b_exp                   0
+        b                       0
+        m                       100
+        nominal_specified       true
+        nominal_freading        10000
+        accuracy                1
+        accuracy_exp            0
+        sensor_maximum          250
+        sensor_minimum          0
+        lc_fthresh              500
+        positive_hysteresis     2
+        negative_hysteresis     2
+        id_string               "fan2_1"
+endsdr
+
+#fan2_2 sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           0x73
+        entity_id               fan_cooling_device
+        entity_instance         1
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_scanning           true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        event_reading_type_code 1
+        sensor_type             Fan
+        return_lc               true
+        deassert_lcgl           true
+        assert_lcgl             true
+        lc_thrsh_readable       true
+        base_unit               RPM
+        r_exp                   0
+        b_exp                   0
+        b                       0
+        m                       100
+        nominal_specified       true
+        nominal_freading        10000
+        accuracy                1
+        accuracy_exp            0
+        sensor_maximum          250
+        sensor_minimum          0
+        lc_fthresh              500
+        positive_hysteresis     2
+        negative_hysteresis     2
+        id_string               "fan2_2"
+endsdr
+
+#fan3_1 sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           0x74
+        entity_id               fan_cooling_device
+        entity_instance         1
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_scanning           true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        event_reading_type_code 1
+        sensor_type             Fan
+        return_lc               true
+        deassert_lcgl           true
+        assert_lcgl             true
+        lc_thrsh_readable       true
+        base_unit               RPM
+        r_exp                   0
+        b_exp                   0
+        b                       0
+        m                       100
+        nominal_specified       true
+        nominal_freading        10000
+        accuracy                1
+        accuracy_exp            0
+        sensor_maximum          250
+        sensor_minimum          0
+        lc_fthresh              500
+        positive_hysteresis     2
+        negative_hysteresis     2
+        id_string               "fan3_1"
+endsdr
+
+#fan3_2 sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           0x75
+        entity_id               fan_cooling_device
+        entity_instance         1
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_scanning           true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        event_reading_type_code 1
+        sensor_type             Fan
+        return_lc               true
+        deassert_lcgl           true
+        assert_lcgl             true
+        lc_thrsh_readable       true
+        base_unit               RPM
+        r_exp                   0
+        b_exp                   0
+        b                       0
+        m                       100
+        nominal_specified       true
+        nominal_freading        10000
+        accuracy                1
+        accuracy_exp            0
+        sensor_maximum          250
+        sensor_minimum          0
+        lc_fthresh              500
+        positive_hysteresis     2
+        negative_hysteresis     2
+        id_string               "fan3_2"
+endsdr
+
+#fan4_1 sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           0x76
+        entity_id               fan_cooling_device
+        entity_instance         1
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_scanning           true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        event_reading_type_code 1
+        sensor_type             Fan
+        return_lc               true
+        deassert_lcgl           true
+        assert_lcgl             true
+        lc_thrsh_readable       true
+        base_unit               RPM
+        r_exp                   0
+        b_exp                   0
+        b                       0
+        m                       100
+        nominal_specified       true
+        nominal_freading        10000
+        accuracy                1
+        accuracy_exp            0
+        sensor_maximum          250
+        sensor_minimum          0
+        lc_fthresh              500
+        positive_hysteresis     2
+        negative_hysteresis     2
+        id_string               "fan4_1"
+endsdr
+
+#fan4_2 sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           0x77
+        entity_id               fan_cooling_device
+        entity_instance         1
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_scanning           true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        event_reading_type_code 1
+        sensor_type             Fan
+        return_lc               true
+        deassert_lcgl           true
+        assert_lcgl             true
+        lc_thrsh_readable       true
+        base_unit               RPM
+        r_exp                   0
+        b_exp                   0
+        b                       0
+        m                       100
+        nominal_specified       true
+        nominal_freading        10000
+        accuracy                1
+        accuracy_exp            0
+        sensor_maximum          250
+        sensor_minimum          0
+        lc_fthresh              500
+        positive_hysteresis     2
+        negative_hysteresis     2
+        id_string               "fan4_2"
+endsdr
+
+#fan4_2 sensor
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           0x78
+        entity_id               fan_cooling_device
+        entity_instance         1
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_scanning           true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        event_reading_type_code 1
+        sensor_type             Fan
+        return_lc               true
+        deassert_lcgl           true
+        assert_lcgl             true
+        lc_thrsh_readable       true
+        base_unit               RPM
+        r_exp                   0
+        b_exp                   0
+        b                       0
+        m                       100
+        nominal_specified       true
+        nominal_freading        10000
+        accuracy                1
+        accuracy_exp            0
+        sensor_maximum          250
+        sensor_minimum          0
+        lc_fthresh              500
+        positive_hysteresis     2
+        negative_hysteresis     2
+        id_string               "PSU1_fan"
+endsdr
+
+#PSU2 FAN
+sdr type 1
+        sensor_owner_id         0x20
+        sensor_owner_lun        0
+        channel_number          0
+        sensor_number           0x79
+        entity_id               fan_cooling_device
+        entity_instance         1
+        init_events             true
+        init_thresholds         true
+        init_hysteresis         true
+        init_scanning           true
+        init_sensor_type        true
+        default_event_gen_on    true
+        default_sensor_scan_on  true
+        sensor_auto_rearm       true
+        sensor_event_msg_ctrl   per_state
+        sensor_threshold_access settable
+        event_reading_type_code 1
+        sensor_type             Fan
+        return_lc               true
+        deassert_lcgl           true
+        assert_lcgl             true
+        lc_thrsh_readable       true
+        base_unit               RPM
+        r_exp                   0
+        b_exp                   0
+        b                       0
+        m                       100
+        nominal_specified       true
+        nominal_freading        10000
+        accuracy                1
+        accuracy_exp            0
+        sensor_maximum          250
+        sensor_minimum          0
+        lc_fthresh              500
+        positive_hysteresis     2
+        negative_hysteresis     2
+        id_string               "PSU2_fan"
+endsdr
+
+#############PROCESSOR############
+# Board CPU status sensor
+sdr type 2
+	sensor_owner_id		0x20
+	sensor_owner_lun	0
+	channel_number		1
+	sensor_number		40
+	entity_id		processor
+	entity_instance		0x20
+	init_scanning		true
+	init_events		true
+	init_sensor_type	true
+	default_event_gen_on	true
+	default_sensor_scan_on	true
+	sensor_auto_rearm	false
+	sensor_type		Processor
+	event_reading_type_code 0x6f
+	assert_event0		true
+	deassert_event0		true
+	event0_state_ret	true
+	id_string		"CPU Status"
+endsdr
\ No newline at end of file
diff --git a/lanserv/mellanox/mlx-hw-events.sh b/lanserv/mellanox/mlx-hw-events.sh
new file mode 100755
index 0000000..da938a7
--- /dev/null
+++ b/lanserv/mellanox/mlx-hw-events.sh
@@ -0,0 +1,525 @@
+#!/bin/bash
+
+########################################################################
+# Copyright (c) 2017 Mellanox Technologies.
+# Copyright (c) 2017 Nataliya Yakuts <nataliyay@mellanox.com>
+#
+# Licensed under the GNU General Public License Version 2
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+
+if [ "$1" == "add" ]; then
+  if [ "$2" == "amb_carrier" ] || [ "$2" == "amb_switch" ]; then
+    mkdir -p /bsp/thermal/
+    ln -sf $3$4/temp1_input /bsp/thermal/$2_temp
+    ln -sf $3$4/temp1_max /bsp/thermal/$2_temp_max
+    ln -sf $3$4/temp1_max_hyst /bsp/thermal/$2_temp_hyst
+  fi
+  if [ "$2" == "psu1" ] || [ "$2" == "psu2" ]; then
+    mkdir -p /bsp/thermal/
+    mkdir -p /bsp/environment/
+    mkdir -p /bsp/fan/
+    ln -sf $3$4/temp1_input /bsp/thermal/$2_temp
+    ln -sf $3$4/temp1_max /bsp/thermal/$2_temp_max
+    ln -sf $3$4/temp1_max_alarm /bsp/thermal/$2_temp_alarm
+    ln -sf $3$4/in1_input /bsp/environment/$2_vin
+    ln -sf $3$4/in2_input /bsp/environment/$2_vout
+    ln -sf $3$4/power1_input /bsp/environment/$2_pin
+    ln -sf $3$4/power2_input /bsp/environment/$2_pout
+    ln -sf $3$4/curr1_input /bsp/environment/$2_iin
+    ln -sf $3$4/curr2_input /bsp/environment/$2_iout
+    ln -sf $3$4/fan1_input /bsp/fan/$2_fan_input
+
+    #FAN speed set
+    if [ "$2" == "psu1" ]; then
+      i2cset -f -y 3 0x58 0x3b 0x3c wp
+    else
+      i2cset -f -y 3 0x59 0x3b 0x3c wp
+    fi
+  fi
+  if [ "$2" == "A2D" ]; then
+    mkdir -p /bsp/environment/
+    ln -sf $3$4/in_voltage-voltage_scale /bsp/environment/$2_voltage_scale
+    ln -sf $3$4/in_voltage6_raw /bsp/environment/$2_1_8v
+    ln -sf $3$4/in_voltage5_raw /bsp/environment/$2_1_2v
+    ln -sf $3$4/in_voltage4_raw /bsp/environment/$2_vcore
+    ln -sf $3$4/in_voltage3_raw /bsp/environment/$2_swb_12v
+    ln -sf $3$4/in_voltage2_raw /bsp/environment/$2_swb_3_3v_aux
+    ln -sf $3$4/in_voltage1_raw /bsp/environment/$2_swb_3_3v_sen
+  fi
+  if [ "$2" == "ADC" ]; then
+    mkdir -p /bsp/environment/
+    ln -sf $3$4/adc0_value /bsp/environment/$2_12v
+    ln -sf $3$4/adc2_value /bsp/environment/$2_5v
+    ln -sf $3$4/adc3_value /bsp/environment/$2_5v_usb
+    ln -sf $3$4/adc4_value /bsp/environment/$2_3_3v_aux
+    ln -sf $3$4/adc10_value /bsp/environment/$2_3_3v_bmc
+    ln -sf $3$4/adc11_value /bsp/environment/$2_2_5v_ddr
+    ln -sf $3$4/adc12_value /bsp/environment/$2_1_2v_ddr
+    ln -sf $3$4/adc13_value /bsp/environment/$2_1_15v_Vcore
+  fi
+  if [ "$2" == "UCD" ]; then
+    mkdir -p /bsp/environment/
+    ln -sf $3$4/in2_input /bsp/environment/$2_3_3v_sen
+    ln -sf $3$4/in3_input /bsp/environment/$2_1_2v
+    ln -sf $3$4/curr2_input /bsp/environment/$2_3_3v_sen_curr
+    ln -sf $3$4/curr3_input /bsp/environment/$2_1_2v_curr
+  fi
+  if [ "$2" == "VcoreUCD" ]; then
+    mkdir -p /bsp/environment/
+    ln -sf $3$4/in2_input /bsp/environment/$2
+    ln -sf $3$4/curr2_input /bsp/environment/$2_curr
+  fi
+  if [ "$2" == "asic" ]; then
+    mkdir -p /bsp/thermal/
+    ln -sf $3$4/temp1_input /bsp/thermal/$2_temp
+    ln -sf $3$4/temp1_highest /bsp/thermal/$2_temp_highest
+  fi
+  if [ "$2" == "reset" ]; then
+    mkdir -p /bsp/reset/
+    ln -sf $3$4/bmc_reset_soft /bsp/reset/bmc_reset_soft
+    ln -sf $3$4/cpu_reset_hard /bsp/reset/cpu_reset_hard
+    ln -sf $3$4/cpu_reset_soft /bsp/reset/cpu_reset_soft
+    ln -sf $3$4/system_reset_hard /bsp/reset/system_reset_hard
+    ln -sf $3$4/bmc_uart_en /bsp/reset/bmc_uart_en
+    ln -sf $3$4/uart_sel /bsp/reset/uart_sel
+    ln -sf $3$4/bmc_upgrade /bsp/reset/bmc_upgrade
+
+    ln -sf $3$4/ac_power_cycle /bsp/reset/ac_power_cycle
+    ln -sf $3$4/dc_power_cycle /bsp/reset/dc_power_cycle
+    ln -sf $3$4/bmc_upgrade /bsp/reset/bmc_upgrade
+    ln -sf $3$4/cpu_kernel_panic /bsp/reset/cpu_kernel_panic
+    ln -sf $3$4/cpu_power_down /bsp/reset/cpu_power_down
+    ln -sf $3$4/cpu_reboot /bsp/reset/cpu_reboot
+    ln -sf $3$4/cpu_shutdown /bsp/reset/cpu_shutdown
+    ln -sf $3$4/cpu_watchdog /bsp/reset/cpu_watchdog
+  fi
+  if [ "$2" == "phy_reset" ]; then
+    mkdir -p /bsp/reset/
+    ln -sf $3$4/phy_reset /bsp/reset/reset_phy
+  fi
+  if [ "$2" == "fan" ]; then
+    mkdir -p /bsp/fan/
+    ln -sf $3$4/tacho0_en /bsp/fan/tacho1_en
+    ln -sf $3$4/tacho1_en /bsp/fan/tacho2_en
+    ln -sf $3$4/tacho2_en /bsp/fan/tacho3_en
+    ln -sf $3$4/tacho3_en /bsp/fan/tacho4_en
+    ln -sf $3$4/tacho4_en /bsp/fan/tacho5_en
+    ln -sf $3$4/tacho5_en /bsp/fan/tacho6_en
+    ln -sf $3$4/tacho6_en /bsp/fan/tacho7_en
+    ln -sf $3$4/tacho7_en /bsp/fan/tacho8_en
+
+    ln -sf $3$4/tacho0_rpm /bsp/fan/tacho1_rpm
+    ln -sf $3$4/tacho1_rpm /bsp/fan/tacho2_rpm
+    ln -sf $3$4/tacho2_rpm /bsp/fan/tacho3_rpm
+    ln -sf $3$4/tacho3_rpm /bsp/fan/tacho4_rpm
+    ln -sf $3$4/tacho4_rpm /bsp/fan/tacho5_rpm
+    ln -sf $3$4/tacho5_rpm /bsp/fan/tacho6_rpm
+    ln -sf $3$4/tacho6_rpm /bsp/fan/tacho7_rpm
+    ln -sf $3$4/tacho7_rpm /bsp/fan/tacho8_rpm
+
+    ln -sf $3$4/pwm0_en /bsp/fan/pwm_en
+    ln -sf $3$4/pwm0_falling /bsp/fan/pwm
+
+    for i in /bsp/fan/tacho[1-8]_en; do echo 1 > $i; done
+    echo 1 > /bsp/fan/pwm_en
+    echo 6 > /bsp/fan/pwm
+  fi
+  if [ "$2" == "fan_4_10" ]; then
+    mkdir -p /bsp/fan/
+
+    ln -sf $3$4/fan1_input /bsp/fan/tacho1_rpm
+    ln -sf $3$4/fan2_input /bsp/fan/tacho2_rpm
+    ln -sf $3$4/fan3_input /bsp/fan/tacho3_rpm
+    ln -sf $3$4/fan4_input /bsp/fan/tacho4_rpm
+    ln -sf $3$4/fan5_input /bsp/fan/tacho5_rpm
+    ln -sf $3$4/fan6_input /bsp/fan/tacho6_rpm
+    ln -sf $3$4/fan7_input /bsp/fan/tacho7_rpm
+    ln -sf $3$4/fan8_input /bsp/fan/tacho8_rpm
+
+    ln -sf $3$4/pwm1 /bsp/fan/pwm
+
+    echo 153 > /bsp/fan/pwm
+  fi
+  if [ "$2" == "eeprom_psu1" ]; then
+    mkdir -p /bsp/fru/
+    ln -sf $3$4/eeprom /bsp/fru/psu1_eeprom
+    status_led.py 0xb5 1 0x2d
+  fi
+  if [ "$2" == "eeprom_psu2" ]; then
+    mkdir -p /bsp/fru/
+    ln -sf $3$4/eeprom /bsp/fru/psu2_eeprom
+    status_led.py 0xb6 1 0x2d
+  fi
+  if [ "$2" == "eeprom_fan1" ]; then
+    mkdir -p /bsp/fru/
+    ln -sf $3$4/eeprom /bsp/fru/fan1_eeprom
+    echo 0 > /bsp/leds/fan/red/1/brightness
+    echo 1 > /bsp/leds/fan/green/1/brightness
+    status_led.py 0xb7 1 0x2e
+  fi
+  if [ "$2" == "eeprom_fan2" ]; then
+    mkdir -p /bsp/fru/
+    ln -sf $3$4/eeprom /bsp/fru/fan2_eeprom
+    echo 0 > /bsp/leds/fan/red/2/brightness
+    echo 1 > /bsp/leds/fan/green/2/brightness
+    status_led.py 0xb8 1 0x2e
+  fi
+  if [ "$2" == "eeprom_fan3" ]; then
+    mkdir -p /bsp/fru/
+    ln -sf $3$4/eeprom /bsp/fru/fan3_eeprom
+    echo 0 > /bsp/leds/fan/red/3/brightness
+    echo 1 > /bsp/leds/fan/green/3/brightness
+    status_led.py 0xb9 1 0x2e
+  fi
+  if [ "$2" == "eeprom_fan4" ]; then
+    mkdir -p /bsp/fru/
+    ln -sf $3$4/eeprom /bsp/fru/fan4_eeprom
+    echo 0 > /bsp/leds/fan/red/4/brightness
+    echo 1 > /bsp/leds/fan/green/4/brightness
+    status_led.py 0xba 1 0x2e
+  fi
+  if [ "$2" == "fan1_green" ]; then
+    mkdir -p /bsp/leds/fan/green/1/
+    ln -sf $3$4/brightness /bsp/leds/fan/green/1/brightness
+    ln -sf $3$4/trigger /bsp/leds/fan/green/1/trigger
+    echo timer > /bsp/leds/fan/green/1/trigger
+    ln -sf $3$4/delay_on  /bsp/leds/fan/green/1/delay_on
+    ln -sf $3$4/delay_off /bsp/leds/fan/green/1/delay_off
+  fi
+  if [ "$2" == "fan1_red" ]; then
+    mkdir -p /bsp/leds/fan/red/1/
+    ln -sf $3$4/brightness /bsp/leds/fan/red/1/brightness
+    ln -sf $3$4/trigger /bsp/leds/fan/red/1/trigger
+    echo 1 > /bsp/leds/fan/red/1/brightness
+    echo timer > /bsp/leds/fan/red/1/trigger
+    ln -sf $3$4/delay_on  /bsp/leds/fan/red/1/delay_on
+    ln -sf $3$4/delay_off /bsp/leds/fan/red/1/delay_off
+  fi
+  if [ "$2" == "fan2_green" ]; then
+    mkdir -p /bsp/leds/fan/green/2/
+    ln -sf $3$4/brightness /bsp/leds/fan/green/2/brightness
+    ln -sf $3$4/trigger /bsp/leds/fan/green/2/trigger
+    echo timer > /bsp/leds/fan/green/2/trigger
+    ln -sf $3$4/delay_on  /bsp/leds/fan/green/2/delay_on
+    ln -sf $3$4/delay_off /bsp/leds/fan/green/2/delay_off
+  fi
+  if [ "$2" == "fan2_red" ]; then
+    mkdir -p /bsp/leds/fan/red/2/
+    ln -sf $3$4/brightness /bsp/leds/fan/red/2/brightness
+    ln -sf $3$4/trigger /bsp/leds/fan/red/2/trigger
+    echo 1 > /bsp/leds/fan/red/2/brightness
+    echo timer > /bsp/leds/fan/red/2/trigger
+    ln -sf $3$4/delay_on  /bsp/leds/fan/red/2/delay_on
+    ln -sf $3$4/delay_off /bsp/leds/fan/red/2/delay_off
+  fi
+  if [ "$2" == "fan3_green" ]; then
+    mkdir -p /bsp/leds/fan/green/3/
+    ln -sf $3$4/brightness /bsp/leds/fan/green/3/brightness
+    ln -sf $3$4/trigger /bsp/leds/fan/green/3/trigger
+    echo timer > /bsp/leds/fan/green/3/trigger
+    ln -sf $3$4/delay_on  /bsp/leds/fan/green/3/delay_on
+    ln -sf $3$4/delay_off /bsp/leds/fan/green/3/delay_off
+  fi
+  if [ "$2" == "fan3_red" ]; then
+    mkdir -p /bsp/leds/fan/red/3/
+    ln -sf $3$4/brightness /bsp/leds/fan/red/3/brightness
+    ln -sf $3$4/trigger /bsp/leds/fan/red/3/trigger
+    echo 1 > /bsp/leds/fan/red/3/brightness
+    echo timer > /bsp/leds/fan/red/3/trigger
+    ln -sf $3$4/delay_on  /bsp/leds/fan/red/3/delay_on
+    ln -sf $3$4/delay_off /bsp/leds/fan/red/3/delay_off
+  fi
+  if [ "$2" == "fan4_green" ]; then
+    mkdir -p /bsp/leds/fan/green/4/
+    ln -sf $3$4/brightness /bsp/leds/fan/green/4/brightness
+    ln -sf $3$4/trigger /bsp/leds/fan/green/4/trigger
+    echo timer > /bsp/leds/fan/green/4/trigger
+    ln -sf $3$4/delay_on  /bsp/leds/fan/green/4/delay_on
+    ln -sf $3$4/delay_off /bsp/leds/fan/green/4/delay_off
+  fi
+  if [ "$2" == "fan4_red" ]; then
+    mkdir -p /bsp/leds/fan/red/4/
+    ln -sf $3$4/brightness /bsp/leds/fan/red/4/brightness
+    ln -sf $3$4/trigger /bsp/leds/fan/red/4/trigger
+    echo 1 > /bsp/leds/fan/red/4/brightness
+    echo timer > /bsp/leds/fan/red/4/trigger
+    ln -sf $3$4/delay_on  /bsp/leds/fan/red/4/delay_on
+    ln -sf $3$4/delay_off /bsp/leds/fan/red/4/delay_off
+  fi
+  if [ "$2" == "status_green" ]; then
+    mkdir -p /bsp/leds/status/green/
+    ln -sf $3$4/brightness /bsp/leds/status/green/brightness
+    ln -sf $3$4/trigger /bsp/leds/status/green/trigger
+    echo timer > /bsp/leds/status/green/trigger
+    ln -sf $3$4/delay_on  /bsp/leds/status/green/delay_on
+    ln -sf $3$4/delay_off /bsp/leds/status/green/delay_off
+  fi
+  if [ "$2" == "status_red" ]; then
+    mkdir -p /bsp/leds/status/red/
+    ln -sf $3$4/brightness /bsp/leds/status/red/brightness
+    ln -sf $3$4/trigger /bsp/leds/status/red/trigger
+    echo timer > /bsp/leds/status/red/trigger
+    ln -sf $3$4/delay_on  /bsp/leds/status/red/delay_on
+    ln -sf $3$4/delay_off /bsp/leds/status/red/delay_off
+  fi
+  if [ "$2" == "status_amber" ]; then
+    mkdir -p /bsp/leds/status/amber/
+    ln -sf $3$4/brightness /bsp/leds/status/amber/brightness
+    ln -sf $3$4/trigger /bsp/leds/status/amber/trigger
+    echo timer > /bsp/leds/status/amber/trigger
+    ln -sf $3$4/delay_on  /bsp/leds/status/amber/delay_on
+    ln -sf $3$4/delay_off /bsp/leds/status/amber/delay_off
+  fi
+  if [ "$2" == "thermal_zone0" ]; then
+    mkdir -p /bsp/thermal/
+    mkdir -p /bsp/thermal/$2/
+    ln -sf $3$4/mode /bsp/thermal/$2/mode
+  fi
+elif [ "$1" == "change" ]; then
+  if [ "$2" == "reset" ]; then
+    unlink /bsp/reset/bmc_reset_soft
+    unlink /bsp/reset/cpu_reset_hard
+    unlink /bsp/reset/cpu_reset_soft
+    unlink /bsp/reset/system_reset_hard
+    unlink /bsp/reset/bmc_uart_en
+    unlink /bsp/reset/uart_sel
+    unlink /bsp/reset/bmc_upgrade
+    unlink /bsp/reset/ac_power_cycle
+    unlink /bsp/reset/dc_power_cycle
+    unlink /bsp/reset/bmc_upgrade
+    unlink /bsp/reset/cpu_kernel_panic
+    unlink /bsp/reset/cpu_power_down
+    unlink /bsp/reset/cpu_reboot
+    unlink /bsp/reset/cpu_shutdown
+    unlink /bsp/reset/cpu_watchdog
+
+    ln -sf $3$4/bmc_reset_soft /bsp/reset/bmc_reset_soft
+    ln -sf $3$4/cpu_reset_hard /bsp/reset/cpu_reset_hard
+    ln -sf $3$4/cpu_reset_soft /bsp/reset/cpu_reset_soft
+    ln -sf $3$4/system_reset_hard /bsp/reset/system_reset_hard
+    ln -sf $3$4/bmc_uart_en /bsp/reset/bmc_uart_en
+    ln -sf $3$4/uart_sel /bsp/reset/uart_sel
+    ln -sf $3$4/bmc_upgrade /bsp/reset/bmc_upgrade
+    ln -sf $3$4/ac_power_cycle /bsp/reset/ac_power_cycle
+    ln -sf $3$4/dc_power_cycle /bsp/reset/dc_power_cycle
+    ln -sf $3$4/bmc_upgrade /bsp/reset/bmc_upgrade
+    ln -sf $3$4/cpu_kernel_panic /bsp/reset/cpu_kernel_panic
+    ln -sf $3$4/cpu_power_down /bsp/reset/cpu_power_down
+    ln -sf $3$4/cpu_reboot /bsp/reset/cpu_reboot
+    ln -sf $3$4/cpu_shutdown /bsp/reset/cpu_shutdown
+    ln -sf $3$4/cpu_watchdog /bsp/reset/cpu_watchdog
+  fi
+  if [ "$2" == "phy_reset" ]; then
+    unlink /bsp/reset/reset_phy
+    ln -sf $3$4/phy_reset /bsp/reset/reset_phy
+  fi
+else
+  if [ "$2" == "amb_current" ] || [ "$2" == "amb_switch" ]; then
+    unlink /bsp/thermal/$2_temp
+    unlink /bsp/thermal/$2_temp_max
+    unlink /bsp/thermal/$2_temp_hyst
+  fi
+  if [ "$2" == "psu1" ] || [ "$2" == "psu2" ]; then
+    unlink /bsp/thermal/$2_temp
+    unlink /bsp/thermal/$2_temp_max
+    unlink /bsp/thermal/$2_temp_alarm
+    unlink /bsp/environment/$2_vin
+    unlink /bsp/environment/$2_vout
+    unlink /bsp/environment/$2_pin
+    unlink /bsp/environment/$2_pout
+    unlink /bsp/environment/$2_iin
+    unlink /bsp/environment/$2_iout
+    unlink /bsp/fan/$2_fan_input
+  fi
+  if [ "$2" == "A2D" ]; then
+    unlink /bsp/environment/$2_voltage_scale
+    unlink /bsp/environment/$2_1_8v
+    unlink /bsp/environment/$2_1_2v
+    unlink /bsp/environment/$2_vcore
+    unlink /bsp/environment/$2_swb_12v
+    unlink /bsp/environment/$2_swb_3_3v_aux
+    unlink /bsp/environment/$2_swb_3_3v_sen
+  fi
+  if [ "$2" == "ADC" ]; then
+    unlink /bsp/environment/$2_12v
+    unlink /bsp/environment/$2_5v
+    unlink /bsp/environment/$2_5v_usb
+    unlink /bsp/environment/$2_3_3v_aux
+    unlink /bsp/environment/$2_3_3v_bmc
+    unlink /bsp/environment/$2_2_5v_ddr
+    unlink /bsp/environment/$2_1_2v_ddr
+    unlink /bsp/environment/$2_1_15v_Vcore
+  fi
+  if [ "$2" == "UCD" ]; then
+    unlink /bsp/environment/$2_3_3v_sen
+    unlink /bsp/environment/$2_1_2v
+    unlink /bsp/environment/$2_3_3v_sen_curr
+    unlink /bsp/environment/$2_1_2v_curr
+  fi
+  if [ "$2" == "VcoreUCD" ]; then
+    unlink /bsp/environment/$2
+    unlink /bsp/environment/$2_curr
+  fi
+  if [ "$2" == "asic" ]; then
+    unlink /bsp/thermal/$2_temp
+    unlink /bsp/thermal/$2_temp_highest
+  fi
+  if [ "$2" == "reset" ]; then
+    unlink /bsp/reset/bmc_reset_soft
+    unlink /bsp/reset/cpu_reset_hard
+    unlink /bsp/reset/cpu_reset_soft
+    unlink /bsp/reset/system_reset_hard
+    unlink /bsp/reset/reset_phy
+    unlink /bsp/reset/bmc_uart_en
+    unlink /bsp/reset/uart_sel
+    unlink /bsp/reset/ac_power_cycle
+    unlink /bsp/reset/dc_power_cycle
+    unlink /bsp/reset/bmc_upgrade
+    unlink /bsp/reset/cpu_kernel_panic
+    unlink /bsp/reset/cpu_power_down
+    unlink /bsp/reset/cpu_reboot
+    unlink /bsp/reset/cpu_shutdown
+    unlink /bsp/reset/cpu_watchdog
+  fi
+  if [ "$2" == "phy_reset" ]; then
+    unlink /bsp/reset/reset_phy
+  fi
+  if [ "$2" == "fan" ]; then
+    unlink /bsp/fan/tacho1_en
+    unlink /bsp/fan/tacho2_en
+    unlink /bsp/fan/tacho3_en
+    unlink /bsp/fan/tacho4_en
+    unlink /bsp/fan/tacho5_en
+    unlink /bsp/fan/tacho6_en
+    unlink /bsp/fan/tacho7_en
+    unlink /bsp/fan/tacho8_en
+
+    unlink /bsp/fan/tacho1_rpm
+    unlink /bsp/fan/tacho2_rpm
+    unlink /bsp/fan/tacho3_rpm
+    unlink /bsp/fan/tacho4_rpm
+    unlink /bsp/fan/tacho5_rpm
+    unlink /bsp/fan/tacho6_rpm
+    unlink /bsp/fan/tacho7_rpm
+    unlink /bsp/fan/tacho8_rpm
+    unlink /bsp/fan/pwm_en
+    unlink /bsp/fan/pwm
+  fi
+  if [ "$2" == "fan_4_10" ]; then
+    unlink /bsp/fan/tacho1_rpm
+    unlink /bsp/fan/tacho2_rpm
+    unlink /bsp/fan/tacho3_rpm
+    unlink /bsp/fan/tacho4_rpm
+    unlink /bsp/fan/tacho5_rpm
+    unlink /bsp/fan/tacho6_rpm
+    unlink /bsp/fan/tacho7_rpm
+    unlink /bsp/fan/tacho8_rpm
+    unlink /bsp/fan/pwm
+  fi
+  if [ "$2" == "eeprom_psu1" ]; then
+    unlink /bsp/fru/psu1_eeprom
+    status_led.py 0xb5 0 0x2d
+  fi
+  if [ "$2" == "eeprom_psu2" ]; then
+    unlink /bsp/fru/psu2_eeprom
+    status_led.py 0xb6 0 0x2d
+  fi
+  if [ "$2" == "eeprom_fan1" ]; then
+    unlink /bsp/fru/fan1_eeprom
+    echo 0 > /bsp/leds/fan/green/1/brightness
+    echo 1 > /bsp/leds/fan/red/1/brightness
+    status_led.py 0xb7 0 0x2e
+  fi
+  if [ "$2" == "eeprom_fan2" ]; then
+    unlink /bsp/fru/fan2_eeprom
+    echo 0 > /bsp/leds/fan/green/2/brightness
+    echo 1 > /bsp/leds/fan/red/2/brightness
+    status_led.py 0xb8 0 0x2e
+  fi
+  if [ "$2" == "eeprom_fan3" ]; then
+    unlink /bsp/fru/fan3_eeprom
+    echo 0 > /bsp/leds/fan/green/3/brightness
+    echo 1 > /bsp/leds/fan/red/3/brightness
+    status_led.py 0xb9 0 0x2e
+  fi
+  if [ "$2" == "eeprom_fan4" ]; then
+    unlink /bsp/fru/fan4_eeprom
+    echo 0 > /bsp/leds/fan/green/4/brightness
+    echo 1 > /bsp/leds/fan/red/4/brightness
+    status_led.py 0xba 0 0x2e
+  fi
+  if [ "$2" == "fan1_green" ]; then
+    unlink /bsp/leds/fan/green/1/brightness
+    unlink /bsp/leds/fan/green/1/trigger
+    unlink /bsp/leds/fan/green/1/delay_on
+    unlink /bsp/leds/fan/green/1/delay_off
+  fi
+  if [ "$2" == "fan1_red" ]; then
+    unlink /bsp/leds/fan/red/1/brightness
+    unlink /bsp/leds/fan/red/1/trigger
+    unlink /bsp/leds/fan/red/1/delay_on
+    unlink /bsp/leds/fan/red/1/delay_off
+  fi
+  if [ "$2" == "fan2_green" ]; then
+    unlink /bsp/leds/fan/green/2/brightness
+    unlink /bsp/leds/fan/green/2/trigger
+    unlink /bsp/leds/fan/green/2/delay_on
+    unlink /bsp/leds/fan/green/2/delay_off
+  fi
+  if [ "$2" == "fan2_red" ]; then
+    unlink /bsp/leds/fan/red/2/brightness
+    unlink /bsp/leds/fan/red/2/trigger
+    unlink /bsp/leds/fan/red/2/delay_on
+    unlink /bsp/leds/fan/red/2/delay_off
+  fi
+  if [ "$2" == "fan3_green" ]; then
+    unlink /bsp/leds/fan/green/3/brightness
+    unlink /bsp/leds/fan/green/3/trigger
+    unlink /bsp/leds/fan/green/3/delay_on
+    unlink /bsp/leds/fan/green/3/delay_off
+  fi
+  if [ "$2" == "fan3_red" ]; then
+    unlink /bsp/leds/fan/red/3/brightness
+    unlink /bsp/leds/fan/red/3/trigger
+    unlink /bsp/leds/fan/red/3/delay_on
+    unlink /bsp/leds/fan/red/3/delay_off
+  fi
+  if [ "$2" == "fan4_green" ]; then
+    unlink /bsp/leds/fan/green/4/brightness
+    unlink /bsp/leds/fan/green/4/trigger
+    unlink /bsp/leds/fan/green/4/delay_on
+    unlink /bsp/leds/fan/green/4/delay_off
+  fi
+  if [ "$2" == "fan4_red" ]; then
+    unlink /bsp/leds/fan/red/4/brightness
+    unlink /bsp/leds/fan/red/4/trigger
+    unlink /bsp/leds/fan/red/4/delay_on
+    unlink /bsp/leds/fan/red/4/delay_off
+  fi
+  if [ "$2" == "status_green" ]; then
+    unlink /bsp/leds/status/green/brightness
+    unlink /bsp/leds/status/green/trigger
+    unlink /bsp/leds/status/green/delay_on
+    unlink /bsp/leds/status/green/delay_off
+  fi
+  if [ "$2" == "status_red" ]; then
+    unlink /bsp/leds/status/red/brightness
+    unlink /bsp/leds/status/red/trigger
+    unlink /bsp/leds/status/red/delay_on
+    unlink /bsp/leds/status/red/delay_off
+  fi
+  if [ "$2" == "status_amber" ]; then
+    unlink /bsp/leds/status/amber/brightness
+    unlink /bsp/leds/status/amber/trigger
+    unlink /bsp/leds/status/amber/delay_on
+    unlink /bsp/leds/status/amber/delay_off
+  fi
+  if [ "$2" == "thermal_zone0" ]; then
+    unlink /bsp/thermal/$2/mode
+  fi
+fi
diff --git a/lanserv/mellanox/sdr.20.main b/lanserv/mellanox/sdr.20.main
new file mode 100644
index 0000000..79aac75
--- /dev/null
+++ b/lanserv/mellanox/sdr.20.main
@@ -0,0 +1,49 @@
+last_add_time:i:1490790637
+48:d:0\00Q\02* \10(\03 g\00\07o\01\00\01\00\01\00\c0\00\00\00\00\00\00\00\00\00\00\cfCPU Status
+47:d:/\00Q\013 \00y\1d\01\7fH\04\01\04 \04\00\02\00\00\12\00\00d\00\00\01\00\00\01d\00\00\fa\00\00\00\00\00\05\00\02\02\00\00\00\c8PSU2_fan
+46:d:.\00Q\013 \00x\1d\01\7fH\04\01\04 \04\00\02\00\00\12\00\00d\00\00\01\00\00\01d\00\00\fa\00\00\00\00\00\05\00\02\02\00\00\00\c8PSU1_fan
+45:d:-\00Q\011 \00w\1d\01\7fH\04\01\04 \04\00\02\00\00\12\00\00d\00\00\01\00\00\01d\00\00\fa\00\00\00\00\00\05\00\02\02\00\00\00\c6fan4_2
+44:d:,\00Q\011 \00v\1d\01\7fH\04\01\04 \04\00\02\00\00\12\00\00d\00\00\01\00\00\01d\00\00\fa\00\00\00\00\00\05\00\02\02\00\00\00\c6fan4_1
+43:d:+\00Q\011 \00u\1d\01\7fH\04\01\04 \04\00\02\00\00\12\00\00d\00\00\01\00\00\01d\00\00\fa\00\00\00\00\00\05\00\02\02\00\00\00\c6fan3_2
+42:d:*\00Q\011 \00t\1d\01\7fH\04\01\04 \04\00\02\00\00\12\00\00d\00\00\01\00\00\01d\00\00\fa\00\00\00\00\00\05\00\02\02\00\00\00\c6fan3_1
+41:d:)\00Q\011 \00s\1d\01\7fH\04\01\04 \04\00\02\00\00\12\00\00d\00\00\01\00\00\01d\00\00\fa\00\00\00\00\00\05\00\02\02\00\00\00\c6fan2_2
+40:d:(\00Q\011 \00r\1d\01\7fH\04\01\04 \04\00\02\00\00\12\00\00d\00\00\01\00\00\01d\00\00\fa\00\00\00\00\00\05\00\02\02\00\00\00\c6fan2_1
+39:d:'\00Q\011 \00q\1d\01\7fH\04\01\04 \04\00\02\00\00\12\00\00d\00\00\01\00\00\01d\00\00\fa\00\00\00\00\00\05\00\02\02\00\00\00\c6fan1_2
+38:d:&\00Q\011 \00p\1d\01\7fH\04\01\04 \04\00\02\00\00\12\00\00d\00\00\01\00\00\01d\00\00\fa\00\00\00\00\00\05\00\02\02\00\00\00\c6fan1_1
+37:d:%\00Q\018 \00$\0a\01\7fH\03\01\00\02\00"\10\10\00\05\00\00}\00\00\01\01\d0\01\00\00\00\d8\00\00\c8\00\00\00\00\02\02\00\00\00\cdUCD_1_2v_curr
+36:d:$\00Q\01< \00#\0a\01\7fH\03\01\00\02\00"\10\10\00\05\00\00\8e\00\00\01\01\d0\01\00\00\00\e7\00\00\da\00\00\00\00\02\02\00\00\00\d1UCD_3_3v_sen_curr
+35:d:#\00Q\018 \00"\0a\01\7fH\03\01\00\02\00"\10\10\00\05\00\00\f4@\00\01\01\d0\01\00\00\00\b2\00\00\ae\00\00\00\00\02\02\00\00\00\cdVcoreUCD_curr
+34:d:"\00Q\014 \00!\0a\01\7fH\03\01\00\02\00"\10\10\00\05\00\00\86\00\00\01\01\d0\01K\00\00\fe\00\00\ef\00\00\00\00\02\02\00\00\00\c9PSU2_iout
+33:d:!\00Q\013 \00 \0a\01\7fH\03\01\00\02\00"\10\10\00\05\00\00\9d\00\00\01\01\c0\01`\00\00\fe\00\00\bf\00\00\00\00\02\02\00\00\00\c8PSU2_iin
+32:d: \00Q\014 \00\1f\0a\01\7fH\03\01\00\02\00"\10\10\00\05\00\00\86\00\00\01\01\d0\01K\00\00\fe\00\00\ef\00\00\00\00\02\02\00\00\00\c9PSU1_iout
+31:d:\1f\00Q\013 \00\1e\0a\01\7fH\03\01\00\02\00"\10\10\00\05\00\00\9d\00\00\01\01\c0\01`\00\00\fe\00\00\bf\00\00\00\00\02\02\00\00\00\c8PSU1_iin
+30:d:\1e\00Q\014 \00\17\0a\01\7fH\08\01\00\02\00"\10\10\00\06\00\00\c8\00\00\01\01\e0\012\00\00\cc\00\00\be\00\00\00\00\02\02\00\00\00\c9PSU2_pout
+29:d:\1d\00Q\013 \00\16\0a\01\7fH\08\01\00\02\00"\10\10\00\06\00\00\90@\00\01\01\e0\01}\00\00\dc\00\00\bc\00\00\00\00\02\02\00\00\00\c8PSU2_pin
+28:d:\1c\00Q\014 \00\15\0a\01\7fH\08\01\00\02\00"\10\10\00\06\00\00\c8\00\00\01\01\e0\012\00\00\cc\00\00\be\00\00\00\00\02\02\00\00\00\c9PSU1_pout
+27:d:\1b\00Q\013 \00\14\0a\01\7fH\08\01\00\02\00"\10\10\00\06\00\00\90@\00\01\01\e0\01}\00\00\dc\00\00\bc\00\00\00\00\02\02\00\00\00\c8PSU1_pin
+26:d:\1a\00Q\014 \00\ae\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00\f4@\00\01\01\b0\01\b4\00\00\f0\00\00\c6\00\00\a2\00\02\02\00\00\00\c9UCD Vcore
+25:d:\19\00Q\013 \00\ad\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00d\00\00\01\01\c0\01x\00\00\b4\00\00\84\00\00l\00\02\02\00\00\00\c8UCD 1.2v
+24:d:\18\00Q\017 \00\ac\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00\9c\00\00\01\01\c0\01\d4\00\00\ff\00\00\e9\00\00\be\00\02\02\00\00\00\ccUCD 3.3v_sen
+23:d:\17\00Q\01: \00\ab\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\008\00\00\01\01\c0\01\cd\00\00\ff\00\00\d8\00\00\c3\00\02\02\00\00\00\cfADC 1.15v_Vcore
+22:d:\16\00Q\017 \00\aa\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\008\00\00\01\01\c0\01\d6\00\00\ff\00\00\e1\00\00\cc\00\02\02\00\00\00\ccADC 1.2v_ddr
+21:d:\15\00Q\017 \00\a9\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00v\00\00\01\01\c0\01\d4\00\00\ff\00\00\de\00\00\c9\00\02\02\00\00\00\ccADC 2.5v_ddr
+20:d:\14\00Q\017 \00\a8\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00\9b\00\00\01\01\c0\01\d5\00\00\ff\00\00\e0\00\00\ca\00\02\02\00\00\00\ccADC 3.3v_bmc
+19:d:\13\00Q\017 \00\a7\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00\9c\00\00\01\01\c0\01\d4\00\00\ff\00\00\de\00\00\c9\00\02\02\00\00\00\ccADC 3.3v_aux
+18:d:\12\00Q\015 \00\a6\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00\eb\00\00\01\01\c0\01\05\00\00\ff\00\00\df\00\00\ca\00\02\02\00\00\00\caADC 5v usb
+17:d:\11\00Q\011 \00\a5\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00\eb\00\00\01\01\c0\01\d5\00\00\ff\00\00\df\00\00\ca\00\02\02\00\00\00\c6ADC 5v
+16:d:\10\00Q\012 \00\a4\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\008\00\00\01\01\d0\01\d6\00\00\ff\00\00\e1\00\00\cc\00\02\02\00\00\00\c7ADC 12v
+15:d:\0f\00Q\017 \00\a3\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00\9c\00\00\01\01\c0\01\d4\00\00\ff\00\00\de\00\00\c9\00\02\02\00\00\00\ccSWB 3.3v_sen
+14:d:\0e\00Q\017 \00\a2\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00\9c\00\00\01\01\c0\01\d4\00\00\ff\00\00\de\00\00\c9\00\02\02\00\00\00\ccSWB 3.3v_aux
+13:d:\0d\00Q\012 \00\a1\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\008\00\00\01\01\d0\01\0c\00\00\ff\00\00\e1\00\00\cc\00\02\02\00\00\00\c7SWB 12v
+12:d:\0c\00Q\014 \00\a0\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00\bf@\00\01\01\b0\01\d5\00\00\ff\00\00\df\00\00\ca\00\02\02\00\00\00\c9A2D Vcore
+11:d:\0b\00Q\013 \00\9f\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\008\00\00\01\01\c0\01\d6\00\00\ff\00\00\ec\00\00\c1\00\02\02\00\00\00\c8A2D 1.2v
+10:d:\0a\00Q\013 \00\9e\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00U\00\00\01\01\c0\01\d4\00\00\ff\00\00\e9\00\00\c9\00\02\02\00\00\00\c8A2D 1.8v
+9:d:\09\00Q\014 \00\9d\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\008\00\00\01\01\d0\01\0c\00\00\ff\00\00\ec\00\00\c1\00\02\02\00\00\00\c9PSU2 vout
+8:d:\08\00Q\013 \00\9c\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00d\00\00\01\01\e0\01\e6\00\00\ff\00\00\fa\00\00\aa\00\02\02\00\00\00\c8PSU2 vin
+7:d:\07\00Q\014 \00\9b\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\008\00\00\01\01\d0\01\0c\00\00\ff\00\00\ec\00\00\c1\00\02\02\00\00\00\c9PSU1 vout
+6:d:\06\00Q\013 \00\9a\0a\01\7fH\02\01\04"\04"\12\12\00\04\00\00d\00\00\01\01\e0\01\e6\00\00\ff\00\00\fa\00\00\aa\00\02\02\00\00\00\c8PSU1 vin
+5:d:\05\00Q\014 \00\05*\01\7fH\01\01\852\852\1b\1b\00\01\00\00\01\00\80\c0\01\00\01\99\00\00\f8N\00\d2\bc\00j\81\01\01\00\00\00\c9asic temp
+4:d:\04\00Q\014 \00\04*\01\7fH\01\01\852\852\1b\1b\00\01\00\00\01\00\80\c0\01\00\01\99\00\00\f8N\00\d2\bc\00j\81\01\01\00\00\00\c9PSU2 temp
+3:d:\03\00Q\014 \00\03*\01\7fH\01\01\852\852\1b\1b\00\01\00\00\01\00\80\c0\01\00\01\99\00\00\f8N\00\d2\bc\00j\81\01\01\00\00\00\c9PSU1 temp
+2:d:\02\00Q\01> \00\02*\01\7fH\01\01\852\852\1b\1b\00\01\00\00\01\00\80\c0\01\00\01\99\00\00\f8N\00\d2\bc\00j\81\01\01\00\00\00\d3ambient switch temp
+1:d:\01\00Q\01? \00\01*\01\7fH\01\01\852\852\1b\1b\00\01\00\00\01\00\80\c0\01\00\01\99\00\00\f8N\00\d2\bc\00j\81\01\01\00\00\00\d4ambient carrier temp
diff --git a/lanserv/mellanox/sel_set_log_size.sh b/lanserv/mellanox/sel_set_log_size.sh
new file mode 100644
index 0000000..24261f2
--- /dev/null
+++ b/lanserv/mellanox/sel_set_log_size.sh
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+########################################################################
+# Copyright (c) 2017 Mellanox Technologies.
+# Copyright (c) 2017 Nataliya Yakuts <nataliyay@mellanox.com>
+#
+# Licensed under the GNU General Public License Version 2
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+
+H_SIZE=$1
+
+if [ $H_SIZE -gt 4095 ] || [ $H_SIZE -lt 64 ]; then
+        echo "Invalid range. Value must be in range 64-4095\n"
+else
+        sed -i'' "s/^sel_enable \([0-9x]*\) [^ ]* \([0-9x]*\)/sel_enable \1 $H_SIZE \2/g" /etc/ipmi/mellanox.hw
+fi
diff --git a/lanserv/mellanox/status_led.json b/lanserv/mellanox/status_led.json
new file mode 100644
index 0000000..5e38dbf
--- /dev/null
+++ b/lanserv/mellanox/status_led.json
@@ -0,0 +1,56 @@
+{
+    "ids": {
+      "0x01": "2",
+      "0x02": "2",
+      "0x05": "2",
+      "0x22": "2",
+      "0x23": "2",
+      "0x24": "2",
+      "0x9a": "1",
+      "0x9c": "1",
+      "0x9e": "2",
+      "0xac": "2",
+      "0xad": "2", 
+      "0xae": "2",
+      "0x70": "1",
+      "0x71": "1",
+      "0x72": "1",
+      "0x73": "1",
+      "0x74": "1",
+      "0x75": "1",
+      "0x76": "1",
+      "0x77": "1",
+      "0xb4": "2",
+      "0xb5": "1",
+      "0xb6": "1",
+      "0xb7": "1",
+      "0xb8": "1",
+      "0xb9": "1",
+      "0xba": "1",
+      "0xbb": "1"
+    },
+    "type": {
+              "0x04": {
+                  "status": "2",
+                  "max_count": "2"
+              },
+              "0x2e": {
+                  "status": "2",
+                  "max_count": "1"
+              }
+    },
+    "status": [
+      {
+        "color": "green",
+        "cmd": "echo 0 > /bsp/leds/status/red/brightness;echo 0 > /bsp/leds/status/amber/brightness;echo 1 > /bsp/leds/status/green/brightness;echo timer > /bsp/leds/status/green/trigger"
+      },
+      {
+        "color": "amber",
+        "cmd": "echo 0 > /bsp/leds/status/green/brightness;echo 0 > /bsp/leds/status/red/brightness;echo 1 > /bsp/leds/status/amber/brightness;echo timer > /bsp/leds/status/amber/trigger"
+      },
+      {
+        "color": "red",
+        "cmd": "echo 0 > /bsp/leds/status/amber/brightness;echo 0 > /bsp/leds/status/green/brightness;echo 1 > /bsp/leds/status/red/brightness;echo timer > /bsp/leds/status/red/trigger"
+      }
+    ]
+}
diff --git a/lanserv/mellanox/status_led.py b/lanserv/mellanox/status_led.py
new file mode 100755
index 0000000..f715c0a
--- /dev/null
+++ b/lanserv/mellanox/status_led.py
@@ -0,0 +1,125 @@
+#!/usr/bin/env python
+
+'''
+Sensor number (1-st param):
+    ambient carrier temp  0x01
+    ambient switch temp   0x02
+    asic temp             0x05
+    PSU1 vin              0x9A
+    PSU2 vin              0x9C
+    A2D 1.8v              0x9E
+    UCD 3.3v_sen          0xAC
+    UCD 1.2v              0xAD
+    UCD Vcore             0xAE
+    VcoreUCD_curr         0x22
+    UCD_3_3v_sen_cur      0x23
+    UCD_1_2v_curr         0x24
+    fan1_1                0x70
+    fan1_2                0x71
+    fan2_1                0x73
+    fan2_2                0x73
+    fan3_1                0x74
+    fan3_2                0x75
+    fan4_1                0x76
+    fan4_2                0x77
+    PSU1 drw              0xb5
+    PSU2 drw              0xb6
+    FAN1 drw              0xb7
+    FAN2 drw              0xb8
+    FAN3 drw              0xb9
+    FAN4 drw              0xba
+    CPU ready             0xbb
+
+Sensor Types (3-rd param):
+    Temperature           0x01
+    Voltage               0x02
+    Current               0x03
+    Fan                   0x04
+    Processor             0x07
+    PSU drw               0x2d
+    FAN drw               0x2e
+'''
+import sys
+import os
+
+import json
+
+config = {}
+entrys = {}
+
+#read config with allowed ids and something else
+def read_config():
+    global config
+    with open('/etc/status_led.json') as data_file:
+        config = json.load(data_file)
+
+    return 1
+
+#here we will check id and exit if this id dont allowed to set status led
+def filter_id(id):
+    global config
+
+    if id in config["ids"]:
+        return 1
+    else:
+        print "Not allowed id("+id+") for change status led."
+        return 0
+
+# 1 - event id
+# 2 - event status ( 0 - Asserted, 1 - Deassered)
+def get_args():
+    global entrys
+
+    if sys.argv[2] in ['0','1']:
+        if filter_id(sys.argv[1]):
+            if int(sys.argv[2]):
+                entrys[sys.argv[1]]= [0, sys.argv[3]]
+            else:
+                entrys[sys.argv[1]]= [config["ids"][sys.argv[1]], sys.argv[3]]
+            return
+
+    else:
+        print "2-nd argument only 0,1 allowed."
+    exit()
+
+def main():
+    global entrys
+    read_config()
+    s = open('/tmp/led_status', 'a+').read()
+    if s:
+        entrys = eval(s)
+
+    get_args()
+    open('/tmp/led_status', 'w').write(str(entrys))
+    set_status_led()
+
+#allways set worst status
+def set_status_led():
+    status = 0 #green by default
+    global status_led_sysfs
+    global config
+    type_counter = {}
+
+    for value in entrys.values():
+        status = status if (status > value[0]) else value[0]
+
+        if value[1] in config["type"]:
+            if int(value[0]) > 0:
+                if type_counter.get(value[1]):
+                    type_counter[value[1]] += int(1)
+                else:
+                    type_counter[value[1]] = 1
+    if type_counter:
+        for key, value in type_counter.iteritems():
+            max_type_id = key
+            max_type_cnt = value
+            cfg_type_status = config["type"].get(max_type_id).get("status")
+            cfg_type_max_cnt = config["type"].get(max_type_id).get("max_count")
+            if int(max_type_cnt) > int(cfg_type_max_cnt):
+                status = status if (status > cfg_type_status) else cfg_type_status
+
+    os.system(config["status"][int(status)].get("cmd"))
+
+
+# execute main
+main()
diff --git a/lanserv/sdrcomp/sdrcomp.c b/lanserv/sdrcomp/sdrcomp.c
index e98f649..6d8ca3d 100644
--- a/lanserv/sdrcomp/sdrcomp.c
+++ b/lanserv/sdrcomp/sdrcomp.c
@@ -54,7 +54,7 @@ struct sdr_field_name {
 struct sdr_field {
     char *name;
     enum { SDR_BITS, SDR_SBITS, SDR_MULTIBITS, SDR_MULTISBITS, SDR_MULTIBITS2,
-	   SDR_STRING, SDR_BOOLBIT, SDR_THRESH } type;
+	   SDR_STRING, SDR_BOOLBIT, SDR_THRESH, SDR_THRESHREL } type;
     /*
      * IMPORTANT: pos is offset + 1, the values given in the IPMI spec.
      * It is not zero-based.
@@ -120,7 +120,11 @@ static struct sdr_field_name entity_id_fields[] = {
     { "pci_express_bus", 49 },
     { "scsi_bus", 50 },
     { "sata_/_sas_bus", 51 },
-    { "processor_/_front-side_bus", 52 }
+    { "processor_/_front-side_bus", 52 },
+    { "picmg_front", 0xa0 },
+    { "picmg_rtm", 0xc0 },
+    { "picmg_amc", 0xc1 },
+    { NULL }
 };
 
 static struct sdr_field_name sensor_type_fields[] = {
@@ -167,7 +171,11 @@ static struct sdr_field_name sensor_type_fields[] = {
     { "Battery", 41 },
     { "Session_Audit", 42 },
     { "Version_Change", 43 },
-    { "FRU_State", 44 }
+    { "FRU_State", 44 },
+    { "picmg_FruHotSwap", 0xF0 },
+    { "picmg_IPMB0", 0xF1 },
+    { "picmg_ModuleHotSwap", 0xF2 },
+    { NULL }
 };
 
 static struct sdr_field_name sensor_access_fields[] = {
@@ -289,7 +297,8 @@ static struct sdr_field_name base_unit_fields[] = {
     { "characters", 87 },
     { "error", 88 },
     { "correctable_error", 89 },
-    { "uncorrectable_error", 90 }
+    { "uncorrectable_error", 90 },
+    { NULL }
 };
 
 static struct sdr_field_name linearization_fields[] = {
@@ -414,7 +423,7 @@ static struct sdr_field type1[] =
     { "unr_thrsh_settable",	SDR_BOOLBIT,	20, 5, 1 },
     { "uc_thrsh_settable",	SDR_BOOLBIT,	20, 4, 1 },
     { "unc_thrsh_settable",	SDR_BOOLBIT,	20, 3, 1 },
-    { "lnr_thresh_settable",	SDR_BOOLBIT,	20, 2, 1 },
+    { "lnr_thrsh_settable",	SDR_BOOLBIT,	20, 2, 1 },
     { "lc_thrsh_settable",	SDR_BOOLBIT,	20, 1, 1 },
     { "lnc_thrsh_settable",	SDR_BOOLBIT,	20, 0, 1 },
     { "unr_thrsh_readable",	SDR_BOOLBIT,	19, 5, 1 },
@@ -455,7 +464,9 @@ static struct sdr_field type1[] =
     { "nominal_reading",	SDR_BITS,	32, 0, 8 },
     { "nominal_freading",	SDR_THRESH,	32, 0, 8 },
     { "normal_maximum",		SDR_BITS,	33, 0, 8 },
+    { "normal_fmaximum",	SDR_THRESH,	33, 0, 8 },
     { "normal_minimum",		SDR_BITS,	34, 0, 8 },
+    { "normal_fminimum",	SDR_THRESH,	34, 0, 8 },
     { "sensor_maximum",		SDR_BITS,	35, 0, 8 },
     { "sensor_minimum",		SDR_BITS,	36, 0, 8 },
     { "unr_thresh",		SDR_BITS,	37, 0, 8 },
@@ -471,7 +482,9 @@ static struct sdr_field type1[] =
     { "lc_fthresh",		SDR_THRESH,	41, 0, 8 },
     { "lnc_fthresh",		SDR_THRESH,	42, 0, 8 },
     { "positive_hysteresis",	SDR_BITS,	43, 0, 8 },
+    { "positive_fhysteresis",	SDR_THRESHREL,	43, 0, 8 },
     { "negative_hysteresis",	SDR_BITS,	44, 0, 8 },
+    { "negative_fhysteresis",	SDR_THRESHREL,	44, 0, 8 },
     { "oem",			SDR_BITS,	47, 0, 8 },
     { "id_string",		SDR_STRING,	48, 0, 8, .required = 1 },
 };
@@ -590,7 +603,7 @@ static struct sdr_field type2[] =
     { "unr_thrsh_settable",	SDR_BOOLBIT,	20, 5, 1 },
     { "uc_thrsh_settable",	SDR_BOOLBIT,	20, 4, 1 },
     { "unc_thrsh_settable",	SDR_BOOLBIT,	20, 3, 1 },
-    { "lnr_thresh_settable",	SDR_BOOLBIT,	20, 2, 1 },
+    { "lnr_thrsh_settable",	SDR_BOOLBIT,	20, 2, 1 },
     { "lc_thrsh_settable",	SDR_BOOLBIT,	20, 1, 1 },
     { "lnc_thrsh_settable",	SDR_BOOLBIT,	20, 0, 1 },
     { "unr_thrsh_readable",	SDR_BOOLBIT,	19, 5, 1 },
@@ -1448,6 +1461,7 @@ ipmi_compile_sdr(FILE *f, unsigned int type,
 		break;
 
 	    case SDR_THRESH:
+	    case SDR_THRESHREL:
 	    {
 		double fval, fx;
 		int m, b, r_exp, b_exp;
@@ -1471,13 +1485,35 @@ ipmi_compile_sdr(FILE *f, unsigned int type,
 		if (b_exp & (1 << 3))
 		    b_exp |= (~0 << 4);
 
-		fx = (((fval / pow(10, r_exp)) - ((double) b) * pow(10, b_exp))
-		      / ((double) m));
-
-		if (t[i].name[0] == 'u')
-		    fx = ceil(fx);
-		else if (t[i].name[0] != 'l')
-		    fx += .5; /* round */
+		if (t[i].type == SDR_THRESHREL)
+		    /*
+		     * A threshold value, like hysteresis.  It's not
+		     * an absolute value, it's a relative value, so we
+		     * leave "b" out of the equation.  Note that this
+		     * only works for linear equations.
+		     */
+		    fx = (((fval / pow(10, r_exp))) / ((double) m));
+		else
+		    fx = (((fval / pow(10, r_exp))
+			   - ((double) b) * pow(10, b_exp))
+			  / ((double) m));
+
+		/*
+		 * We always round here.  This means that a threshold
+		 * may be set that is on the "wrong side" of the
+		 * threshold, and the trigger may too sensitive.  Or
+		 * perhaps insensitive.  Of course, that can happen
+		 * without rounding, too.  There appears to be no easy
+		 * way to second-guess the user of this program and,
+		 * given a floating point value, figure out the proper
+		 * integer value they want. Instead, they are expected
+		 * to give a floating point value that will evaluate
+		 * very closely to the integer they want.  Rounding
+		 * should handle the issue of getting it right on the
+		 * integer value the user wants and avoid issues with
+		 * floating point imprecision.
+		 */
+		fx = round(fx);
 
 		if (fx < 0.0 || fx > 255.0) {
 		    err = -1;
@@ -1674,9 +1710,9 @@ main(int argc, char *argv[])
 	help();
     }
 
-    f = fopen(argv[1], "r");
+    f = fopen(argv[argn], "r");
     if (!f) {
-	fprintf(stderr, "Unable to open input file %s\n", argv[1]);
+	fprintf(stderr, "Unable to open input file %s\n", argv[argn]);
 	exit(1);
     }
 
@@ -1688,7 +1724,7 @@ main(int argc, char *argv[])
 	}
     }
 
-    parse_file(argv[1], f, p, outraw, &sdrnum);
+    parse_file(argv[argn], f, p, outraw, &sdrnum);
 
     fclose(f);
 
diff --git a/lanserv/serial_ipmi.c b/lanserv/serial_ipmi.c
index 9a1806c..792ba3d 100644
--- a/lanserv/serial_ipmi.c
+++ b/lanserv/serial_ipmi.c
@@ -63,6 +63,7 @@
 #include <OpenIPMI/ipmi_mc.h>
 #include <OpenIPMI/ipmi_msgbits.h>
 #include <OpenIPMI/serserv.h>
+#include <config.h>
 
 #define EVENT_BUFFER_GLOBAL_ENABLE	(1 << 2)
 #define EVENT_LOG_GLOBAL_ENABLE		(1 << 3)
@@ -745,7 +746,8 @@ tm_setup(serserv_data_t *si)
 #define   VM_CAPABILITIES_IRQ	0x04
 #define   VM_CAPABILITIES_NMI	0x08
 #define   VM_CAPABILITIES_ATTN	0x10
-#define VM_CMD_FORCEOFF		0x09
+#define   VM_CAPABILITIES_GRACEFUL_SHUTDOWN 0x20
+#define VM_CMD_GRACEFUL_SHUTDOWN 0x09
 
 struct vm_data {
     unsigned char recv_msg[IPMI_SIM_MAX_MSG_LENGTH + 4];
@@ -806,6 +808,8 @@ vm_handle_cmd(unsigned char *imsg, unsigned int len, serserv_data_t *si)
 	    return;
 	if (imsg[1] & VM_CAPABILITIES_POWER)
 	    si->channel.hw_capabilities |= (1 << HW_OP_POWERON);
+	if (imsg[1] & VM_CAPABILITIES_GRACEFUL_SHUTDOWN)
+	    si->channel.hw_capabilities |= (1 << HW_OP_GRACEFUL_SHUTDOWN);
 	if (imsg[1] & VM_CAPABILITIES_RESET)
 	    si->channel.hw_capabilities |= (1 << HW_OP_RESET);
 	if (imsg[1] & VM_CAPABILITIES_IRQ)
@@ -961,9 +965,9 @@ vm_hw_op(channel_t *chan, unsigned int op)
 	    chan->stop_cmd(chan, !si->connected);
 	break;
 	
-    case HW_OP_FORCEOFF:
+    case HW_OP_GRACEFUL_SHUTDOWN:
 	if (si->connected)
-	    vm_add_char(VM_CMD_FORCEOFF, c, &len);
+	    vm_add_char(VM_CMD_GRACEFUL_SHUTDOWN, c, &len);
 	break;
 	
     case HW_OP_SEND_NMI:
@@ -1027,6 +1031,115 @@ vm_setup(serserv_data_t *si)
     return 0;
 }
 
+#ifdef MLX_IPMID
+/***********************************************************************
+ *
+ * BT Mode codec.
+ *
+ ***********************************************************************/
+
+/*
+ * Messages are normal IPMI messages with the following header:
+ *
+ *   len
+ *   netfn << 2 | lun
+ *   seq
+ *   cmd
+ *   data....
+ *
+ */
+
+struct bt_data {
+    unsigned char recv_msg[IPMI_SIM_MAX_MSG_LENGTH + 4];
+    unsigned int  recv_msg_len;
+    int           recv_msg_too_many;
+};
+
+static void
+bt_handle_msg(unsigned char *imsg, unsigned int len, serserv_data_t *si)
+{
+    msg_t msg;
+
+    if (si->sysinfo->debug & DEBUG_RAW_MSG)
+	debug_log_raw_msg(si->sysinfo, imsg, len, "Raw serial receive:");
+
+    if (len < 4) {
+	fprintf(stderr, "Message too short\n");
+	return;
+    }
+    len--;
+    imsg++;
+
+    memset(&msg, 0, sizeof(msg));
+
+    msg.netfn = imsg[0] >> 2;
+    msg.rs_lun = imsg[0] & 0x3;
+    msg.rq_seq = imsg[1];
+    msg.cmd = imsg[2];
+    msg.len = len - 3;
+    msg.data = imsg + 3;
+    msg.src_addr = NULL;
+	msg.src_len = 0;
+
+    channel_smi_send(&si->channel, &msg);
+}
+
+static void
+bt_handle_char(unsigned char ch, serserv_data_t *si)
+{
+    struct bt_data *info = si->codec_info;
+    unsigned int len = info->recv_msg_len;
+
+    if (si->bind_fd == 0) {
+        if (info->recv_msg_len != 0){
+            bt_handle_msg(info->recv_msg, info->recv_msg_len, si);
+            info->recv_msg_len = 0;
+        }
+        return;
+    }
+
+	if(len >= sizeof(info->recv_msg))
+        return;
+
+    info->recv_msg[len] = ch;
+    info->recv_msg_len++;
+}
+
+static void
+bt_send(msg_t *imsg, serserv_data_t *si)
+{
+    unsigned int i;
+    unsigned char buf[IPMI_SIM_MAX_MSG_LENGTH + 4];
+
+	buf[0] = imsg->len+3;
+	buf[1] = (imsg->netfn << 2) | imsg->rs_lun;
+	buf[2] = imsg->rq_seq;
+	buf[3] = imsg->cmd;
+
+    for (i = 0; i < imsg->len; i++)
+		buf[i+4] = imsg->data[i];
+
+    raw_send(si, buf, imsg->len+4);
+}
+
+static int
+bt_setup(serserv_data_t *si)
+{
+    struct bt_data *info;
+
+    info = malloc(sizeof(*info));
+    if (!info)
+	return -1;
+    memset(info, 0, sizeof(*info));
+    si->channel.set_atn = handle_attn;
+    si->codec_info = info;
+    si->connected = 1;
+    si->channel.hw_capabilities |= (1 << HW_OP_POWERON);
+    si->channel.hw_capabilities |= (1 << HW_OP_RESET);
+    return 0;
+}
+#endif
+
 
 /***********************************************************************
  *
@@ -1042,6 +1155,10 @@ static ser_codec_t codecs[] = {
       ra_handle_char, ra_send, ra_setup },
     { "VM",
       vm_handle_char, vm_send, vm_setup, vm_connected, vm_disconnected },
+#ifdef MLX_IPMID
+    { "BT_Mode",
+      bt_handle_char, bt_send, bt_setup },
+#endif
     { NULL }
 };
 
diff --git a/lanserv/sol.c b/lanserv/sol.c
index 2a6afb3..778a6fc 100644
--- a/lanserv/sol.c
+++ b/lanserv/sol.c
@@ -45,6 +45,7 @@
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 
+#include <config.h>
 #include <OpenIPMI/serv.h>
 #include <OpenIPMI/mcserv.h>
 #include <OpenIPMI/lanserv.h>
@@ -574,9 +575,10 @@ sol_tcp_initialize(ipmi_sol_t *sol)
     if (rv == -1) {
 	close(sd->fd);
 	sd->fd = -1;
-	sd->logchan->log(sd->logchan, OS_ERROR, NULL,
-			 "Error connecting tcp sol port socket for %s:%s: %s",
-			 sol->tcpdest, sol->tcpport, strerror(errno));
+	if (sd->sys->debug & DEBUG_SOL)
+	    sd->logchan->log(sd->logchan, OS_ERROR, NULL,
+			   "Error connecting tcp sol port socket for %s:%s: %s",
+			   sol->tcpdest, sol->tcpport, strerror(errno));
 	goto out;
     }
 
@@ -899,6 +901,12 @@ ipmi_sol_activate(lmc_data_t    *mc,
     ipmi_set_uint16(rdata + 9, port);
     ipmi_set_uint16(rdata + 11, 0xffff);
     *rdata_len = 13;
+
+#ifdef MLX_IPMID
+/*Uart to BMC*/
+	if (instance == 1)
+		system("echo 0 > /bsp/reset/uart_sel");
+#endif
 }
 
 void
@@ -939,6 +947,12 @@ ipmi_sol_deactivate(lmc_data_t    *mc,
 
     rdata[0] = 0;
     *rdata_len = 1;
+
+#ifdef MLX_IPMID
+/*Uart to CPU*/
+	if (instance == 1)
+		system("echo 1 > /bsp/reset/uart_sel");
+#endif
 }
 
 static void
diff --git a/lib/aes_cbc.c b/lib/aes_cbc.c
index 483cdfb..f20d69b 100644
--- a/lib/aes_cbc.c
+++ b/lib/aes_cbc.c
@@ -86,7 +86,7 @@ aes_cbc_encrypt(ipmi_con_t    *ipmi,
     unsigned int   l = *payload_len;
     unsigned int   i;
     unsigned char  *d;
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx;
     int            rv;
     int            outlen;
     int            tmplen;
@@ -133,15 +133,19 @@ aes_cbc_encrypt(ipmi_con_t    *ipmi,
     *header_len -= 16;
     *max_payload_len += 16;
 
+    ctx = EVP_CIPHER_CTX_new();
+    if (!ctx) {
+	    rv = ENOMEM;
+	    goto out_cleanup;
+    }
     /* Ok, we're set to do the crypt operation. */
-    EVP_CIPHER_CTX_init(&ctx);
-    EVP_EncryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL, info->k2, iv);
-    EVP_CIPHER_CTX_set_padding(&ctx, 0);
-    if (!EVP_EncryptUpdate(&ctx, *payload, &outlen, d, l)) {
+    EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, info->k2, iv);
+    EVP_CIPHER_CTX_set_padding(ctx, 0);
+    if (!EVP_EncryptUpdate(ctx, *payload, &outlen, d, l)) {
 	rv = ENOMEM; /* right? */
 	goto out_cleanup;
     }
-    if (!EVP_EncryptFinal_ex(&ctx, (*payload) + outlen, &tmplen)) {
+    if (!EVP_EncryptFinal_ex(ctx, (*payload) + outlen, &tmplen)) {
 	rv = ENOMEM; /* right? */
 	goto out_cleanup;
     }
@@ -154,7 +158,7 @@ aes_cbc_encrypt(ipmi_con_t    *ipmi,
     *payload_len = outlen + 16;
 
  out_cleanup:
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_free(ctx);
     ipmi_mem_free(d);
 
     return rv;
@@ -170,7 +174,7 @@ aes_cbc_decrypt(ipmi_con_t    *ipmi,
     unsigned int   l = *payload_len;
     unsigned char  *d;
     unsigned char  *p;
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx;
     int            outlen;
     int            rv = 0;
     unsigned char  *pad;
@@ -195,10 +199,14 @@ aes_cbc_decrypt(ipmi_con_t    *ipmi,
     memcpy(d, p, l);
 
     /* Ok, we're set to do the decrypt operation. */
-    EVP_CIPHER_CTX_init(&ctx);
-    EVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL, info->k2, *payload);
-    EVP_CIPHER_CTX_set_padding(&ctx, 0);
-    if (!EVP_DecryptUpdate(&ctx, p, &outlen, d, l)) {
+    ctx = EVP_CIPHER_CTX_new();
+    if (!ctx) {
+	    rv = ENOMEM;
+	    goto out_cleanup;
+    }
+    EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, info->k2, *payload);
+    EVP_CIPHER_CTX_set_padding(ctx, 0);
+    if (!EVP_DecryptUpdate(ctx, p, &outlen, d, l)) {
 	rv = EINVAL;
 	goto out_cleanup;
     }
@@ -231,7 +239,7 @@ aes_cbc_decrypt(ipmi_con_t    *ipmi,
     *payload_len = outlen;
 
  out_cleanup:
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_free(ctx);
     ipmi_mem_free(d);
     return rv;
 }
diff --git a/m4/.gitignore b/m4/.gitignore
new file mode 100644
index 0000000..464ba5c
--- /dev/null
+++ b/m4/.gitignore
@@ -0,0 +1,5 @@
+libtool.m4
+lt~obsolete.m4
+ltoptions.m4
+ltsugar.m4
+ltversion.m4
diff --git a/m4/ax_config_feature.m4 b/m4/ax_config_feature.m4
new file mode 100644
index 0000000..e205723
--- /dev/null
+++ b/m4/ax_config_feature.m4
@@ -0,0 +1,156 @@
+# ===========================================================================
+#     http://www.gnu.org/software/autoconf-archive/ax_config_feature.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CONFIG_FEATURE(FEATURE-NAME, FEATURE-DESCRIPTION, DEFINE, DEFINE-DESCRIPTION, [ACTION-IF-ENABLED [, ACTION-IF-NOT-ENABLED]])
+#
+# DESCRIPTION
+#
+#   AX_CONFIG_FEATURE is a simple wrapper for AC_ARG_ENABLE, it enables the
+#   feature FEATURE-NAME and AC_DEFINEs the passed DEFINE, depending on the
+#   user choice. DESCRIPTION will be used for AC_DEFINEs. ACTION-IF-ENABLED
+#   and ACTION-IF-NOT-ENABLED are the actions that will be run. A feature is
+#   enabled by default, in order to change this behaviour use the
+#   AX_CONFIG_FEATURE_DEFAULT_ENABLED and AX_CONFIG_FEATURE_DEFAULT_DISABLED
+#   macros.
+#
+#   A simple example:
+#
+#     AX_CONFIG_FEATURE_DEFAULT_ENABLED
+#     AX_CONFIG_FEATURE(feature_xxxxx, [turns on/off XXXXX support],
+#                       HAVE_XXXXX, [Define if you want XXXXX support])
+#
+#     ...
+#
+#     AX_CONFIG_FEATURE_DEFAULT_DISABLED
+#     AX_CONFIG_FEATURE(feature_yyyyy, [turns on/off YYYYY support],
+#                       HAVE_YYYYY, [Define if you want YYYYY support],
+#                       [enable_yyyyy="yes"], [enable_yyyyy="no"])
+#     AM_CONDITIONAL(YYYYY, [test "$enable_yyyyy" = "yes"])
+#
+#     AX_CONFIG_FEATURE_DEFAULT_ENABLED
+#     AX_CONFIG_FEATURE(...)
+#
+#     ...
+#
+#   If you have lot of features and you want a verbose dumping of each user
+#   selection use AX_CONFIG_FEATURE_VERBOSE. Use AX_CONFIG_FEATURE_SILENT in
+#   order to remove a previously AX_CONFIG_FEATURE_VERBOSE. By default
+#   features are silent.
+#
+#   Use AX_CONFIG_FEATURE_ENABLE or AX_CONFIG_FEATURE_DISABLE in order to
+#   enable or disable a specific feature.
+#
+#   Another simple example:
+#
+#     AS_IF([some_test_here],[AX_CONFIG_FEATURE_ENABLE(feature_xxxxx)],[])
+#
+#     AX_CONFIG_FEATURE(feature_xxxxx, [turns on/off XXXXX support],
+#                       HAVE_XXXXX, [Define if you want XXXXX support])
+#     AX_CONFIG_FEATURE(feature_yyyyy, [turns on/off YYYYY support],
+#                       HAVE_YYYYY, [Define if you want YYYYY support],
+#                       [enable_yyyyy="yes"], [enable_yyyyy="no"])
+#
+#     ...
+#
+#   NOTE: AX_CONFIG_FEATURE_ENABLE() must be placed first of the relative
+#   AX_CONFIG_FEATURE() macro ...
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Francesco Salvestrini <salvestrini@users.sourceforge.net>
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation; either version 2 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 10
+
+AC_DEFUN([AX_CONFIG_FEATURE],[ dnl
+m4_pushdef([FEATURE], patsubst([$1], -, _))dnl
+
+AC_ARG_ENABLE([$1],AS_HELP_STRING([--enable-$1],[$2]),[
+case "${enableval}" in
+   yes)
+     ax_config_feature_[]FEATURE[]="yes"
+     ;;
+   no)
+     ax_config_feature_[]FEATURE[]="no"
+     ;;
+   *)
+     AC_MSG_ERROR([bad value ${enableval} for feature --$1])
+     ;;
+esac
+])
+
+AS_IF([test "$ax_config_feature_[]FEATURE[]" = yes],[ dnl
+  AC_DEFINE([$3])
+  $5
+  AS_IF([test "$ax_config_feature_verbose" = yes],[ dnl
+    AC_MSG_NOTICE([Feature $1 is enabled])
+  ])
+],[ dnl
+  $6
+  AS_IF([test "$ax_config_feature_verbose" = yes],[ dnl
+    AC_MSG_NOTICE([Feature $1 is disabled])
+  ])
+])
+
+AH_TEMPLATE([$3],[$4])
+
+m4_popdef([FEATURE])dnl
+])
+
+dnl Feature global
+AC_DEFUN([AX_CONFIG_FEATURE_VERBOSE],[ dnl
+  ax_config_feature_verbose=yes
+])
+
+dnl Feature global
+AC_DEFUN([AX_CONFIG_FEATURE_SILENT],[ dnl
+  ax_config_feature_verbose=no
+])
+
+dnl Feature specific
+AC_DEFUN([AX_CONFIG_FEATURE_DEFAULT_ENABLED], [
+  ax_config_feature_[]FEATURE[]_default=yes
+])
+
+dnl Feature specific
+AC_DEFUN([AX_CONFIG_FEATURE_DEFAULT_DISABLED], [
+  ax_config_feature_[]FEATURE[]_default=no
+])
+
+dnl Feature specific
+AC_DEFUN([AX_CONFIG_FEATURE_ENABLE],[ dnl
+  ax_config_feature_[]patsubst([$1], -, _)[]=yes
+])
+
+dnl Feature specific
+AC_DEFUN([AX_CONFIG_FEATURE_DISABLE],[ dnl
+  ax_config_feature_[]patsubst([$1], -, _)[]=no
+])
diff --git a/m4/ax_have_epoll.m4 b/m4/ax_have_epoll.m4
new file mode 100644
index 0000000..07ceb49
--- /dev/null
+++ b/m4/ax_have_epoll.m4
@@ -0,0 +1,104 @@
+# ===========================================================================
+#       http://www.gnu.org/software/autoconf-archive/ax_have_epoll.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_HAVE_EPOLL([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+#   AX_HAVE_EPOLL_PWAIT([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+#
+# DESCRIPTION
+#
+#   This macro determines whether the system supports the epoll I/O event
+#   interface. A neat usage example would be:
+#
+#     AX_HAVE_EPOLL(
+#       [AX_CONFIG_FEATURE_ENABLE(epoll)],
+#       [AX_CONFIG_FEATURE_DISABLE(epoll)])
+#     AX_CONFIG_FEATURE(
+#       [epoll], [This platform supports epoll(7)],
+#       [HAVE_EPOLL], [This platform supports epoll(7).])
+#
+#   The epoll interface was added to the Linux kernel in version 2.5.45, and
+#   the macro verifies that a kernel newer than this is installed. This
+#   check is somewhat unreliable if <linux/version.h> doesn't match the
+#   running kernel, but it is necessary regardless, because glibc comes with
+#   stubs for the epoll_create(), epoll_wait(), etc. that allow programs to
+#   compile and link even if the kernel is too old; the problem would then
+#   be detected only at runtime.
+#
+#   Linux kernel version 2.6.19 adds the epoll_pwait() call in addition to
+#   epoll_wait(). The availability of that function can be tested with the
+#   second macro. Generally speaking, it is safe to assume that
+#   AX_HAVE_EPOLL would succeed if AX_HAVE_EPOLL_PWAIT has, but not the
+#   other way round.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Peter Simons <simons@cryp.to>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 10
+
+AC_DEFUN([AX_HAVE_EPOLL], [dnl
+  ax_have_epoll_cppflags="${CPPFLAGS}"
+  AC_CHECK_HEADER([linux/version.h], [CPPFLAGS="${CPPFLAGS} -DHAVE_LINUX_VERSION_H"])
+  AC_MSG_CHECKING([for Linux epoll(7) interface])
+  AC_CACHE_VAL([ax_cv_have_epoll], [dnl
+    AC_LINK_IFELSE([dnl
+      AC_LANG_PROGRAM([dnl
+#include <sys/epoll.h>
+#ifdef HAVE_LINUX_VERSION_H
+#  include <linux/version.h>
+#  if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,45)
+#    error linux kernel version is too old to have epoll
+#  endif
+#endif
+], [dnl
+int fd, rc;
+struct epoll_event ev;
+fd = epoll_create(128);
+rc = epoll_wait(fd, &ev, 1, 0);])],
+      [ax_cv_have_epoll=yes],
+      [ax_cv_have_epoll=no])])
+  CPPFLAGS="${ax_have_epoll_cppflags}"
+  AS_IF([test "${ax_cv_have_epoll}" = "yes"],
+    [AC_MSG_RESULT([yes])
+$1],[AC_MSG_RESULT([no])
+$2])
+])dnl
+
+AC_DEFUN([AX_HAVE_EPOLL_PWAIT], [dnl
+  ax_have_epoll_cppflags="${CPPFLAGS}"
+  AC_CHECK_HEADER([linux/version.h],
+    [CPPFLAGS="${CPPFLAGS} -DHAVE_LINUX_VERSION_H"])
+  AC_MSG_CHECKING([for Linux epoll(7) interface with signals extension])
+  AC_CACHE_VAL([ax_cv_have_epoll_pwait], [dnl
+    AC_LINK_IFELSE([dnl
+      AC_LANG_PROGRAM([dnl
+#ifdef HAVE_LINUX_VERSION_H
+#  include <linux/version.h>
+#  if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#    error linux kernel version is too old to have epoll_pwait
+#  endif
+#endif
+#include <sys/epoll.h>
+#include <signal.h>
+], [dnl
+int fd, rc;
+struct epoll_event ev;
+fd = epoll_create(128);
+rc = epoll_wait(fd, &ev, 1, 0);
+rc = epoll_pwait(fd, &ev, 1, 0, (sigset_t const *)(0));])],
+      [ax_cv_have_epoll_pwait=yes],
+      [ax_cv_have_epoll_pwait=no])])
+  CPPFLAGS="${ax_have_epoll_cppflags}"
+  AS_IF([test "${ax_cv_have_epoll_pwait}" = "yes"],
+    [AC_MSG_RESULT([yes])
+$1],[AC_MSG_RESULT([no])
+$2])
+])dnl
diff --git a/sample/ipmicmd.c b/sample/ipmicmd.c
index 9f51273..6cbcdc5 100644
--- a/sample/ipmicmd.c
+++ b/sample/ipmicmd.c
@@ -676,7 +676,11 @@ main(int argc, char *argv[])
     }
 
     /* Create selector with os handler. */
-    sel_alloc_selector(os_hnd, &sel);
+    rv = sel_alloc_selector_nothread(&sel);
+    if (rv) {
+	fprintf(stderr, "Error allocating selector: 0x%x\n", rv);
+	exit(1);
+    }
 
     /* The OS handler has to know about the selector. */
     ipmi_posix_os_handler_set_sel(os_hnd, sel);
diff --git a/sample/sample2.c b/sample/sample2.c
index 3b1f948..b6fe251 100644
--- a/sample/sample2.c
+++ b/sample/sample2.c
@@ -281,15 +281,6 @@ main(int argc, char *argv[])
 
     progname = argv[0];
 
-    if (argc < 4) {
-	usage();
-	exit(1);
-    }
-
-    entity_id = strtoul(argv[1], NULL, 10);
-    entity_instance = strtoul(argv[2], NULL, 10);
-    control_name = argv[3];
-
     /* OS handler allocated first. */
     os_hnd = ipmi_posix_thread_setup_os_handler(SIGUSR1);
     if (!os_hnd) {
@@ -302,6 +293,15 @@ main(int argc, char *argv[])
     /* Initialize the OpenIPMI library. */
     ipmi_init(os_hnd);
 
+    if (argc < 4) {
+	usage();
+	exit(1);
+    }
+
+    entity_id = strtoul(argv[1], NULL, 10);
+    entity_instance = strtoul(argv[2], NULL, 10);
+    control_name = argv[3];
+
     rv = ipmi_parse_args2(&curr_arg, argc, argv, &args);
     if (rv) {
 	fprintf(stderr, "Error parsing command arguments, argument %d: %s\n",
diff --git a/ui/basic_ui.c b/ui/basic_ui.c
index 3f0d0a1..cf5e8cd 100644
--- a/ui/basic_ui.c
+++ b/ui/basic_ui.c
@@ -62,6 +62,8 @@
 # endif
 #endif
 
+extern selector_t *ui_sel;
+
 /* This is here because the POSIX library requires it, but we only
    pull the posix library to get the selector code, so this is not
    used. */
@@ -147,37 +149,119 @@ snmp_pre_parse(struct snmp_session *session, snmp_ipaddr from)
 
 struct snmp_session *snmp_session;
 
-void snmp_add_read_fds(selector_t     *sel,
-		       int            *num_fds,
-		       fd_set         *fdset,
-		       struct timeval *timeout,
-		       int            *timeout_invalid,
-		       void           *cb_data)
-{
-    snmp_select_info(num_fds, fdset, timeout, timeout_invalid);
-}
+struct snmp_fd_data {
+    int fd;
+    os_hnd_fd_id_t *id;
+    struct snmp_fd_data *next;
+};
+
+static struct snmp_fd_data *snmpfd = NULL;
+os_hnd_timer_id_t *snmp_timer = NULL;
 
-void snmp_check_read_fds(selector_t *sel,
-			 fd_set     *fds,
-			 void       *cb_data)
+static void
+snmp_check_read_fds(int fd, void *cb_data, os_hnd_fd_id_t *id)
 {
-    snmp_read(fds);
+    fd_set fdset;
+
+    FD_ZERO(&fdset);
+    FD_SET(fd, &fdset);
+    snmp_read(&fdset);
 }
 
-void snmp_check_timeout(selector_t *sel,
-			void       *cb_data)
+static void
+snmp_check_timeout(void *cb_data, os_hnd_timer_id_t *id)
 {
     snmp_timeout();
 }
 
+static void
+snmp_setup_fds(os_handler_t *os_hnd)
+{
+    int nfds = 0, block = 0, i, rv;
+    fd_set fdset;
+    struct timeval tv;
+    struct snmp_fd_data *fdd, *nfdd, *prev = NULL;
+
+    FD_ZERO(&fdset);
+    tv.tv_sec = 0;
+    tv.tv_usec = 0;
+    snmp_select_info(&nfds, &fdset, &tv, &block);
+
+    /* Run through the list.  Since the list is kept sorted, we only
+       need one pass. */
+    fdd = snmpfd;
+    for (i = 0; i < nfds; i++) {
+	if (!FD_ISSET(i, &fdset))
+	    continue;
+
+	if (fdd) {
+	    if (fdd->fd == i) {
+		/* Didn't change. */
+		prev = fdd;
+		fdd = fdd->next;
+		continue;
+	    }
+	    if (fdd->fd < i) {
+		/* Current one was deleted. */
+		os_hnd->remove_fd_to_wait_for(os_hnd, fdd->id);
+		if (prev)
+		    prev->next = fdd->next;
+		else
+		    snmpfd = fdd->next;
+		os_hnd->mem_free(fdd);
+		continue;
+	    }
+	}
+
+	/* New one to add. */
+	nfdd = os_hnd->mem_alloc(sizeof(*fdd));
+	if (!nfdd) {
+	    rv = ENOMEM;
+	    goto err;
+	}
+	nfdd->fd = i;
+	rv = os_hnd->add_fd_to_wait_for(os_hnd, i, snmp_check_read_fds,
+					NULL, NULL, &nfdd->id);
+	if (rv)
+	    goto err;
+
+	/* Insert after */
+	if (fdd) {
+	    nfdd->next = fdd->next;
+	    fdd->next = nfdd;
+	} else {
+	    nfdd->next = NULL;
+	    snmpfd = fdd;
+	}
+    }
+
+    if (!block) {
+	os_hnd->stop_timer(os_hnd, snmp_timer);
+    } else {
+	os_hnd->stop_timer(os_hnd, snmp_timer);
+	os_hnd->start_timer(os_hnd, snmp_timer, &tv, snmp_check_timeout, NULL);
+    }
+    return;
+
+ err:
+    fprintf(stderr, "Error handling SNMP fd data: %s\n", strerror(rv));
+    exit(1);
+}
 
 int
-snmp_init(selector_t *sel)
+snmp_init(os_handler_t *os_hnd)
 {
     struct snmp_session session;
 #ifdef HAVE_NETSNMP
     netsnmp_transport *transport = NULL;
     static char *snmp_default_port = "udp:162";
+    int rv;
+
+    rv = os_hnd->alloc_timer(os_hnd, &snmp_timer);
+    if (rv) {
+	fprintf(stderr, "Could not allocate SNMP timer\n");
+	return -1;
+    }
 
     netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID,
 			   NETSNMP_DS_LIB_MIB_ERRORS,
@@ -216,14 +300,10 @@ snmp_init(selector_t *sel)
 	return -1;
     }
 
-    ipmi_sel_set_read_fds_handler(sel,
-				  snmp_add_read_fds,
-				  snmp_check_read_fds,
-				  snmp_check_timeout,
-				  NULL);
-
     return 0;
 }
+#else
+static void snmp_setup_fds(os_handler_t *os_hnd) { }
 #endif /* HAVE_UCDSNMP */
     
 int
@@ -241,9 +321,6 @@ main(int argc, char *argv[])
     ipmi_args_t      *con_parms[2];
     ipmi_con_t       *con[2];
     int              last_con = 0;
-    selector_t       *selector;
-
-
 
     while ((curr_arg < argc) && (argv[curr_arg][0] == '-')) {
 	arg = argv[curr_arg];
@@ -270,11 +347,17 @@ main(int argc, char *argv[])
 	}
     }
 
-    rv = ipmi_ui_init(&selector, full_screen);
+    rv = sel_alloc_selector_nothread(&ui_sel);
+    if (rv) {
+	fprintf(stderr, "Could not allocate selector\n");
+	exit(1);
+    }
+
+    rv = ipmi_ui_init(&ipmi_ui_cb_handlers, full_screen);
 
 #ifdef HAVE_UCDSNMP
     if (init_snmp) {
-	if (snmp_init(selector) < 0)
+	if (snmp_init(&ipmi_ui_cb_handlers) < 0)
 	    goto out;
     }
 #endif
@@ -300,7 +383,7 @@ main(int argc, char *argv[])
     for (i=0; i<last_con; i++) {
 	rv = ipmi_args_setup_con(con_parms[i],
 				 &ipmi_ui_cb_handlers,
-				 selector,
+				 NULL,
 				 &con[i]);
 	if (rv) {
 	    fprintf(stderr, "ipmi_ip_setup_con: %s", strerror(rv));
@@ -318,7 +401,11 @@ main(int argc, char *argv[])
 	goto out;
     }
 
-    sel_select_loop(selector, NULL, 0, NULL);
+    for (;;) {
+      if (init_snmp)
+	  snmp_setup_fds(&ipmi_ui_cb_handlers);
+      ipmi_ui_cb_handlers.perform_one_op(&ipmi_ui_cb_handlers, NULL);
+    }
 
  out:
     ipmi_ui_shutdown();
diff --git a/ui/ui.c b/ui/ui.c
index 8dcb41d..a9f6dd2 100644
--- a/ui/ui.c
+++ b/ui/ui.c
@@ -44,7 +44,6 @@
 #include <sys/time.h>
 #include <ctype.h>
 
-#include <OpenIPMI/selector.h>
 #include <OpenIPMI/ipmi_err.h>
 #include <OpenIPMI/ipmi_msgbits.h>
 #include <OpenIPMI/ipmi_mc.h>
@@ -71,8 +70,6 @@ WINDOW *log_pad;
 WINDOW *dummy_pad;
 WINDOW *display_pad;
 
-selector_t *ui_sel;
-
 int log_pad_top_line;
 int display_pad_top_line;
 
@@ -81,7 +78,7 @@ command_t commands;
 
 ipmi_domain_id_t domain_id;
 
-extern os_handler_t ipmi_ui_cb_handlers;
+os_handler_t *ipmi_ui_os_hnd;
 ipmi_pef_t *pef;
 ipmi_pef_config_t *pef_config;
 ipmi_lanparm_t *lanparm;
@@ -157,7 +154,7 @@ static char *line_buffer = NULL;
 static int  line_buffer_max = 0;
 static int  line_buffer_pos = 0;
 
-sel_timer_t *redisplay_timer;
+os_hnd_timer_id_t *redisplay_timer;
 
 static void
 conv_from_spaces(char *name)
@@ -427,7 +424,7 @@ ui_vlog(const char *format, enum ipmi_log_type_e log_type, va_list ap)
     int do_nl = 1;
     struct timeval now;
 
-    ipmi_ui_cb_handlers.get_real_time(&ipmi_ui_cb_handlers, &now);
+    ipmi_ui_os_hnd->get_real_time(ipmi_ui_os_hnd, &now);
 
     if (full_screen) {
 	int x = 0, y = 0, old_x = 0, old_y = 0;
@@ -557,7 +554,7 @@ ui_log(char *format, ...)
     struct timeval now;
     va_list ap;
 
-    ipmi_ui_cb_handlers.get_real_time(&ipmi_ui_cb_handlers, &now);
+    ipmi_ui_os_hnd->get_real_time(ipmi_ui_os_hnd, &now);
 
     va_start(ap, format);
 
@@ -586,8 +583,8 @@ leave(int rv, char *format, ...)
 
     ipmi_shutdown();
 
-    sel_stop_timer(redisplay_timer);
-    sel_free_timer(redisplay_timer);
+    ipmi_ui_os_hnd->stop_timer(ipmi_ui_os_hnd, redisplay_timer);
+    ipmi_ui_os_hnd->free_timer(ipmi_ui_os_hnd, redisplay_timer);
 
     if (full_screen) {
 	endwin();
@@ -621,7 +618,7 @@ leave(int rv, char *format, ...)
     command_free(commands);
     keypad_free(keymap);
 
-    sel_free_selector(ui_sel);
+    ipmi_ui_os_hnd->free_os_handler(ipmi_ui_os_hnd);
 
     va_start(ap, format);
     vfprintf(stderr, format, ap);
@@ -643,7 +640,7 @@ leave_err(int err, char *format, ...)
 	fcntl(0, F_SETFL, old_flags);
 	tcdrain(0);
     }
-    sel_free_selector(ui_sel);
+    ipmi_ui_os_hnd->free_os_handler(ipmi_ui_os_hnd);
 
     va_start(ap, format);
     vfprintf(stderr, format, ap);
@@ -694,7 +691,7 @@ void handle_user_char(int c)
 }
 
 void
-user_input_ready(int fd, void *data)
+user_input_ready(int fd, void *data, os_hnd_fd_id_t *id)
 {
     int c;
 
@@ -5566,7 +5563,7 @@ addevent_cmd(char *cmd, char **toks, void *cb_data)
 	    return 0;
     }
 
-    ipmi_ui_cb_handlers.get_monotonic_time(&ipmi_ui_cb_handlers, &time);
+    ipmi_ui_os_hnd->get_monotonic_time(ipmi_ui_os_hnd, &time);
     info.timestamp = time.tv_sec * 1000000000;
 
     rv = ipmi_mc_pointer_noseq_cb(info.mc_id, addevent_cmder, &info);
@@ -6158,8 +6155,8 @@ new_domain_cmd(char *cmd, char **toks, void *cb_data)
 
     for (i=0; i<set; i++) {
 	rv = ipmi_args_setup_con(con_parms[i],
-				 &ipmi_ui_cb_handlers,
-				 ui_sel,
+				 ipmi_ui_os_hnd,
+				 NULL,
 				 &con[i]);
 	if (rv) {
 	    cmd_win_out("ipmi_ip_setup_con: %s\n", strerror(rv));
@@ -6962,9 +6959,7 @@ event_handler(ipmi_domain_t *domain,
 }
 
 static void
-redisplay_timeout(selector_t  *sel,
-		  sel_timer_t *timer,
-		  void        *data)
+redisplay_timeout(void *cb_data, os_hnd_timer_id_t *id)
 {
     struct timeval now;
     int            rv;
@@ -6989,9 +6984,10 @@ redisplay_timeout(selector_t  *sel,
 		   rv);
     }
 
-    ipmi_ui_cb_handlers.get_monotonic_time(&ipmi_ui_cb_handlers, &now);
+    ipmi_ui_os_hnd->get_monotonic_time(ipmi_ui_os_hnd, &now);
     now.tv_sec += 1;
-    rv = sel_start_timer(timer, &now);
+    rv = ipmi_ui_os_hnd->start_timer(ipmi_ui_os_hnd, id, &now,
+				     redisplay_timeout, NULL);
     if (rv)
 	ui_log("Unable to restart redisplay timer: 0x%x\n", rv);
 }
@@ -7050,24 +7046,26 @@ ipmi_ui_domain_ready(ipmi_domain_t *domain,
 {
 }
 
+os_hnd_fd_id_t *user_input_id;
+
 int
-ipmi_ui_init(selector_t **selector, int do_full_screen)
+ipmi_ui_init(os_handler_t *os_hnd, int do_full_screen)
 {
     int rv;
 
     full_screen = do_full_screen;
 
-    ipmi_init(&ipmi_ui_cb_handlers);
+    ipmi_ui_os_hnd = os_hnd;
+
+    ipmi_init(ipmi_ui_os_hnd);
 
-    rv = sel_alloc_selector(&ipmi_ui_cb_handlers, &ui_sel);
+    rv = os_hnd->add_fd_to_wait_for(os_hnd, 0, user_input_ready, NULL, NULL,
+				    &user_input_id);
     if (rv) {
-	fprintf(stderr, "Could not allocate selector\n");
+        fprintf(stderr, "Could not add stdin waiter: %s\n", strerror(rv));
 	exit(1);
     }
 
-    sel_set_fd_handlers(ui_sel, 0, NULL, user_input_ready, NULL, NULL, NULL);
-    sel_set_fd_read_handler(ui_sel, 0, SEL_FD_HANDLER_ENABLED);
-
     /* This is a dummy allocation just to make sure that the malloc
        debugger is working. */
     ipmi_mem_alloc(10);
@@ -7127,19 +7125,18 @@ ipmi_ui_init(selector_t **selector, int do_full_screen)
 
     {
 	struct timeval now;
-	rv = sel_alloc_timer(ui_sel, redisplay_timeout, NULL,
-			     &redisplay_timer);
+
+	rv = os_hnd->alloc_timer(os_hnd, &redisplay_timer);
 	if (rv)
 	    leave_err(rv, "sel_alloc_timer");
-	ipmi_ui_cb_handlers.get_monotonic_time(&ipmi_ui_cb_handlers, &now);
+	ipmi_ui_os_hnd->get_monotonic_time(ipmi_ui_os_hnd, &now);
 	now.tv_sec += 1;
-	rv = sel_start_timer(redisplay_timer, &now);
+	rv = os_hnd->start_timer(os_hnd, redisplay_timer, &now,
+				 redisplay_timeout, NULL);
 	if (rv)
 	    leave_err(rv, "Unable to restart redisplay timer");
     }
 
-    *selector = ui_sel;
-
     return 0;
 }
 
diff --git a/ui/ui_os.c b/ui/ui_os.c
index b4d6442..597f79b 100644
--- a/ui/ui_os.c
+++ b/ui/ui_os.c
@@ -45,7 +45,7 @@
 
 #include <OpenIPMI/internal/ipmi_int.h>
 
-extern selector_t *ui_sel;
+selector_t *ui_sel;
 
 #ifdef IPMI_CHECK_LOCKS
 static void check_no_locks(os_handler_t *handler);
@@ -526,6 +526,21 @@ static int get_real_time(os_handler_t *handler,
     return get_posix_time(CLOCK_REALTIME, tv);
 }
 
+static void free_os_handler(os_handler_t *handler)
+{
+    sel_free_selector(ui_sel);
+}
+
+static int perform_one_op(os_handler_t *os_hnd, struct timeval *timeout)
+{
+    int           rv;
+
+    rv = sel_select(ui_sel, NULL, 0, NULL, timeout);
+    if (rv == -1)
+	return errno;
+    return 0;
+}
+
 os_handler_t ipmi_ui_cb_handlers =
 {
     .mem_alloc = ui_malloc,
@@ -536,6 +551,8 @@ os_handler_t ipmi_ui_cb_handlers =
     .stop_timer = stop_timer,
     .alloc_timer = alloc_timer,
     .free_timer = free_timer,
+    .free_os_handler = free_os_handler,
+    .perform_one_op = perform_one_op,
 #ifdef IPMI_CHECK_LOCKS
     .create_lock = create_lock,
     .destroy_lock = destroy_lock,
diff --git a/unix/posix_os_hnd.c b/unix/posix_os_hnd.c
index d15efb9..d359bd9 100644
--- a/unix/posix_os_hnd.c
+++ b/unix/posix_os_hnd.c
@@ -679,7 +679,7 @@ ipmi_posix_setup_os_handler(void)
     if (!os_hnd)
 	return NULL;
 
-    rv = sel_alloc_selector(os_hnd, &sel);
+    rv = sel_alloc_selector_nothread(&sel);
     if (rv) {
 	ipmi_posix_free_os_handler(os_hnd);
 	os_hnd = NULL;
diff --git a/unix/posix_thread_os_hnd.c b/unix/posix_thread_os_hnd.c
index a26fff8..f181161 100644
--- a/unix/posix_thread_os_hnd.c
+++ b/unix/posix_thread_os_hnd.c
@@ -887,7 +887,7 @@ static os_handler_t ipmi_posix_thread_os_handler =
 };
 
 os_handler_t *
-ipmi_posix_thread_get_os_handler(void)
+ipmi_posix_thread_get_os_handler2(int wake_sig)
 {
     os_handler_t     *rv;
     pt_os_hnd_data_t *info;
@@ -918,10 +918,60 @@ ipmi_posix_thread_get_os_handler(void)
     }
 #endif
 
+    info->wake_sig = wake_sig;
+
     return rv;
 }
 
 os_handler_t *
+ipmi_posix_thread_get_os_handler(void)
+{
+    return ipmi_posix_thread_get_os_handler2(0);
+}
+
+struct sel_lock_s
+{
+    os_handler_t *os_hnd;
+    os_hnd_lock_t *lock;
+};
+
+static sel_lock_t *
+slock_alloc(void *cb_data)
+{
+    os_handler_t *os_hnd = cb_data;
+    sel_lock_t *l;
+
+    l = os_hnd->mem_alloc(sizeof(*l));
+    if (!l)
+	return NULL;
+    l->os_hnd = os_hnd;
+    if (os_hnd->create_lock(os_hnd, &l->lock)) {
+	os_hnd->mem_free(l);
+	l = NULL;
+    }
+    return l;
+}
+
+static void
+slock_free(sel_lock_t *l)
+{
+    l->os_hnd->destroy_lock(l->os_hnd, l->lock);
+    l->os_hnd->mem_free(l);
+}
+
+static void
+slock_lock(sel_lock_t *l)
+{
+    l->os_hnd->lock(l->os_hnd, l->lock);
+}
+
+static void
+slock_unlock(sel_lock_t *l)
+{
+    l->os_hnd->unlock(l->os_hnd, l->lock);
+}
+
+os_handler_t *
 ipmi_posix_thread_setup_os_handler(int wake_sig)
 {
     os_handler_t     *os_hnd;
@@ -929,14 +979,15 @@ ipmi_posix_thread_setup_os_handler(int wake_sig)
     struct sigaction act;
     int              rv;
 
-    os_hnd = ipmi_posix_thread_get_os_handler();
+    os_hnd = ipmi_posix_thread_get_os_handler2(wake_sig);
     if (!os_hnd)
 	return NULL;
 
     info = os_hnd->internal_data;
-    info->wake_sig = wake_sig;
 
-    rv = sel_alloc_selector(os_hnd, &info->sel);
+    rv = sel_alloc_selector_thread(&info->sel, wake_sig,
+				   slock_alloc, slock_free,
+				   slock_lock, slock_unlock, os_hnd);
     if (rv) {
 	ipmi_posix_thread_free_os_handler(os_hnd);
 	os_hnd = NULL;
diff --git a/unix/selector.c b/unix/selector.c
index b25023e..f92b244 100644
--- a/unix/selector.c
+++ b/unix/selector.c
@@ -38,8 +38,9 @@
    things happen on those file descriptors this code will call
    routines registered with it. */
 
-#include <OpenIPMI/selector.h>
-#include <OpenIPMI/os_handler.h>
+#include "config.h"
+
+#include "OpenIPMI/selector.h"
 
 #include <sys/time.h>
 #include <time.h>
@@ -47,9 +48,17 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <errno.h>
+#include <stdio.h>
 #include <syslog.h>
 #include <signal.h>
 #include <string.h>
+#ifdef HAVE_EPOLL_PWAIT
+#include <sys/epoll.h>
+#else
+#define EPOLL_CTL_ADD 0
+#define EPOLL_CTL_DEL 0
+#define EPOLL_CTL_MOD 0
+#endif
 
 typedef struct fd_state_s
 {
@@ -88,6 +97,18 @@ typedef struct heap_val_s
 
     /* Am I currently running? */
     int in_heap;
+
+    /* Am I currently stopped? */
+    int stopped;
+
+    /* Have I been freed? */
+    int freed;
+
+    /* Am I currently in a handler? */
+    int in_handler;
+
+    sel_timeout_handler_t done_handler;
+    void *done_cb_data;
 } heap_val_t;
 
 typedef struct theap_s theap_t;
@@ -143,6 +164,15 @@ typedef struct sel_wait_list_s
     struct sel_wait_list_s *next, *prev;
 } sel_wait_list_t;
 
+struct sel_runner_s
+{
+    selector_t *sel;
+    sel_runner_func_t func;
+    void *cb_data;
+    int in_use;
+    sel_runner_t *next;
+};
+
 struct selector_s
 {
     /* This is an array of all the file descriptors possible.  This is
@@ -156,31 +186,62 @@ struct selector_s
     volatile fd_set write_set;
     volatile fd_set except_set;
 
-    os_hnd_lock_t *fd_lock;
-    int           have_fd_lock;
-
     volatile int maxfd; /* The largest file descriptor registered with
 			   this code. */
 
+    void *fd_lock;
+
     /* The timer heap. */
     theap_t timer_heap;
 
-    os_hnd_lock_t *timer_lock;
-    int           have_timer_lock;
-
-    /* Handlers to allow other code to work with the select. */
-    ipmi_sel_add_read_fds_cb   add_read;
-    ipmi_sel_check_read_fds_cb check_read;
-    ipmi_sel_check_timeout_cb  check_timeout;
-    void                       *read_cb_data;
-
-    os_handler_t *os_hnd;
-
     /* This is a list of items waiting to be woken up because they are
        sitting in a select.  See wake_sel_thread() for more info. */
     sel_wait_list_t wait_list;
+
+    void *timer_lock;
+
+    sel_runner_t *runner_head;
+    sel_runner_t *runner_tail;
+
+    int wake_sig;
+
+#ifdef HAVE_EPOLL_PWAIT
+    int epollfd;
+#endif
+    sel_lock_t *(*sel_lock_alloc)(void *cb_data);
+    void (*sel_lock_free)(sel_lock_t *);
+    void (*sel_lock)(sel_lock_t *);
+    void (*sel_unlock)(sel_lock_t *);
 };
 
+static void
+sel_timer_lock(selector_t *sel)
+{
+    if (sel->sel_lock)
+	sel->sel_lock(sel->timer_lock);
+}
+
+static void
+sel_timer_unlock(selector_t *sel)
+{
+    if (sel->sel_lock)
+	sel->sel_unlock(sel->timer_lock);
+}
+
+static void
+sel_fd_lock(selector_t *sel)
+{
+    if (sel->sel_lock)
+	sel->sel_lock(sel->fd_lock);
+}
+
+static void
+sel_fd_unlock(selector_t *sel)
+{
+    if (sel->sel_lock)
+	sel->sel_unlock(sel->fd_lock);
+}
+
 /* This function will wake the SEL thread.  It must be called with the
    timer lock held, because it messes with timeout.
 
@@ -208,6 +269,23 @@ wake_sel_thread(selector_t *sel)
     }
 }
 
+static void
+wake_fd_sel_thread(selector_t *sel)
+{
+    wake_sel_thread(sel);
+    sel_fd_unlock(sel);
+}
+
+static void
+wake_timer_sel_thread(selector_t *sel, volatile sel_timer_t *old_top)
+{
+    if (old_top != theap_get_top(&sel->timer_heap))
+	/* If the top value changed, restart the waiting thread. */
+	wake_sel_thread(sel);
+
+    sel_timer_unlock(sel);
+}
+
 /* Wait list management.  These *must* be called with the timer list
    locked, and the values in the item *must not* change while in the
    list. */
@@ -233,16 +311,6 @@ remove_sel_wait_list(selector_t *sel, sel_wait_list_t *item)
     item->prev->next = item->next;
 }
 
-static void
-wake_sel_thread_lock(selector_t *sel)
-{
-    if (sel->have_timer_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->timer_lock);
-    wake_sel_thread(sel);
-    if (sel->have_timer_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->timer_lock);
-}
-
 /* Initialize a single file descriptor. */
 static void
 init_fd(fd_control_t *fd)
@@ -254,6 +322,36 @@ init_fd(fd_control_t *fd)
     fd->handle_except = NULL;
 }
 
+#ifdef HAVE_EPOLL_PWAIT
+static int
+sel_update_epoll(selector_t *sel, int fd, int op)
+{
+    struct epoll_event event;
+
+    if (sel->epollfd < 0)
+	return 1;
+
+    memset(&event, 0, sizeof(event));
+    event.events = EPOLLONESHOT;
+    event.data.fd = fd;
+    if (FD_ISSET(fd, &sel->read_set))
+	event.events |= EPOLLIN | EPOLLHUP;
+    if (FD_ISSET(fd, &sel->write_set))
+	event.events |= EPOLLOUT;
+    if (FD_ISSET(fd, &sel->write_set))
+	event.events |= EPOLLERR | EPOLLPRI;
+
+    epoll_ctl(sel->epollfd, op, fd, &event);
+    return 0;
+}
+#else
+static int
+sel_update_epoll(selector_t *sel, int fd, int op)
+{
+    return 1;
+}
+#endif
+
 /* Set the handlers for a file descriptor. */
 int
 sel_set_fd_handlers(selector_t        *sel,
@@ -266,6 +364,7 @@ sel_set_fd_handlers(selector_t        *sel,
 {
     fd_control_t *fdc;
     fd_state_t   *state;
+    int          added = 1;
 
     state = malloc(sizeof(*state));
     if (!state)
@@ -274,10 +373,10 @@ sel_set_fd_handlers(selector_t        *sel,
     state->use_count = 0;
     state->done = done;
 
-    if (sel->have_fd_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
+    sel_fd_lock(sel);
     fdc = (fd_control_t *) &(sel->fds[fd]);
     if (fdc->state) {
+	added = 0;
 	fdc->state->deleted = 1;
 	if (fdc->state->use_count == 0) {
 	    if (fdc->state->done)
@@ -291,14 +390,18 @@ sel_set_fd_handlers(selector_t        *sel,
     fdc->handle_write = write_handler;
     fdc->handle_except = except_handler;
 
-    /* Move maxfd up if necessary. */
-    if (fd > sel->maxfd) {
-	sel->maxfd = fd;
-    }
+    if (added) {
+	/* Move maxfd up if necessary. */
+	if (fd > sel->maxfd) {
+	    sel->maxfd = fd;
+	}
 
-    wake_sel_thread_lock(sel);
-    if (sel->have_fd_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
+	if (sel_update_epoll(sel, fd, EPOLL_CTL_ADD)) {
+	    wake_fd_sel_thread(sel);
+	    return 0;
+	}
+    }
+    sel_fd_unlock(sel);
     return 0;
 }
 
@@ -309,8 +412,8 @@ sel_clear_fd_handlers(selector_t *sel,
 		      int        fd)
 {
     fd_control_t *fdc;
-    if (sel->have_fd_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
+
+    sel_fd_lock(sel);
     fdc = (fd_control_t *) &(sel->fds[fd]);
 
     if (fdc->state) {
@@ -321,6 +424,8 @@ sel_clear_fd_handlers(selector_t *sel,
 	    free(fdc->state);
 	}
 	fdc->state = NULL;
+
+	sel_update_epoll(sel, fd, EPOLL_CTL_DEL);
     }
 
     init_fd(fdc);
@@ -335,9 +440,7 @@ sel_clear_fd_handlers(selector_t *sel,
 	}
     }
 
-    wake_sel_thread_lock(sel);
-    if (sel->have_fd_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
+    sel_fd_unlock(sel);
 }
 
 /* Set whether the file descriptor will be monitored for data ready to
@@ -345,16 +448,28 @@ sel_clear_fd_handlers(selector_t *sel,
 void
 sel_set_fd_read_handler(selector_t *sel, int fd, int state)
 {
-    if (sel->have_fd_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
+    fd_control_t *fdc = (fd_control_t *) &(sel->fds[fd]);
+
+    sel_fd_lock(sel);
+    if (!fdc->state)
+	goto out;
+
     if (state == SEL_FD_HANDLER_ENABLED) {
+	if (FD_ISSET(fd, &sel->read_set))
+	    goto out;
 	FD_SET(fd, &sel->read_set);
     } else if (state == SEL_FD_HANDLER_DISABLED) {
+	if (!FD_ISSET(fd, &sel->read_set))
+	    goto out;
 	FD_CLR(fd, &sel->read_set);
     }
-    wake_sel_thread_lock(sel);
-    if (sel->have_fd_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
+    if (sel_update_epoll(sel, fd, EPOLL_CTL_MOD)) {
+	wake_fd_sel_thread(sel);
+	return;
+    }
+
+ out:
+    sel_fd_unlock(sel);
 }
 
 /* Set whether the file descriptor will be monitored for when the file
@@ -362,16 +477,28 @@ sel_set_fd_read_handler(selector_t *sel, int fd, int state)
 void
 sel_set_fd_write_handler(selector_t *sel, int fd, int state)
 {
-    if (sel->have_fd_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
+    fd_control_t *fdc = (fd_control_t *) &(sel->fds[fd]);
+
+    sel_fd_lock(sel);
+    if (!fdc->state)
+	goto out;
+
     if (state == SEL_FD_HANDLER_ENABLED) {
+	if (FD_ISSET(fd, &sel->write_set))
+	    goto out;
 	FD_SET(fd, &sel->write_set);
     } else if (state == SEL_FD_HANDLER_DISABLED) {
+	if (!FD_ISSET(fd, &sel->write_set))
+	    goto out;
 	FD_CLR(fd, &sel->write_set);
     }
-    wake_sel_thread_lock(sel);
-    if (sel->have_fd_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
+    if (sel_update_epoll(sel, fd, EPOLL_CTL_MOD)) {
+	wake_fd_sel_thread(sel);
+	return;
+    }
+
+ out:
+    sel_fd_unlock(sel);
 }
 
 /* Set whether the file descriptor will be monitored for exceptions
@@ -379,16 +506,28 @@ sel_set_fd_write_handler(selector_t *sel, int fd, int state)
 void
 sel_set_fd_except_handler(selector_t *sel, int fd, int state)
 {
-    if (sel->have_fd_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
+    fd_control_t *fdc = (fd_control_t *) &(sel->fds[fd]);
+
+    sel_fd_lock(sel);
+    if (!fdc->state)
+	goto out;
+
     if (state == SEL_FD_HANDLER_ENABLED) {
+	if (FD_ISSET(fd, &sel->except_set))
+	    goto out;
 	FD_SET(fd, &sel->except_set);
     } else if (state == SEL_FD_HANDLER_DISABLED) {
+	if (!FD_ISSET(fd, &sel->except_set))
+	    goto out;
 	FD_CLR(fd, &sel->except_set);
     }
-    wake_sel_thread_lock(sel);
-    if (sel->have_fd_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
+    if (sel_update_epoll(sel, fd, EPOLL_CTL_MOD)) {
+	wake_fd_sel_thread(sel);
+	return;
+    }
+
+ out:
+    sel_fd_unlock(sel);
 }
 
 static void
@@ -426,11 +565,12 @@ sel_alloc_timer(selector_t            *sel,
     timer = malloc(sizeof(*timer));
     if (!timer)
 	return ENOMEM;
+    memset(timer, 0, sizeof(*timer));
 
     timer->val.handler = handler;
     timer->val.user_data = user_data;
-    timer->val.in_heap = 0;
     timer->val.sel = sel;
+    timer->val.stopped = 1;
     *new_timer = timer;
 
     return 0;
@@ -440,15 +580,18 @@ int
 sel_free_timer(sel_timer_t *timer)
 {
     selector_t *sel = timer->val.sel;
+    int in_handler;
 
-    if (sel->have_timer_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->timer_lock);
+    sel_timer_lock(sel);
     if (timer->val.in_heap) {
 	sel_stop_timer(timer);
     }
-    if (sel->have_timer_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->timer_lock);
-    free(timer);
+    timer->val.freed = 1;
+    in_handler = timer->val.in_handler;
+    sel_timer_unlock(sel);
+
+    if (!in_handler)
+	free(timer);
 
     return 0;
 }
@@ -460,26 +603,25 @@ sel_start_timer(sel_timer_t    *timer,
     selector_t *sel = timer->val.sel;
     volatile sel_timer_t *top;
 
-    if (sel->have_timer_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->timer_lock);
+    sel_timer_lock(sel);
     if (timer->val.in_heap) {
-	if (sel->have_timer_lock)
-	    sel->os_hnd->unlock(sel->os_hnd, sel->timer_lock);
+	sel_timer_unlock(sel);
 	return EBUSY;
     }
 
-    top = theap_get_top(&timer->val.sel->timer_heap);
+    top = theap_get_top(&sel->timer_heap);
 
     timer->val.timeout = *timeout;
-    theap_add(&timer->val.sel->timer_heap, timer);
-    timer->val.in_heap = 1;
 
-    if (top != theap_get_top(&timer->val.sel->timer_heap))
-	/* If the top value changed, restart the waiting thread. */
-	wake_sel_thread(timer->val.sel);
+    if (!timer->val.in_handler) {
+	/* Wait until the handler returns to start the timer. */
+	theap_add(&sel->timer_heap, timer);
+	timer->val.in_heap = 1;
+    }
+    timer->val.stopped = 0;
+
+    wake_timer_sel_thread(sel, top);
 
-    if (sel->have_timer_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->timer_lock);
     return 0;
 }
 
@@ -489,31 +631,62 @@ sel_stop_timer(sel_timer_t *timer)
     selector_t *sel = timer->val.sel;
     volatile sel_timer_t *top;
 
-    if (sel->have_timer_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->timer_lock);
-    if (!timer->val.in_heap) {
-	if (sel->have_timer_lock)
-	    sel->os_hnd->unlock(sel->os_hnd, sel->timer_lock);
+    sel_timer_lock(sel);
+    if (timer->val.stopped) {
+	sel_timer_unlock(sel);
 	return ETIMEDOUT;
     }
 
-    top = theap_get_top(&timer->val.sel->timer_heap);
+    if (timer->val.in_heap) {
+	top = theap_get_top(&sel->timer_heap);
 
-    theap_remove(&timer->val.sel->timer_heap, timer);
-    timer->val.in_heap = 0;
+	theap_remove(&sel->timer_heap, timer);
+	timer->val.in_heap = 0;
+	wake_timer_sel_thread(sel, top);
+    }
+    timer->val.stopped = 1;
 
-    if (top != theap_get_top(&timer->val.sel->timer_heap))
-	/* If the top value changed, restart the waiting thread. */
-	wake_sel_thread(timer->val.sel);
+    return 0;
+}
+
+int
+sel_stop_timer_with_done(sel_timer_t *timer,
+			 sel_timeout_handler_t done_handler,
+			 void *cb_data)
+{
+    selector_t *sel = timer->val.sel;
+    volatile sel_timer_t *top;
 
-    if (sel->have_timer_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->timer_lock);
+    sel_timer_lock(sel);
+    if (timer->val.stopped) {
+	sel_timer_unlock(sel);
+	goto out;
+    }
+
+    if (timer->val.in_handler) {
+	timer->val.done_handler = done_handler;
+	timer->val.done_cb_data = cb_data;
+	sel_timer_unlock(sel);
+	return 0;
+    }
+
+    if (timer->val.in_heap) {
+	top = theap_get_top(&sel->timer_heap);
+
+	theap_remove(&sel->timer_heap, timer);
+	timer->val.in_heap = 0;
+
+	wake_timer_sel_thread(sel, top);
+    }
+    timer->val.stopped = 1;
 
+ out:
+    done_handler(sel, timer, cb_data);
     return 0;
 }
 
-static void
-get_monotonic_time(struct timeval *tv)
+void
+sel_get_monotonic_time(struct timeval *tv)
 {
     struct timespec ts;
 
@@ -522,7 +695,7 @@ get_monotonic_time(struct timeval *tv)
     tv->tv_usec = (ts.tv_nsec + 500) / 1000;
 }
 
-/* 
+/*
  * Process timers on selector.  The timeout is always set, to a very
  * long value if no timers are waiting.  Note that this *must* be
  * called with sel->timer_lock held.  Note that if this processes
@@ -535,20 +708,35 @@ process_timers(selector_t	       *sel,
     struct timeval now;
     sel_timer_t    *timer;
     int            called = 0;
-    
+
     timer = theap_get_top(&sel->timer_heap);
-    get_monotonic_time(&now);
+    sel_get_monotonic_time(&now);
     while (timer && cmp_timeval(&now, &timer->val.timeout) >= 0) {
 	called = 1;
 	theap_remove(&(sel->timer_heap), timer);
 	timer->val.in_heap = 0;
-	if (sel->have_timer_lock)
-	    sel->os_hnd->unlock(sel->os_hnd, sel->timer_lock);
-	
+	timer->val.stopped = 1;
+	timer->val.in_handler = 1;
+	sel_timer_unlock(sel);
 	timer->val.handler(sel, timer, timer->val.user_data);
-	
-	if (sel->have_timer_lock)
-	    sel->os_hnd->lock(sel->os_hnd, sel->timer_lock);
+	sel_timer_lock(sel);
+	timer->val.in_handler = 0;
+	if (timer->val.done_handler) {
+	    sel_timeout_handler_t done_handler = timer->val.done_handler;
+	    void *done_cb_data = timer->val.done_cb_data;
+	    timer->val.done_handler = NULL;
+	    sel_timer_unlock(sel);
+	    done_handler(sel, timer, done_cb_data);
+	    sel_timer_lock(sel);
+	}
+	if (timer->val.freed)
+	    free(timer);
+	else if (!timer->val.stopped) {
+	    /* We were restarted while in the handler. */
+	    theap_add(&sel->timer_heap, timer);
+	    timer->val.in_heap = 1;
+	}
+
 	timer = theap_get_top(&sel->timer_heap);
     }
 
@@ -557,7 +745,7 @@ process_timers(selector_t	       *sel,
 	timeout->tv_sec = 0;
 	timeout->tv_usec = 0;
     } else if (timer) {
-	get_monotonic_time(&now);
+	sel_get_monotonic_time(&now);
 	diff_timeval((struct timeval *) timeout,
 		     (struct timeval *) &timer->val.timeout,
 		     &now);
@@ -568,16 +756,124 @@ process_timers(selector_t	       *sel,
     }
 }
 
+int
+sel_alloc_runner(selector_t *sel, sel_runner_t **new_runner)
+{
+    sel_runner_t *runner;
+
+    runner = malloc(sizeof(*runner));
+    if (!runner)
+	return ENOMEM;
+    memset(runner, 0, sizeof(*runner));
+    runner->sel = sel;
+    *new_runner = runner;
+    return 0;
+}
+
+int
+sel_free_runner(sel_runner_t *runner)
+{
+    selector_t *sel = runner->sel;
+
+    sel_timer_lock(sel);
+    if (runner->in_use) {
+	sel_timer_unlock(sel);
+	return EBUSY;
+    }
+    sel_timer_unlock(sel);
+    free(runner);
+    return 0;
+}
+
+int
+sel_run(sel_runner_t *runner, sel_runner_func_t func, void *cb_data)
+{
+    selector_t *sel = runner->sel;
+
+    sel_timer_lock(sel);
+    if (runner->in_use) {
+	sel_timer_unlock(sel);
+	return EBUSY;
+    }
+
+    runner->func = func;
+    runner->cb_data = cb_data;
+    runner->next = NULL;
+    runner->in_use = 1;
+
+    if (sel->runner_tail) {
+	sel->runner_tail->next = runner;
+	sel->runner_tail = runner;
+    } else {
+	sel->runner_head = runner;
+	sel->runner_tail = runner;
+    }
+    sel_timer_unlock(sel);
+    return 0;
+}
+
+static void
+process_runners(selector_t *sel)
+{
+    while (sel->runner_head) {
+	sel_runner_t *runner = sel->runner_head;
+	sel_runner_func_t func;
+	void *cb_data;
+
+	sel->runner_head = sel->runner_head->next;
+	if (!sel->runner_head)
+	    sel->runner_tail = NULL;
+	runner->in_use = 0;
+	func = runner->func;
+	cb_data = runner->cb_data;
+	sel_timer_unlock(sel);
+	func(runner, cb_data);
+	sel_timer_lock(sel);
+    }
+}
+
+static void
+handle_selector_call(selector_t *sel, int i, volatile fd_set *fdset,
+		     sel_fd_handler_t handler)
+{
+    void             *data;
+    fd_state_t       *state;
+
+    if (handler == NULL) {
+	/* Somehow we don't have a handler for this.
+	   Just shut it down. */
+	FD_CLR(i, fdset);
+	return;
+    }
+
+    if (!FD_ISSET(i, fdset))
+	/* The value was cleared, ignore it. */
+	return;
+
+    data = sel->fds[i].data;
+    state = sel->fds[i].state;
+    state->use_count++;
+    sel_fd_unlock(sel);
+    handler(i, data);
+    sel_fd_lock(sel);
+    state->use_count--;
+    if (state->deleted && state->use_count == 0) {
+	if (state->done) {
+	    sel_fd_unlock(sel);
+	    state->done(i, data);
+	    sel_fd_lock(sel);
+	}
+	free(state);
+    }
+}
+
 /*
  * return == 0  when timeout
- * 	  >  0  when successful 
+ * 	  >  0  when successful
  * 	  <  0  when error
  */
 static int
 process_fds(selector_t	            *sel,
-	    sel_send_sig_cb         send_sig,
-	    long                    thread_id,
-	    void                    *cb_data,
 	    volatile struct timeval *timeout)
 {
     fd_set      tmp_read_set;
@@ -586,144 +882,90 @@ process_fds(selector_t	            *sel,
     int i;
     int err;
     int num_fds;
-    
-    if (sel->have_fd_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
+
+    sel_fd_lock(sel);
     memcpy(&tmp_read_set, (void *) &sel->read_set, sizeof(tmp_read_set));
     memcpy(&tmp_write_set, (void *) &sel->write_set, sizeof(tmp_write_set));
     memcpy(&tmp_except_set, (void *) &sel->except_set, sizeof(tmp_except_set));
     num_fds = sel->maxfd+1;
-    if (sel->add_read) {
-	int timeout_invalid;
-	struct timeval ttimeout;
-
-	timeout_invalid = 1; 
-	sel->add_read(sel, &num_fds, &tmp_read_set,
-		      &ttimeout, &timeout_invalid,
-		      sel->read_cb_data);
-	if (!timeout_invalid
-	    && (cmp_timeval(&ttimeout, (struct timeval *)timeout) <= 0))
-	{
-	    *timeout= ttimeout;
-	}	      
-    }
-    if (sel->have_fd_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
+    sel_fd_unlock(sel);
 
     err = select(num_fds,
 		 &tmp_read_set,
 		 &tmp_write_set,
 		 &tmp_except_set,
 		 (struct timeval *) timeout);
-    if (err <= 0) {
-	if ((err == 0) && (sel->check_timeout))
-	    sel->check_timeout(sel, sel->read_cb_data);
+    if (err <= 0)
 	goto out;
-    }
 
-    if (sel->check_read)
-	sel->check_read(sel, &tmp_read_set, sel->read_cb_data);
-    
     /* We got some I/O. */
-    for (i=0; i<=sel->maxfd; i++) {
-	if (FD_ISSET(i, &tmp_read_set)) {
-	    sel_fd_handler_t handle_read;
-	    void             *data;
-	    fd_state_t       *state;
-
-	    if (sel->have_fd_lock)
-		sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
-	    if (sel->fds[i].handle_read == NULL) {
-		/* Somehow we don't have a handler for this.
-		   Just shut it down. */
-		sel_set_fd_read_handler(sel, i, SEL_FD_HANDLER_DISABLED);
-	    } else {
-		handle_read = sel->fds[i].handle_read;
-		data = sel->fds[i].data;
-		state = sel->fds[i].state;
-		state->use_count++;
-		if (sel->have_fd_lock)
-		    sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
-		handle_read(i, data);
-		if (sel->have_fd_lock)
-		    sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
-		state->use_count--;
-		if (state->deleted && state->use_count == 0) {
-		    if (state->done)
-			state->done(i, data);
-		    free(state);
-		}
-	    }
-	    if (sel->have_fd_lock)
-		sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
-	}
-	if (FD_ISSET(i, &tmp_write_set)) {
-	    sel_fd_handler_t handle_write;
-	    void             *data;
-	    fd_state_t       *state;
-
-	    if (sel->have_fd_lock)
-		sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
-	    if (sel->fds[i].handle_write == NULL) {
-		/* Somehow we don't have a handler for this.
-                   Just shut it down. */
-		sel_set_fd_write_handler(sel, i, SEL_FD_HANDLER_DISABLED);
-	    } else {
-		handle_write = sel->fds[i].handle_write;
-		data = sel->fds[i].data;
-		state = sel->fds[i].state;
-		state->use_count++;
-		if (sel->have_fd_lock)
-		    sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
-		handle_write(i, data);
-		if (sel->have_fd_lock)
-		    sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
-		state->use_count--;
-		if (state->deleted && state->use_count == 0) {
-		    if (state->done)
-			state->done(i, data);
-		    free(state);
-		}
-	    }
-	    if (sel->have_fd_lock)
-		sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
-	}
-	if (FD_ISSET(i, &tmp_except_set)) {
-	    sel_fd_handler_t handle_except;
-	    void             *data;
-	    fd_state_t       *state;
-
-	    if (sel->have_fd_lock)
-		sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
-	    if (sel->fds[i].handle_except == NULL) {
-		/* Somehow we don't have a handler for this.
-                   Just shut it down. */
-		sel_set_fd_except_handler(sel, i, SEL_FD_HANDLER_DISABLED);
-	    } else {
-	        handle_except = sel->fds[i].handle_except;
-		data = sel->fds[i].data;
-		state = sel->fds[i].state;
-		state->use_count++;
-		if (sel->have_fd_lock)
-		    sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
-	        handle_except(i, data);
-		if (sel->have_fd_lock)
-		    sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
-		state->use_count--;
-		if (state->deleted && state->use_count == 0) {
-		    if (state->done)
-			state->done(i, data);
-		    free(state);
-		}
-	    }
-	    if (sel->have_fd_lock)
-		sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
-	}
+    sel_fd_lock(sel);
+    for (i = 0; i <= sel->maxfd; i++) {
+	if (FD_ISSET(i, &tmp_read_set))
+	    handle_selector_call(sel, i, &sel->read_set,
+				 sel->fds[i].handle_read);
+	if (FD_ISSET(i, &tmp_write_set))
+	    handle_selector_call(sel, i, &sel->write_set,
+				 sel->fds[i].handle_write);
+	if (FD_ISSET(i, &tmp_except_set))
+	    handle_selector_call(sel, i, &sel->except_set,
+				 sel->fds[i].handle_except);
     }
+    sel_fd_unlock(sel);
 out:
     return err;
 }
 
+#ifdef HAVE_EPOLL_PWAIT
+static int
+process_fds_epoll(selector_t *sel, struct timeval *tvtimeout)
+{
+    int rv, fd;
+    struct epoll_event event;
+    int timeout;
+    sigset_t sigmask;
+
+    if (tvtimeout->tv_sec > 600)
+	 /* Don't wait over 10 minutes, to work around an old epoll bug
+	    and avoid issues with timeout overflowing on 64-bit systems,
+	    which is much larger that 10 minutes, but who cares. */
+	timeout = 600 * 1000;
+    else
+	timeout = ((tvtimeout->tv_sec * 1000) +
+		   (tvtimeout->tv_usec + 999) / 1000);
+
+#ifdef USE_PTHREADS
+    pthread_sigmask(SIG_SETMASK, NULL, &sigmask);
+#else
+    sigprocmask(SIG_SETMASK, NULL, &sigmask);
+#endif
+    sigdelset(&sigmask, sel->wake_sig);
+    rv = epoll_pwait(sel->epollfd, &event, 1, timeout, &sigmask);
+
+    if (rv <= 0)
+	return rv;
+
+    sel_fd_lock(sel);
+    fd = event.data.fd;
+    if (event.events & (EPOLLIN | EPOLLHUP))
+	handle_selector_call(sel, fd, &sel->read_set,
+			     sel->fds[fd].handle_read);
+    if (event.events & EPOLLOUT)
+	handle_selector_call(sel, fd, &sel->write_set,
+			     sel->fds[fd].handle_write);
+    if (event.events & (EPOLLERR | EPOLLPRI))
+	handle_selector_call(sel, fd, &sel->except_set,
+			     sel->fds[fd].handle_except);
+
+    /* Rearm the event.  Remember it could have been deleted in the handler. */
+    if (sel->fds[fd].state)
+	sel_update_epoll(sel, fd, EPOLL_CTL_MOD);
+    sel_fd_unlock(sel);
+
+    return 0;
+}
+#endif
+
 int
 sel_select(selector_t      *sel,
 	   sel_send_sig_cb send_sig,
@@ -735,25 +977,28 @@ sel_select(selector_t      *sel,
     struct timeval  loc_timeout;
     sel_wait_list_t wait_entry;
 
-    if (sel->have_timer_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->timer_lock);
+    sel_timer_lock(sel);
+    process_runners(sel);
     process_timers(sel, (struct timeval *)(&loc_timeout));
-    if (timeout) { 
+    if (timeout) {
 	if (cmp_timeval((struct timeval *)(&loc_timeout), timeout) >= 0)
 	    memcpy(&loc_timeout, timeout, sizeof(loc_timeout));
     }
     add_sel_wait_list(sel, &wait_entry, send_sig, cb_data, thread_id,
 		      &loc_timeout);
-    if (sel->have_timer_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->timer_lock);
+    sel_timer_unlock(sel);
 
-    err = process_fds(sel, send_sig, thread_id, cb_data, &loc_timeout);
+#ifdef HAVE_EPOLL_PWAIT
+    if (sel->epollfd >= 0)
+	err = process_fds_epoll(sel, &loc_timeout);
+    else
+#endif
+	err = process_fds(sel, &loc_timeout);
 
-    if (sel->have_timer_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->timer_lock);
+    sel_timer_lock(sel);
     remove_sel_wait_list(sel, &wait_entry);
-    if (sel->have_timer_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->timer_lock);
+    sel_timer_unlock(sel);
+
     return err;
 }
 
@@ -770,7 +1015,7 @@ sel_select_loop(selector_t      *sel,
 
     for (;;) {
 	err = sel_select(sel, send_sig, thread_id, cb_data, NULL);
-    	if ((err < 0) && (errno != EINTR)) {
+	if ((err < 0) && (errno != EINTR)) {
 	    err = errno;
 	    /* An error occurred. */
 	    /* An error is bad, we need to abort. */
@@ -780,59 +1025,33 @@ sel_select_loop(selector_t      *sel,
     }
 }
 
-void
-ipmi_sel_set_read_fds_handler(selector_t                 *sel, 
-			      ipmi_sel_add_read_fds_cb   add,
-			      ipmi_sel_check_read_fds_cb handle,
-			      ipmi_sel_check_timeout_cb  timeout,
-			      void                       *cb_data)
-{
-    if (sel->have_fd_lock)
-	sel->os_hnd->lock(sel->os_hnd, sel->fd_lock);
-    sel->add_read = add;
-    sel->check_read = handle;
-    sel->check_timeout = timeout;
-    sel->read_cb_data = cb_data;
-    if (sel->have_fd_lock)
-	sel->os_hnd->unlock(sel->os_hnd, sel->fd_lock);
-}
-
 /* Initialize the select code. */
 int
-sel_alloc_selector(os_handler_t *os_hnd, selector_t **new_selector)
+sel_alloc_selector_thread(selector_t **new_selector, int wake_sig,
+			  sel_lock_t *(*sel_lock_alloc)(void *cb_data),
+			  void (*sel_lock_free)(sel_lock_t *),
+			  void (*sel_lock)(sel_lock_t *),
+			  void (*sel_unlock)(sel_lock_t *),
+			  void *cb_data)
 {
     selector_t *sel;
-    unsigned int        i;
-    int        rv;
+    unsigned int i;
 
     sel = malloc(sizeof(*sel));
     if (!sel)
 	return ENOMEM;
     memset(sel, 0, sizeof(*sel));
 
-    sel->os_hnd = os_hnd;
+    sel->sel_lock_alloc = sel_lock_alloc;
+    sel->sel_lock_free = sel_lock_free;
+    sel->sel_lock = sel_lock;
+    sel->sel_unlock = sel_unlock;
 
     /* The list is initially empty. */
     sel->wait_list.next = &sel->wait_list;
     sel->wait_list.prev = &sel->wait_list;
 
-    rv = 0;
-    if (sel->os_hnd->create_lock) {
-	rv = sel->os_hnd->create_lock(sel->os_hnd, &sel->timer_lock);
-	if (!rv)
-	    sel->have_timer_lock = 1;
-    }
-    if (rv)
-	goto out_err;
-
-    rv = 0;
-    if (sel->os_hnd->create_lock) {
-	rv = sel->os_hnd->create_lock(sel->os_hnd, &sel->fd_lock);
-	if (!rv)
-	    sel->have_fd_lock = 1;
-    }
-    if (rv)
-	goto out_err;
+    sel->wake_sig = wake_sig;
 
     FD_ZERO((fd_set *) &sel->read_set);
     FD_ZERO((fd_set *) &sel->write_set);
@@ -844,17 +1063,54 @@ sel_alloc_selector(os_handler_t *os_hnd, selector_t **new_selector)
 
     theap_init(&sel->timer_heap);
 
-    *new_selector = sel;
+    if (sel->sel_lock_alloc) {
+	sel->timer_lock = sel->sel_lock_alloc(cb_data);
+	if (!sel->timer_lock) {
+	    free(sel);
+	    return ENOMEM;
+	}
+	sel->fd_lock = sel->sel_lock_alloc(cb_data);
+	if (!sel->fd_lock) {
+	    sel->sel_lock_free(sel->fd_lock);
+	    free(sel);
+	    return ENOMEM;
+	}
+    }
 
- out_err:
-    if (rv) {
-	if (sel->have_timer_lock)
-	    sel->os_hnd->destroy_lock(sel->os_hnd, sel->timer_lock);
-	if (sel->have_fd_lock)
-	    sel->os_hnd->destroy_lock(sel->os_hnd, sel->fd_lock);
-	free(sel);
+#ifdef HAVE_EPOLL_PWAIT
+    sel->epollfd = epoll_create(32768);
+    if (sel->epollfd == -1) {
+	syslog(LOG_ERR, "Unable to set up epoll, falling back to select: %m");
+    } else {
+	int rv;
+	sigset_t sigset;
+
+	sigemptyset(&sigset);
+	sigaddset(&sigset, wake_sig);
+	rv = sigprocmask(SIG_BLOCK, &sigset, NULL);
+	if (rv == -1) {
+	    rv = errno;
+	    close(sel->epollfd);
+	    if (sel->sel_lock_alloc) {
+		sel->sel_lock_free(sel->fd_lock);
+		sel->sel_lock_free(sel->timer_lock);
+	    }
+	    free(sel);
+	    return rv;
+	}
     }
-    return rv;
+#endif
+
+    *new_selector = sel;
+
+    return 0;
+}
+
+int
+sel_alloc_selector_nothread(selector_t **new_selector)
+{
+    return sel_alloc_selector_thread(new_selector, 0, NULL, NULL, NULL, NULL,
+				     NULL);
 }
 
 int
@@ -862,18 +1118,76 @@ sel_free_selector(selector_t *sel)
 {
     sel_timer_t *elem;
 
-    if (sel->have_timer_lock)
-	sel->os_hnd->destroy_lock(sel->os_hnd, sel->timer_lock);
-    if (sel->have_fd_lock)
-	sel->os_hnd->destroy_lock(sel->os_hnd, sel->fd_lock);
-
     elem = theap_get_top(&(sel->timer_heap));
     while (elem) {
 	theap_remove(&(sel->timer_heap), elem);
 	free(elem);
 	elem = theap_get_top(&(sel->timer_heap));
     }
+#ifdef HAVE_EPOLL_PWAIT
+    if (sel->epollfd >= 0)
+	close(sel->epollfd);
+#endif
+    if (sel->fd_lock)
+	sel->sel_lock_free(sel->fd_lock);
+    if (sel->timer_lock)
+	sel->sel_lock_free(sel->timer_lock);
     free(sel);
 
     return 0;
 }
+
+/* DEPRECATED - do not use. */
+struct sel_lock_s
+{
+    os_handler_t *os_hnd;
+    os_hnd_lock_t *lock;
+};
+
+static sel_lock_t *
+slock_alloc(void *cb_data)
+{
+    os_handler_t *os_hnd = cb_data;
+    sel_lock_t *l;
+
+    l = os_hnd->mem_alloc(sizeof(*l));
+    if (!l)
+	return NULL;
+    l->os_hnd = os_hnd;
+    if (os_hnd->create_lock(os_hnd, &l->lock)) {
+	os_hnd->mem_free(l);
+	l = NULL;
+    }
+    return l;
+}
+
+static void
+slock_free(sel_lock_t *l)
+{
+    l->os_hnd->destroy_lock(l->os_hnd, l->lock);
+    l->os_hnd->mem_free(l);
+}
+
+static void
+slock_lock(sel_lock_t *l)
+{
+    l->os_hnd->lock(l->os_hnd, l->lock);
+}
+
+static void
+slock_unlock(sel_lock_t *l)
+{
+    l->os_hnd->unlock(l->os_hnd, l->lock);
+}
+
+int
+sel_alloc_selector(os_handler_t *os_hnd, selector_t **new_selector)
+{
+    if (os_hnd->create_lock)
+	return sel_alloc_selector_thread(new_selector, 0,
+					 slock_alloc, slock_free,
+					 slock_lock, slock_unlock, os_hnd);
+    else
+	return sel_alloc_selector_thread(new_selector, 0, NULL, NULL, NULL,
+					 NULL, NULL);
+}
